<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络与信息安全复习]]></title>
    <url>%2F2018%2F11%2F04%2Freview%2F</url>
    <content type="text"><![CDATA[第一章安全攻击分类被动攻击：信息内容泄露、流量分析主动攻击：伪装、重播、消息修改、拒绝服务 安全服务认证：保证通信的真实性。确保通信双方的身份是可信的。访问控制：防止资源非授权使用数据保密性：防止传输消息受到被动攻击。数据完整性：与主动攻击有关，检测而不是阻止。不可否认性：防止通信方对通信行为的否认，包括源不可否认性和宿不可否认性。可用性：系统或系统资源能够按照要求根据系统性能规范被授权系统的实体访问和使用。 第二章理论安全与实际安全理论安全：攻击者无论截获多少密文，都无法得到足够的信息来唯一地决定明文。香农证明只有一次一密才能达到理论安全，不实用。实际安全（计算安全）：在有限的资源内，攻击者都不能通过系统的分析方法来破解系统。 密码体制对称密码体制与非对称密码体制对称密码：加密密钥和解密密钥相同，或者一个密钥可以从另一个导出，能加密就能解密，加密能力和解密能力是结合在一起的，开放性差。非对称密码：加密密钥和解密密钥不相同，从一个密钥导出另一个密钥是计算上不可行的，加密能力和解密能力是分开的，开放性好。 序列密码体制和分组密码体制序列密码：密文不仅与最初给定的算法和密钥有关，同时也与明文位置有关(是所处位置的函数)。分组密码：经过加密所得到的密文仅与给定的密码算法和密钥有关，与被处理的明文数据在整个明文中的位置无关。 确定型密码体制和概率型密码体制确定型密码:当明文和密钥确定后，密文也就唯一地确定了。概率密码：当明文和密钥确定后，密文通过客观随机因素从一个密文集合中产生，密文形式不确定。 单向函数型密码体制和双向变换型密码体制单向函数型密码体制：适用于不需要解密的场合，容易将明文加密成密文，如哈希函数。双向变换型密码体制：可以进行可逆的加密、解密变换。 现代密码学的基本原则设计加密系统时，总是假定密码算法是可以公开的，需要保密的是密钥。一个密码系统的安全性不在算法的保密，而在于密钥，即Kerckhoff原则。 对加密系统的要求系统应该是实际安全的(practical secure)，截获密文或已知明文－密文对时，要决定密钥或任意明文在计算上是不可行的。加密解密算法适用于密钥空间中的所有元素。系统易于实现，使用方便。系统的安全性不依赖于对加密体制或加密算法的保密，而依赖于密钥。系统的使用不应使通信网络的效率过分降低。 对加密信息的攻击类型 攻击类型 攻击者持有的信息 唯密文攻击 加密算法、待解密密文 已知明文攻击 加密算法 、待解密密文、与待解密密文（同一密钥加密）的明密文对 选择明文攻击 加密算法 、待解密密文、攻击者选择的明文及对应的（同一密钥加密）密文 选择密文攻击 加密算法 、待解密密文、攻击者选择的（同一密钥加密）密文及对应的明文 选择文本攻击 加密算法 、待解密密文、攻击者选择的（同一密钥加密）密文及对应的明文、攻击者选择的明文及对应的（同一密钥加密）密文 代换与置换代换法是将明文字母替换成其他字母、数字或符号的加密方法。如果把明文看成是二进制序列的话，代换就是用密文位串来代换明文位串。代换法改变明文内容的表示形式，保持内容元素之间相对位置不变。由于语言的冗余性（即字母单词使用频率的统计特性），单表代换虽然密钥空间很大，但并不安全。置换法是改变明文内容元素的相对位置，保持内容的表现形式不变。通过重新安排消息字母的位置来隐藏明文信息，而不是用其他字母来代换明文字母。这种方法是很容易破译的，因为密文拥有与明文一样的字母频率统计特性。 隐写术隐写术不是加密技术。比如将信息通过改变像素内容隐藏到图片中，不可见的墨水等。 一次一密两个限制：产生大规模随机密钥有实际困难、密钥的分配和保护无法保证 第三章流密码与分组密码流密码：每次加密数据流的一位或一个字节。分组密码：将一个明文分组作为一个整体进行加密，并且一般得到等长的密文。 扩散和混淆扩散：明文统计特征消散在密文中。可以通过让多个明文数字影响一个密文数字，或者每个明文数字可以影响多个密文数字。混淆：使密文和加密密钥之间的统计关系尽量复杂。 Confusion means that each binary digit (bit) of the ciphertext should depend on several parts of the key, obscuring the connections between the two.Diffusion means that if we change a single bit of the plaintext, then (statistically) half of the bits in the ciphertext should change, and similarly, if we change one bit of the ciphertext, then approximately one half of the plaintext bits should change. Since a bit can have only two states, when they are all re-evaluated and changed from one seemingly random position to another, half of the bits will have changed state.In Shannon’s original definitions, confusion refers to making the relationship between the ciphertext and the symmetric key as complex and involved as possible; diffusion refers to dissipating the statistical structure of plaintext over the bulk of ciphertext. This complexity is generally implemented through a well-defined and repeatable series of substitutions and permutations. Substitution refers to the replacement of certain components (usually bits) with other components, following certain rules. Permutation refers to manipulation of the order of bits according to some algorithm. To be effective, any non-uniformity of plaintext bits needs to be redistributed across much larger structures in the ciphertext, making that non-uniformity much harder to detect. 第四章同余给定整数$a, b$及$n≠0$, 当且仅当$a-b=kn$时，$a$与$b$在模$n$时同余，记为$a≡b\ mod\ n$ 或 $a≡nb$。如果$n|(a-b)$, 则$a≡b\ mod\ n$。 模运算$(a1\ op\ a2)\ mod\ n =[(a1\ mod\ n )]\ op\ (a2\ mod\ n)]\ mod\ n$ 乘法逆元如果一个整数与$n$互素，那么它在$Z_n$中存在一个乘法逆元。对于任何一般的模数$n$，如果$a$与$n$互素，那么用乘数$a$作用到$Z_n$(即0,1,2,…,n-1)然后模$n$会得到完整的$Z_n$(元素顺序可能不同，也可以叫做$Z_n$的一个置换)。 Z8 0 1 2 3 4 5 6 7 乘以5 0 5 10 15 20 25 30 35 剩余类 0 5 2 7 4 1 6 3 欧几里得算法与拓展欧几里得算法欧几里得算法又称辗转相除法。欧几里德定理：$ gcd(a, b) = gcd(b , a\%b)$ 拓展欧几里得算法对于不完全为$0$的非负整数 $a，b，gcd（a，b$表示$a，b$的最大公约数，必然存在整数对$x，y$，使得$gcd（a，b）=ax+by$。 第五章双重DES因为对单重DES进行穷举攻击是可行的（密钥长度仅有56位）。双重DES存在着中间相遇攻击。$C = E_{K2}(E_{K1}(P))， P = D_{K1}(D_{K2}(C))$，因为$X = E_{K1}(P) = D_{K2}(C)$，用所有可能的密钥加密明文P并把结果存储起来，然后用所有可能的密钥解密密文C，寻找匹配的X值，因此复杂度只有O($2^{56}$)。攻击单重DES复杂度为O($2^{55}$)。 三重DES使用两个密钥的三重DES$C=E_{K1}[D_{K2}[E_{K1}[P]]$如果$K1=K2$，那么就变成了单重DES，从而实现对单重DES的兼容。 使用三个密钥的三重DES$C = E_{K3}[D_{K2}[E_{K1}[P]]]$如果$K1=K2$或者是$K2=K3$，那么就变成了单重DES，从而实现对单重DES的兼容。 分组密码的工作模式分组密码的安全不仅和秘钥长度有关还和分组长度有关。 电子密码本模式ECB明文分成64的分组进行加密，必要时填充，每个分组用同一密钥加密，相同明文分组加密得相同密文。ECB模式特别适合数据较少的情况，如安全传输DES密钥。一段明文消息中若有几个相同的明文组，则密文也将出现几个相同的片段。对于很长的消息，ECB是不安全的，如果消息是非常结构化的，密码分析可能利用其结构特征来破解。ECB的弱点来源于其加密过的密文分组是互相独立的。优点：操作简单，易于实现；分组独立，可以并行加密；传输错误不会传播。缺点：掩盖不了明文结构信息，可以进行统计分析攻击。 密文分组链接模式CBC加密输入是当前明文分组和前一密文分组的异或，形成一条链，使用相同的密钥， 这样每个明文分组的加密函数输入与明文分组之间不再有固定的关系。每个密文分组依赖于所有明文分组。发送方和接收方需要共享初始向量Initial Value(IV)。如果IV被明文传送，则攻击者可以预先改变IV中的某些位，则接收者收到的P1也就相应改变了。因此，IV必须是一个固定的值或者使用伪随机数、计数器IV用ECB方式在消息之前加密传送。在消息的最后，还要处理不够长度的分组进行填充。明文消息中的任何一点变化都会影响所有的密文分组。优点：能掩盖明文结构信息，保证相同密文可得不同明文，安全性好于ECB；适合传输长度较长的报文。缺点：不可并行；传递错误，即一个分组错误导致后续分组均错误；初始向量IV的选取比较复杂。 密文反馈模式CFB可以视为流密码，不再要求报文被填充成整个分组，可以实时运行，如果要传输一个字符流，每个字符都可以使用面向字符的流密码加密后立即传输。加密：加密函数的输入是一个64位的移位寄存器，产生初始向量IV。加密函数高端s位与明文P1的第一单元异或，产生s位密文C1进入移位寄存器低端，继续加密，与P2输入异或，如此重复直到所有明文单元都完成加密。解密：采用相同方案，但是使用加密函数而非解密函数。设$MSB_s(X)$表示X的最左边s位。则$C1=P1 \bigoplus MSB_s[E(K,IV)]$从而有$P1=C1 \bigoplus MSB_s[E(K,IV)]$如果在传输过程中某一个分组的密文发生改变，则会影响到这个分组及其后的分组的明文正确性。优点：可以实时运行，及时加密小于分组大小的数据；隐藏了明文结构。缺点：不可并行；传输错误会扩散。 输出反馈模式OFB结构上类似CFB，但是OFB中加密函数输出被反馈回移位寄存器，CFB中是密文单元被反馈回移位寄存器（对比两个图，可以看到反馈位置是不同的）。优点是传输中的比特差错不会传播，缺点是比CFB更容易受报文流篡改攻击。OFB的IV必须是时变值。OFB的一个优点是，传输过程中在某位上发生的错误不会影响到其他位。比如，C1中有1位发生了错误，只会影响到P1的恢复，后续的明文单元不受影响。OFB的缺点是，抗消息流篡改攻击的能力不如CFB。即密文中的某位取反，恢复出的明文相应位也取反。优点：可以实时运行，及时加密小于分组大小的数据；隐藏了明文结构；传输过程中在某位上发生的错误不会影响到其他位。缺点：不可以并行；比CFB更容易受报文流篡改攻击。 计数器模式CTR与OFB很像，但是加密的是计数器的值而不是任何反馈回来的值。每一个明文分组都必须使用一个不同的密钥和计数器值，决不要重复使用。高效、可以做并行加密对高速链路的突发数据加密尤其有效可以对被加密的分组进行随机存取安全、简洁不需要填充 第八章费马定理若$p$是素数, $a$是正整数且不能被$p$整除, 则$a^{p-1}\ mod\ p=1$证明：$对于X=\{ a\ mod\ p,2a\ mod\ p,…, (p-1)a\ mod\ p\}$$\because a是正整数且不能被p整除$$\therefore X内的元素均大于零$$假设ja≡ka(modp)，其中1\leqslant j&lt;k\leqslant p-1$$\because a与p互素$$\therefore 两边可以把a消去，则推出j ≡ k(mod p)，与假设矛盾$$也就是说，X内的元素均为正整数且互不相等$$\because \{ a\ mod\ p, 2a\ mod\ p, …, (p-1)a\ mod\ p\} 是\{ 1, 2, …, (p-1)\} 的置换形$$\therefore (aｘ2aｘ … ｘ (p-1)a)≡(1ｘ2ｘ … ｘ(p-1))\ (mod\ p)≡ (p-1)!\ (mod\ p)$$\because aｘ2aｘ…ｘ(p-1)a=(p-1)!a^{p-1}，即 (p-1)!a^{p-1}≡(p-1)!\ (mod\ p)$$两边去掉(p-1)!，即得 a^{p-1}\mod\ p = 1$ 欧拉函数$\varphi (n)$是比n小且与n互素的正整数的个数，定义$\varphi (1)=1$。 欧拉函数定理$p和q是素数, n=p\times q, \varphi (n)= \varphi (p)\varphi (q)=(p-1)(q-1)$证明：$考虑余数集合\{ 0, 1, …, (pq-1)\} 中不与n互素的余数集合是\{ p, 2p, …, (q-1)p\} , \{ q, 2q, …, (p-1)q\}, $$所以\varphi (n)= (pq-1)-[(q-1)+(p-1)]=pq-(p+q)+1= (p-1)(q-1)=\varphi (p)\varphi (q)$ 欧拉定理对任意互素的$a$与$n$，$a^{\varphi (n)} \equiv 1\ (mod\ n)$证明：$若n为素数，则根据\varphi (n)=n-1和a^{p-1}\ mod\ p=1可知成立。但这是不完全的证明。$$考虑集合R=${$x_1,x_2,…,x_{\varphi (n)}$},$每一个元素都有gcd(x_i,n)=1。$$令S=\{ (ax_1\ mod\ n),(ax_2\ mod\ n),…,(ax_{\varphi (n)}\ mod\ n)\}$$S是R的一个置换，因为$$(1) a与n互素，且x_i与n互素，所以ax_i必与n互素，这样S中所有元素均小于n且与n互素。$$(2) S中没有重复元素，因为如果ax_i\equiv ax_j(modn)，则x_i=x_j，显然不成立。$$\prod_{i=1}^{\varphi (n)}(ax_imodn)=\prod_{i=1}^{\varphi (n)}x_i$$\prod_{i=1}^{\varphi (n)}ax_i\equiv \prod_{i=1}^{\varphi (n)}x_i(modn)$$a^{\varphi (n)}\times [\prod_{i=1}^{\varphi (n)}x_i]\equiv \prod_{i=1}^{\varphi (n)}x_i(modn)$$两边同时消去，得到a^{\varphi (n)} \equiv 1(modn)$ 中国剩余定理中国余数定理CRT说明某一范围内的整数可通过它对两两互素的整数取模所得的余数来重构。例如：$Z_{10}(0,1,…,9)$中的10个整数可通过它们对2和5(10的素因子)取模所得的两个余数来重构. 假设数$x$的余数$r_2=0$ 且$r_5=3$, 即$x\ mod\ 2=0$, $x\ mod\ 5=3$, 则$x$是$Z_{10}$中的偶数且被5除余3, 唯一解$x=8$。 一种CRT的表示形式$令M=\prod_{i=1}^{k}m_i, 其中m_i两两互素, 1\leqslant i, j\leqslant k, i≠j, gcd(m_i, m_j)=1。将Z_M中的任一整数对应一个k元组,$$该k元组的元素均在Z_{m_i}中, 对应关系为A\leftrightarrow (a_1,a_2,…,a_k), 其中A∈Z_M, 对1\leqslant i\leqslant k, a_i∈Z_{m_i},$$且a_i = A\ mod\ m_i。$ 计算例子今有物不知其数, 三三数之剩二, 五五数之剩三, 七七数之剩二, 问物几何。(1) 计算$n=3\times 5\times 7$，记$d_1=3,d_2=5,d_3=7$; $r_1=2,r_2=3,r_3=2$(2) 根据$(\frac{n}{d_i})y_i\ mod\ d_i=1$，计算$y_i$$(\frac{105}{3})y_i\ mod\ 3=1 $，得$y_1=2$$(\frac{105}{5})y_i\ mod\ 5=1 $，得$y_2=1$$(\frac{105}{7})y_i\ mod\ 7=1 $，得$y_3=1$(3) $x=[\prod (\frac{n}{d_i})y_ir_i]\ mod\ n$$x=(35\times 2\times 2+21\times 1\times 3+15\times 1\times 2)\ mod\ 105=23$ 第九章对称密码与非对称密码对称密码体制的问题加密能力与解密能力是捆绑在一起的。密钥更换、传递和交换需要可靠信道，密钥分发困难。如有N用户，则需要$C=\frac {N\times (N-1)}{2}$个密钥，n=1000时，C(1000, 2)≈500000, 密钥管理困难。无法满足不相识的人之间通信的保密要求。不能实现数字签名。 非对称密码体制的基本特点加密能力与解密能力是分开的。密钥分发简单。需要保存的密钥量大大减少，N个用户只需要N个密钥。可满足不相识的人之间保密通信。可以实现数字签名。 公钥密码体制的应用加密/解密：发送方用接收方的公钥对消息加密。数字签名：发送方用其私钥对消息签名，可以对整体消息签名或对消息的摘要签名。密钥交换：通信双方交换会话密钥。 RSA算法流程随机选择两个秘密大素数$p$和$q$计算公开模数$n=p\times q$计算秘密的欧拉指数函数$\varphi (n)=(p-1)(q-1)$选择一个与$\varphi (n)$互素的数，作为$e$或$d$用Euclid算法计算模$\varphi (n)$的乘法逆元素，即根据$ed\ mod\ φ(n)=1$, 求$d$或$e$加密：$C=M^e\ mod\ n$解密：$M=C^d\ mod\ n = (M^e\ mod\ n)^d\ mod\ n=M^{ed}\ mod\ n=M$公钥：$PU=\{ e,n\}$ 私钥：$PR=\{ d,n\}$ 需要满足的条件有可能找到e, d, n的值, 使得对所有$M&lt;n$有$M^{ed}\ mod\ n = M$。对于所有$M&lt;n$的值, 要计算$M^e$和$C^d$是相对容易的。在给定e和n时, 计算d是不可行的。 证明已知：$ed\ mod\ \varphi (n)=1，M&lt;n，p和q是素数$求证：$M^{ed}\ mod\ n=M$ 可能的攻击方式穷举攻击：尝试所有可能的密钥数学攻击：对两个素数乘积的因子分解(FAC问题)计时攻击：依赖于解密算法的运行时间RSA的安全性问题依赖于大合数的素因子分解。 第十章几种公钥分配方法公开发布、公开可访问的目录、公钥授权、公钥证书 公开发布 公开可访问的目录一个可信实体或组织负责这个公开目录的维护和分配。 目录包含{name, public-key}等项。 每一通信方通过目录管理员以安全的方式注册一个公钥。 通信方在任何时刻可以用新的密钥替代当前的密钥。 目录定期更新。目录可通过电子方式访问。安全问题：一旦攻击者获得目录管理员私钥，则可传递伪造的公钥，可以假冒任何通信方以窃取消息，或者修改已有的记录。 公钥授权(1) A发送带有时间戳的消息给公钥管理员, 请求B的当前公钥。(2) 管理员给A发送用其私钥$KR_{auth}$加密的消息, A用管理员的公钥解密，可以确信该消息来自管理员。 B的公钥$KU_b$，用来加密；原始请求$Request$，A可以验证其请求未被修改；原始时间戳$Time_1$, A可以确定收到的不是来自管理员的旧消息。 (3) A保存B的公钥, 并用它对包含A的标识$ID_A$和$N_1$的消息加密, 然后发送给B。(45) B以同样方式从管理员处得到A的公钥。(6) B用$KUa$对A的$N_1$和B的$N_2$加密, 发送给A。(7) A用B的公钥对$N_2$加密并发送给B, 使B相信其通信伙伴是A。 公钥证书有了公钥证书使得不通过实时访问公钥授权部门而实现公钥交换成为可能。公钥证书将一个通信方的身份与他的公开密钥绑定在一起，通常还包括有效期和使用方法等。证书的所有内容必须经由可信公钥授权方或者证书授权方签名后方可生效。知道公钥授权当局公开密钥的任何人都可以验证一个用户的公开密钥证书的有效性。 对于申请者A，管理员提供的证书为：$C_A = E_{KR_{auth}} [Time_1, ID_A, KU_a]$其他人读取并验证：$D_{KU_{auth}}[C_A]=D_{KU_{auth}} [E_{KR_{auth}} [Time_1, ID_A, KU_a]]=(Time_1, ID_A, KU_a)$ 公钥密码分配传统密码体制密码公钥密码算法速度较慢，因此更适合作为传统密码中实现秘密密钥分配的一种手段。下图是一个利用公钥密码体制分配（传输）对称式密码（会话密钥$K_s$）的例子：(1) A用$KU_b$加密消息$N_1$和$ID_A$发送给B。(2) 只有B拥有B的私钥，即$N_1$只有B可见，B产生随机值$N_2$，和$N_1$一起加密后发送给A，A看到$N_1$后即可确定消息是B发来的。(3) 同理，$N_2$只有A可见，B可以确定消息是A发来的。(4) A产生本次会话的密钥，先用自己的私钥加密再用B的公钥加密发送给B。上述过程中存在的安全问题：消息(4)可以进行重放攻击。在下次会话时上次的会话密钥可能已经泄露，攻击者可以重放上次的消息(4)进行攻击。解决方案是将消息(3)和消息(4)合并发送，即(3)$E_{KU_b}[N_2 || E_{KR_a}[K_s]]$。 Diffie-Hellman密钥交换Diffie-Hellman密钥交换算法是一种公钥分发机制。它不是用来加密消息的，所生成的是通信双方共享的会话密钥，必须保密，其值取决于通信双方的私钥和公钥信息。 流程通信双方约定一个大素数(或多项式)p, 和模p的一个素根α（p与α是公开的）双方分别选择一个秘密钥(整数值)，如$x_A&lt; p， x_B&lt; p$计算公钥, 如$y_A = α^{x_A}\ mod\ p, y_B = α^{x_B}\ mod\ p$, 并相互交换双方共享的会话密钥$K_{AB}$可以如下算出$K_{AB} = α^{x_Ax_B}\ mod\ p= y_A^{x_B}\ mod\ p (which\ B\ can\ compute) = y_B^{x_A}\ mod\ p (which\ A\ can\ compute) $$K_{AB}$是双方用对称密码通信时共享的密钥如果双方继续通信，可以继续使用这个密钥，除非他们要选择新的密钥 安全性攻击者如果想要获得x, 则必须解决DLP(离散对数)问题。$X_B=dlog_{α,p}Y_B$，即求$Y_B$的以$α$为底的模$p$的离散对数。 中间人攻击 ELGamal概率密码系统流程假设A和B互相通信，共享大素数$p$，本原元素$α，1≤m≤p-1$加密：A选择$k∈[1, p-1]$, $k$的作用其实即为$x_A$, A访问公共区域找到B的公开密钥$Y_B = α^{x_B}\ mod\ p$, 计算：$K = (Y_B)^k\ mod\ p, 即K = α^{x_Bk}\ mod\ p$$c1 = α^k\ mod\ p$$c2 = mK\ mod\ p$密文即为 $(c1, c2)$解密：B首先恢复K：K $= c1^{x_B}\ mod\ p = α^{kx_B}\ mod\ p$然后恢复m：m $=c2K^{-1}\ mod\ p$。这里的$K^{-1}$指$KK^{-1}\ mod\ p=1$ 效率及安全性ElGamal密码体制加密效率是50%，因为密文大小是明文的两倍。ElGamal密码体制是概率密码体制，同样的明文每次加密得到不同的密文, 因为每次随机选择k。ElGamal密码体制的破译难度同Diffie-Hellman的方法,即基于DLP，离散对数问题，最快的算法需要T=exp((ln(p)lnln(p)1/2)次运算。 第十一章消息认证消息认证就是验证接受的消息确实来自真正的发送方，且是未经修改过的消息，并且可以认证消息的顺序和及时性。 消息认证函数消息加密消息加密本身提供了一种认证手段。对称加密 保密性：如果除了源和宿没有其他人知道密码，那么就保证了保密性。 认证：宿可以确信消息是由源产生的，因为除了宿以外只有源拥有加密密钥，产生出用此密钥可以解密的密文。因此宿如果可以恢复出明文，则可以认为每一位都没有被修改过，建立在明文具有可读性的基础上。 如果消息可以是任意的位模式，接收方无法确定收到的消息是合法明文的密文（不具有可读性）。因此要求明文具有某种易于识别的结构，如在加密前对每个消息附加一个帧校验序列FCS。FCS和加密函数E执行的顺序很重要。图中(a)为内部错误控制，攻击者很难产生密文使得控制码仍为正确，所以可以提供认证。图中(b)为外部错误控制，攻击者可以构造出具有正确控制码的消息，虽然不知道解密后的消息是什么，但是可以混淆破坏通信。公钥加密(b) 保密性：只有接受方具有私钥可以解密消息，因此具有保密性；但公钥是公开的，任何人都可以假冒发送方给接收方发送消息，不能保证消息的真实性，因此没有认证。(c) 认证和签名：接收方接收到密文并可以解密出明文（如果明文是具有某种结构的，即具有可读性以区分真实的明文和随机串）就可以确定发送方是真实的。只有发送方有自己的私钥，加密后就相当于是一个签名。(d) 保密性、认证和签名：发送方先用自己的私钥加密以作为签名，再用接收方的公钥加密实现保密性，同时明文具有某种结构的情况下实现了认证。缺点是一次通信执行四次公钥算法（两次加密两次解密）。 消息认证码MAC利用密钥产生一个固定长度的短数据块。假如通信双方共享密钥K，则MAC=C(K,M)。如果接收方通过密钥和消息计算的MAC与收到的一致，那么可以确信(1)消息未被修改过(2)消息来自真正的发送方(3)如果消息中含有序列号，那么可以确定消息顺序是正确的。因为MAC是定长的，而消息数远大于MAC的取值范围，因此MAC是一个多对一的函数。因为K是通信双方所共有的，所以MAC不是数字签名。同时MAC不需要解密，因此不需要具有可逆性，使得MAC比加密更加难以破解。(a) 消息认证：整个消息以明文发送，没有保密性，但有消息认证。(b) 与明文捆绑的消息认证和保密性：对明文做MAC然后与明文一起加密。(c) 与密文捆绑的消息认证和保密性：对明文加密，然后对密文做MAC，与密文一起发送。MAC函数应具有满足以下需求： 若攻击者已知$M$和$C(K,M)$，则构造满足$C(K,M’)=C(K,M)$的消息$M’$在计算上是不可行的 $C(K,M)$应该是均匀分布的，即对任何随机选择的消息$M$和$M’$，$C(K,M’)=C(K,M)$的概率是$2^{-n}$，其中n是MAC的位数 设M’是M的某个已知的变换，即M’=f(M)，如f可能表示逆转M的一位或多位，那么$C(K,M)=C(K,M’)$的概率是$2^{-n}$ 散列函数HASH一个散列函数以变长的报文M作为输入，产生定长的散列码H(M)作为输出，亦称作报文摘要。 散列码是报文所有比特的函数值，具有差错检测能力，报文任意一比特的改变都将引起散列码的改变。Hash函数的安全性需求 需求 描述 输入长度可变 H可以应用于任意大小的数据块 输出长度固定 H产生固定长度的输出 效率 对任意给定的明文x，计算H(x)容易，可由硬件或软件实现 抗原像攻击（单向性） 对任意给定的散列码h，找到满足H(x)=h的x，在计算上不可行 抗第二原像攻击（抗弱碰撞性） 对任何给定的分组x，找到满足y≠x且H(x)=H(y)的y，在计算上不可行 抗强碰撞性 找到任何满足H(x)=H(y)的偶对(x, y)，在计算上不可行 伪随机性 H的输出满足伪随机性测试标准 满足前五条的称为弱哈希函数，如果第六条也满足则称为强哈希函数。应用在数字签名上的Hash函数必须是强哈希函数。三个安全特性之间的关系抗强碰撞那么一定抗弱碰撞，反之不成立。抗强碰撞不一定抗原像，反之亦然。抗弱碰撞不一定抗原像，反之亦然。抗强碰撞可以看作是在人群中寻找两个名字相同的人，抗弱碰撞性可以看作是给定一个名字，然后在人群中找一个和这个名字相同的人。 Hash函数提供的消息认证方式(a) 使用对称密码加密消息和Hash码。对称式密钥保证了保密性，并且可以确定发送方的真实性；Hash码提供了消息认证的功能。(b) 使用对称式密码仅加密Hash码。对于无需保密性的应用，减少了加解密的负担。实现了消息认证。(c) 不使用加密算法，双方共享秘密值s，并且s不在信道上传输，仅实现了消息认证。(d) 在(c)的基础上提供保密性。 Hash函数提供的数字签名方式(a) 使用发送方的私钥，仅对Hash码进行加密。实现了消息认证和数字签名。(b) 在(a)的基础上使用对称式密码加密，同时实现保密性。 第十三章数字签名概述数字签名实现方法数字签名是一种认证机制，它使得消息的产生者可以添加一个起签名作用的码字。通过计算消息的散列值并用产生者的私钥加密散列值来生成签名。签名保证了消息的来源和完整性。数字签名标准(DSS)是NIST标准，它使用安全散列算法(SHA)。 数字签名的要求在收发双方不能完全信任的情况下，需要除认证之外的其他方法来解决假冒和否认的问题，数字签名则是解决办法；签名接收者能容易地验证签字者对消息所做的数字签名，包括日期和时间；任何人，包括签名接收者，都不能伪造签名者的签字；发生争议时，可由第三方解决。 数字签名与消息认证的区别消息认证使收方能验证消息发送者及所发消息内容是否被窜改过。当收发者之间没有利害冲突时，这对于防止第三者的破坏来说是足够了。但当收者和发者之间有利害冲突时，就无法解决他们之间的纠纷，此时须借助满足前述要求的数字签名技术。 直接数字签名用共享的密钥（对称密钥）对明文及签名一起加密。注意先进行签名，然后执行外层的加密，这样在发生争执时，第三方可以查看消息及其签名。若先加密再签名，则第三方必须知道解密密钥才能查看消息。先签名再加密，接收方可以保留消息及其签名留作争执时使用。直接数字签名的有效性依赖于发送方私钥的安全性。发送方如果想要否认一条消息，他可以声称自己的私钥丢失或被盗用。可以使用加入时间戳的方式减少这种威胁。另一种威胁是，攻击者在T时刻盗用了发送方的私钥，并发送了一条签名的消息加盖T时刻之前的时间戳。解决上述问题的方法是使用数字证书的证书管理中心。 ELGamal数字签名方案首先，基本元素是素数p和原根αA用户生成随机整数$X_A\in (1,p-1)$，计算$Y_A=α^{X_A}\ mod\ p$计算消息的Hash码，m=H(M)产生签名选择整数$K\in [1,p-1]$，并且K与p-1互素计算$S_1 = \alpha ^K\ mod\ p$计算K模p-1的逆，即$K^{-1}\ mod\ (p-1)$计算$S_2=K^{-1}(m-X_AS_1)\ mod\ (p-1)$签名即为$(S_1,S_2)$验证签名计算$V_1=\alpha ^m\ mod\ p$计算$V_2=(Y_A)^{S_1}(S_1)^{S_2}\ mod\ p$如果$V_1=V_2$，那么签名合法。]]></content>
      <tags>
        <tag>网络信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【python learning】词法结构]]></title>
    <url>%2F2018%2F10%2F17%2F%E3%80%90python%20learning%E3%80%91%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[字符集通常，python的源代码必须完全由ASCII码组成。若想在程序中的注释和字符串常量中使用非ASCII字符，需在源代码的第一行添加注释# -*- coding: &lt;encoding-name&gt; -*- 标识符通常python的风格是类名称以大写字母开始，其他的标识符都是小写字母。以单个下划线开始的标识符是私有的，以两个下划线开始的标识符是非常强的私有标识符；如果标识符还以两个下划线结尾，则表示该标志符是python语言定义的特殊名称。 关键字(3.7.1版本)False await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if or yield 逻辑行与物理行逻辑行由一个或多个物理行组成。 当某一物理行以backslash(\)结束，并且后面没有注释，就会连接到下一个物理行作为一个逻辑行。 1234if 1900 &lt; year &lt; 2100 and 1 &lt;= month &lt;= 12 \ and 1 &lt;= day &lt;= 31 and 0 &lt;= hour &lt; 24 \ and 0 &lt;= minute &lt; 60 and 0 &lt;= second &lt; 60: # Looks like a valid date print("It's a valid date.") 如果一个左边的圆括号、方括号、花括号还没有对应的右括号，则python会自动把多个物理行连接成一个逻辑行。 1234month_names = ['January', 'February', 'March', # These are the 'April', 'May', 'June', # Dutch names 'July', 'August', 'September', # for the months 'October', 'November', 'December'] # of the year]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[僕が死のうと思ったのは]]></title>
    <url>%2F2018%2F10%2F12%2F%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"http://pg60us30v.bkt.clouddn.com//vedio/%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.mp4","pic":"http://pg60us30v.bkt.clouddn.com//image/image-video/%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <tags>
        <tag>music</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java学习笔记】全系列内容提要篇]]></title>
    <url>%2F2018%2F10%2F06%2F%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%85%A8%E7%B3%BB%E5%88%97%E5%86%85%E5%AE%B9%E6%8F%90%E8%A6%81%E7%AF%87%2F</url>
    <content type="text"><![CDATA[【java学习笔记1】基本数据类型对象和类数据声明函数声明参数传递 【java学习笔记2】数组运算符包访问权限修饰符 【java学习笔记3】继承多态 【java学习笔记4】异常处理 【java学习笔记5】抽象类、抽象函数接口 【java学习笔记6】Object类Class类String类System类包装类 【java学习笔记7】泛型 【java学习笔记8】集合类，集合接口Collection类List LinkedList ArrayListMap HashMap TreeMapSet HashSet TreeSet 【java学习笔记9】FileRandomAccessFile文本流Preoperties // 配置文件的使用多线程 【java学习笔记10】线程同步、锁 【java学习笔记11】网络编程 【java学习笔记12】数据库编程 我比较懒，另一方面由于还在上学，时间比较少，慢慢更新~]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双系统安装Ubuntu18.04]]></title>
    <url>%2F2018%2F10%2F01%2F%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[制作启动盘以Ubuntu18.04为例 方式一工具为软碟通UltraISO。 准备一个U盘，格式化。 以管理员身份运行软碟通，菜单栏里选择“启动-&gt;写入硬盘映像”，写入方式选择“usb-HDD+”，“便捷启动-&gt;写入新的驱动程序引导扇区-&gt;Syslinux”。方式二工具为rufus。 这是一个Ubuntu官方推荐的工具，用起来还是很方便的。唯一需要注意的就是选择Partition schema为MBR还是GPT。 查看硬盘分区表类型可以使用windows下的磁盘管理。点击要查看的硬盘，右键，“属性-&gt;卷”就能看到了。还有很多其他的工具可用，不一一赘述了。安装系统 首先，重启电脑进入BIOS，关闭安全启动(如果之前装过双系统的话应该关掉了)，设置第一启动项为U盘启动，设置完成后保存退出。 这时候电脑应该会自动重启，重启之后应该就是Ubuntu的安装引导了，选择Install Ubuntu。 选择语言和键盘布局。 在联网这一项上，选择暂不连接网络，这样可以加快安装的进度，一些东西可以安好系统后自己选择安装。 选择最小安装，其他的不用选。 如果要装双系统，选择与Windows共存就好了，Ubuntu可以自己选择你未分配的空间作为安装空间(前提是你有未分配的空间)。网上的一些教程都交了如何自己分区，非老手且没有什么特殊需求建议不要尝试了，没什么用。如果只保留Ubuntu，选择只保留Ubuntu就好了。 接下来就是一些时区，用户名的设置了。 设置完后，安装就开始了，大约需要30分钟左右吧(当然这要视电脑情况而定qwq)。系统升级如果之前你是16.04或者17.10等其他的版本，也可以升级到18.04版本。(注意提前做好备份，万一装崩了呢/doge) 首先，更新升级已安装的软件包。 1234sudo apt upgradesudo apt updatesudo apt dist-upgradesudo apt autoremove 在软件更新器里选择更新版本为长期支持版本。 安装update-manager-core sudo apt-get install update-manager-core 执行sudo do-release-upgrade -d等待完成就ok了，我大概用了100分钟的时间。安装Gnome插件Ubuntu18.04回归了gnome桌面，意味着我们可以使用很多有用的插件来使它更加的高效和炫酷。如何安装gnome插件呢？网上说了很多方法，有用Tweaks的，有在官网下载后解压的。这些方法首先肯定都没错。但是我一开始也是用的这两种方法进行尝试，然鹅并没有成功。万念俱灰之际，我发现在Ubuntu的软件中心有一个附加组件项，点进去，卧槽，这不就是现成的嘛…推荐几个插件吧：Simple net speed 顶栏实时网速显示Openweather 顶栏显示天气EasyScreenCast 录屏Coverflow alt-tab 效果超赞的 alt-tab 切换效果……更多有趣的插件自己探索吧~]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[词法分析器]]></title>
    <url>%2F2018%2F10%2F01%2F%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[词法分析 In computer science, lexical analysis, lexing or tokenization is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of tokens (strings with an assigned and thus identified meaning).在计算机科学中，词法分析，lexing或标记化是将一系列字符（例如在计算机程序或网页中）转换成一系列标记（具有指定且因此标识的含义的字符串）的过程。 编码目标给定一个源代码文件，能够将其转化为词法记号流。比如规定int的词法记号为30，输出就是(30, int)；数字的词法记号为11，则输入123，输出为(11, 123)。 约定把程序中的词法单元分为四类：标识符（分为关键字和一般标识符）、数字、特殊字符、空白（空格、Tab、回车换行等） 程序流程图对于运算符等符号，这里只考虑两个字符的组合情况，不考虑三个字符组成的运算符。之所以要在读到特殊字符之后在往后读一个字符是因为有可能在表中存在类似&gt;=和&gt;的运算符，要保证最长字符匹配。 关键代码首字符类型判断1234567891011121314151617181920212223public static String getCharType(String str) &#123; String regex_Letter = "[a-zA-Z]"; String regex_Number = "[0-9]"; String regex_Blank = "\\s"; Pattern pattern; pattern = Pattern.compile(regex_Letter); Matcher matcher = pattern.matcher(str); if (matcher.find()) return "LETTER"; pattern = Pattern.compile(regex_Number); matcher = pattern.matcher(str); if (matcher.find()) return "NUMBER"; pattern = Pattern.compile(regex_Blank); matcher = pattern.matcher(str); if (matcher.find()) return "BLANK"; return "SPECIAL"; &#125; 如果首字符为字母123456789101112131415case "LETTER": pattern = Pattern.compile(regex_ID); matcher = pattern.matcher(srcCode); if (matcher.lookingAt()) &#123; String result = matcher.group(); if (LexicalToken.isKeyWord(result)) &#123; int token = lextok.getToken(result); System.out.printf("&lt;%d,%s&gt; ", token, result); &#125; else &#123; int token = lextok.getToken("ID"); System.out.printf("&lt;%d,%s&gt; ", token, result); &#125; &#125; srcCode = srcCode.substring(matcher.end()); break; 如果首字符是数字12345678910case "NUMBER": pattern = Pattern.compile(regex_NUM); matcher = pattern.matcher(srcCode); if (matcher.lookingAt()) &#123; String result = matcher.group(); int token = lextok.getToken("NUM"); System.out.printf("&lt;%d,%s&gt; ", token, result); &#125; srcCode = srcCode.substring(matcher.end()); break; 如果首字符是空格123case "BLANK": srcCode = srcCode.substring(1); break; 如果首字符是特殊符号1234567891011121314151617181920212223case "SPECIAL": if (srcCode.length() &gt; 1) &#123; String secondChar = srcCode.substring(1, 2); String result; LinkedHashMap tokenMap = lextok.getLexicalTokenMap(); Set set = tokenMap.keySet(); result = firstChar + secondChar; if (getCharType(secondChar).equals("SPECIAL") &amp;&amp; set.contains(result)) &#123; int token = lextok.getToken(result); System.out.printf("&lt;%d,%s&gt; ", token, result); srcCode = srcCode.substring(2); &#125;else &#123; result = firstChar; int token = lextok.getToken(result); System.out.printf("&lt;%d,%s&gt; ", token, result); srcCode = srcCode.substring(1); &#125; &#125; else &#123; // 字符串中只有一个字符时 int token = lextok.getToken(srcCode); System.out.printf("&lt;%d,%s&gt; ", token, srcCode); srcCode = srcCode.substring(1); &#125; break; 源码地址：https://github.com/Liyzy/Lexer开发环境：IJ idea 2018.2]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双系统卸载]]></title>
    <url>%2F2018%2F09%2F23%2F%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%8D%B8%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[本文主要针对windows+Linux双系统卸载Linux/Unix系统(Ubuntu\Deepin...)。 删除系统在windows上，右键开始打开磁盘管理(或者直接搜索“磁盘管理”)，看到装有Linux系统的硬盘分区，右键删除卷，删除后分区变为“未分配”。如果不安装新的系统，可以“新建简单卷”；如果还要安装别的系统，就暂不处理。 如果之前Linux/Unix系统是第一启动项，那么这时候你重启计算机的话是会出现错误的，因为引导找不到这个系统了。而且，在BIOS的启动项里还存在着这个系统。这时我们就要修复引导。 修复引导我们用到一个工具：EasyUEFI 下个试用版就OK。运行EasyUEFI，选择“管理EFI启动项”，可以看到你要卸载的系统的启动项，选中，选择“删除选中项”。之后在进入BIOS查看启动项，发现只剩下一个windows的启动项了，成功！]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【python学习笔记1】数据类型篇]]></title>
    <url>%2F2018%2F09%2F22%2F%E3%80%90python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%91%2F</url>
    <content type="text"><![CDATA[python简单介绍 作为一种解释型语言，Python的设计哲学强调代码的可读性和简洁的语法（尤其是使用空格缩进划分代码块，而非使用大括号或者关键词）。与Scheme、Ruby、Perl、Tcl等动态类型编程语言一样，Python拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。其本身拥有一个巨大而广泛的标准库。Python是完全物件导向的语言。函数、模组、数字、字串都是物件。并且完全支持继承、重载、派生、多重继承，有益于增强原始码的复用性。Python支持重载运算符，因此Python也支持泛型设计。Python编译器本身也可以被集成到其它需要脚本语言的程式内。因此，有很多人把Python作为一种“胶水语言”使用。使用Python将其他语言编写的程式进行集成和封装。Python属于动态类型语言，动态类型语言是在运行期间检查数据的类型，不得不保持描述变量值的实际类型标记，程序在每次操作变量时，需要执行数据依赖分支，而静态类型语言相对于动态类型语言，在声明变量时已经指定了数据类型和表示方法，根据这一原理导致Python相对于C、Visual Basic等静态类型语言来说运行速度较慢。 摘录自Wikipedia python数据类型常量python中没有关键字表示常量，用大写来代表这是一个常量。例如NUM=5，NUM就是一个常量。因此，在编写python代码时，要严格区分大小写。 变量python中变量声明不需要声明变量类型。但是，python是一种强类型语言，不能因此而判断python是弱类型的。python是动态的、强类型的语言。Why is Python a dynamic language and also a strongly typed language？ 数据类型分为两大类：内置数据类型、自定义数据类型内置数据类型分为：数值、序列、集合、字典、特殊、其他数值数据类型：整数、浮点数、布尔、复数序列数据类型：字符串、元组、字节序列、列表、字节数组集合数据类型：集、不可变集 内置的type()函数可以用来查询变量所指的对象类型123&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))&lt;type 'int'&gt; &lt;type 'float'&gt; &lt;type 'bool'&gt; &lt;type 'complex'&gt; int类型12345myInt = 5 myInt = int(5) #int对象方式int(5.4) #自动类型转换int("123") #自动类型转换#二进制以0b开头，八进制以0开头，十六进制以0x开头 float类型12myFloat = float(3.14)myFloat = float(4) #自动类型转换，输出结果4.0 复数数据类型 虚部必须用j1234561+1j #不可写成1+j0+0j #0不能省略complex(1,2) #其中1为实部，2为虚部c1=complex(6) #输出c1为6+0j,等同于complex(6,0) complex(6,)c2=complex(2.1,3.2) #实部与虚部可以为浮点数#real:复数的实部 imag:复数的虚部 c2.real输出结果2.1,c2.imag输出结果3.2 bool类型12345"""True False开头首字母必须大写bool对象 bool(False)bool(0),bool(0.0) 结果为False,任何非零均为True例如 bool('0'),bool(5),bool(2.3),bool("abc")""" String类型表现形式&quot;abc&quot; &#39;abc&#39; &#39;&#39;&#39;abc&#39;&#39;&#39; &quot;&quot;&quot;abc&quot;&quot;&quot; 前两个表示一行，后两个表示可以跨行 字符串拼接与重复123456&gt;&gt;&gt; "abc"+'def' #使用+进行字符串连接'abcdef'&gt;&gt;&gt; "abc" 'def' #默认自动连接'abcdef'&gt;&gt;&gt; "abc"*2 # *表示重复，*后的整数表示重复次数'abcabc' 转义字符 转义字符 含义 \n 换行 \r 回车 \t 水平制表符 \v 垂直制表符 \b 退格 \f 换页 使用r或R为开头的字符串成为原始字符串，其中包含的任何字符都不可进行转义。123&gt;&gt;&gt; myStr = r"abc\n"&gt;&gt;&gt; print(myStr)'abc\n' str对象str()str(.14) 输出结果为 ‘0.14’ ，浮点数前导0可省略,隐式类型转换。 字符串索引Python中的字符串有两种索引方式，第一种是从左往右，从0开始依次增加；第二种是从右往左，从-1开始依次减少。注意，没有单独的字符类型，一个字符就是长度为1的字符串。12345&gt;&gt;&gt; word = 'Python'&gt;&gt;&gt; print(word[0], word[5])P n&gt;&gt;&gt; print(word[-1], word[-6])n P 字符串截取子串用冒号分隔两个索引，形式为变量[头下标:尾下标]。截取的范围是前闭后开的，并且两个索引都可以省略：123456789&gt;&gt;&gt; word = 'ilovepython'&gt;&gt;&gt; word[1:5]'love'&gt;&gt;&gt; word[:]'ilovepython'&gt;&gt;&gt; word[5:]'python'&gt;&gt;&gt; word[-10:-6]'love' Python字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。 列表列表的创建方式字面量[x1,x2,x3,x4,…,xn]列表中元素类型可以不同，如[1, 2, 3, ‘q’, True]列表中的元素可以是表达式，如123x = 1temp = [x + x, x * x, 11]list = [[1,2,3,4],[5,6,7],8] 对象123list1 = list() #空列表list2 = list("abcd") #结果['a', 'b', 'c', 'd']list3 = list(range(3)) #结果[0, 1, 2] 推导式使用非常简单的表达式满足特定的列表表达式 for 变量 in 序列123list4 = [x*x for x in range(1,10)]print(list4) #结果[1, 4, 9, 16, 25, 36, 49, 64, 81]list5 = [i for i in list4 if i%2==0] #结果[4, 16, 36, 64] 列表的操作列表的操作包括：索引、切片、连接、重复、成员关系、比较、求长度、最大值、最小值等 索引访问123list6 = [1, 2, 3]print(list6[0], list6[-1]) #结果１ ３list6[0] = 10 #list中的值可以改变，此时list6为[10, 2, 3] 删除列表中的元素12list7 = [1,2,3,4,5] #[1,2,3,4,5]del list7[1] #[1,3,4,5] 求长度、最大值、最小值、和1234567891011121314151617181920list８ = [1,2,3,4,5,6] #[1,2,3,4,5,6]len(list8) #6min(list8) #1max(list8) #6sum(list8) #21list9 = [1,2,3,4,'a',5]len(list9) #6max(list9) #TypeError: unorderable types: str() &gt; int(), min和sum同样错误。list10 = ['a', 'b', 'c'] #可以算len,max,min，但不能求和# python 2.7.15中测试结果如下&gt;&gt;&gt; list1 = [1,2,3,4,5,'a', 6]&gt;&gt;&gt; max(list1)'a'&gt;&gt;&gt; min(list1)1&gt;&gt;&gt; sum(list1)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: unsupported operand type(s) for +: 'int' and 'str' 切片s[i:j] 从索引i开始，到j结束，左闭右开。省略i从0开始，省略j到结尾结束s[i:j:k] k表示步长1234list1 = [1, 2, 3, 4, 5, 6, 7]temp = list1[1:6:2]print(temp) # 结果[2, 4, 6]list1[:1] = [] # list1变为[2,3,4,5,6,7] 连接与重复连接+ 重复*12345list2 = [1,2,3]list3 = [3,4,5]print(list2+list3) # 结果[1, 2, 3, 3, 4, 5],只连接不去重print(2*list2) # 结果[1, 2, 3, 1, 2, 3]list2 += list3 # 结果[1, 2, 3, 3, 4, 5],等价于list2 = list2 + list3 成员关系操作判断一个元素是否在列表中in 和not in12345list1 = [1, 4, 3, 3, 2, 2, 3]print(7 in list1) # Falseprint(3 in list1) # Trueprint(list1.count(3)) # 3 计算某一个元素在列表中出现的次数print(list1.index(3, 2, 6)) # 2 查找某个元素在给定范围内第一次出现的索引,例子中范围为[2,6) 比较运算12345678list1 = ['a', 'b']list2 = ['a', 'b']list3 = ['a', 'b', 'c']list4 = ['c', 'b', 'a']print(list1 == list2) # Trueprint(list3 &gt; list2) # Trueprint(list3 &gt; list4) # False# 从第一个元素开始比较 列表的排序sorted(list1)) any()和all()any() 列表中是否有元素为Trueall() 列表中的元素是否都为True 列表的拆分1234list1 = [1,2,3,4]a,b,c,d = list1print(a,b,c,d) # 结果１ ２ ３ ４# 应保证前面的变量数与列表的长度相同 元组定义与声明定值表，用来存储不变值表123456789t = 1,2,3,4 # 表示元组t = (1,2,3,4) # 表示元组t = () # 表示空元组t = 1, # 表示只有一个元素的元组，必须有逗号t = tuple(1,2,3,4) # 错误写法，只能有一个参数t = tuple([1,2,3,4])# 正确写法t = tuple("abcd") # 结果为（'a','b','c','d'）t = tuple(range(8)) t = tuple(2*x for x in range(1,5)) # 结果为(2,4,6,8) 元组的操作索引访问、切片、连接、重复、成员关系、最大值、最小值、和、长度、排序等与列表的操作类似，可以进行对比。一些内容不作赘述。 元组的排序123456789tuple1 = tuple([2,1,9,5,4,6])print(tuple1)print(sorted(tuple1))print(tuple1)# 结果为(2, 1, 9, 5, 4, 6)[1, 2, 4, 5, 6, 9] # 输出的是列表(2, 1, 9, 5, 4, 6) # 原元组没有变化 元组的拆分123456789a, *s, d, f = tuple1 print(a, d, f) # 结果为 2 4 6a, s, d, *f = tuple1print(a, s, d) # 结果为 2 1 9# 元组的拆分前面变量的个数必须与元组元素个数相等。如果元组元素个数过多，可以使用*代表多个变量_, a, b, _, *_ = tuple1print(a, b, _) # 结果为 1 9 [4, 6]# 没有意义的命名可以使用临时变量下划线(_)表示。输出临时变量，只会保留最后一个。 字典字面量{键:值,键:值,键:值,键:值,} 字典对象dict()12345print(dict([['优',90],['良',80]]))print(dict((('优',90),('良',80))))print(dict(zip(['优','良'],[90,80])))# 结果均为 &#123;'优': 90, '良': 80&#125;dict1 = dict(a="apple", b="banane") # &#123;'a':'apple', 'b':'banane'&#125; fromkeys()123dict2 = &#123;&#125;.fromkeys(['优','良'],"大于70分") # &#123;'优': '大于70分', '良': '大于70分'&#125;dict3 = &#123;&#125;.fromkeys(['优','良']) # &#123;'优': None, '良': None&#125;dict4 = &#123;&#125;.fromkeys(['优','良'],None) # &#123;'优': None, '良': None&#125; 推导式1dict5 = &#123;n:n**2 for n in range(1,5)&#125; # &#123;1:1,2:4,3:9,4:16&#125; 得到键对应的值12345678dict2['优'] # 大于70分dict2.get('优') # 大于70分dict2.get('秀') # 没有反应，也没有报错dict2.get('秀','自定义错误提示') # 如果有“秀”对应的值，则输出对应的值；否则输出后面的提示信息dict2.get('优', '自定义错误提示') # 大于70分dict2.items() # 获取所有的键值对dict2.keys() # 返回所有的键值dict2.values() #返回所有的值 添加键值对12dict1['c'] = cat # &#123;'a':'apple', 'b':'banane', 'c':'cat'&#125; 没有则添加dict1['a'] = allen # &#123;'a':'allen', 'b':'banane'&#125; 有则修改 合并12345dict6 = &#123;'No1':'java','No2':'python'&#125;dict7 = &#123;'No3':'C++'&#125;dict8 = &#123;'No2','C'&#125;dict6.update(dict7) # dict6为&#123;'No1': 'java', 'No2': 'python', 'No3': 'C++'&#125;dict6.update(dict8) # dict6为&#123;'No1':'java','No2':'C'， 'No3': 'C++'&#125; 删除123456789del(dict6['No2'])print(dict6) # &#123;'No1': 'java'， 'No3': 'C++'&#125;del dict6print(dict6) # 报错，未定义dict1dict6.pop('No2','自定义错误提示') # 存在则删除；不存在输出自定义错误提示，即参数二dict9 = &#123;'No1':'java','No2':'python','No3':'C++'&#125;dict9.popitem() # 从后往前删除，每次删除一个。先删除No3,再删除No2...dict9.clear() # dict9为 &#123;&#125; 集合可变集合(set) 不可变集合(frozenset)没有顺序，没有重复元素 字面量1234print(&#123;1,2,3,4&#125;) # &#123;1, 2, 3, 4&#125;print(&#123;1,2,1,4&#125;) # &#123;1, 2, 4&#125;print(&#123;1,True&#125;) # &#123;1&#125;print(&#123;1,False&#125;) # &#123;False, 1&#125; 对象1234set1 = set('hello') # &#123;'h', 'e', 'l', 'o'&#125;set2 = set((1,2,3,4)) # &#123;1, 2, 3, 4&#125;set3 = set([1,2,3,4]) # &#123;1, 2, 3, 4&#125;set4 = set((1,[2,3,4]))# 错误 推导式1&#123;x*x for x in range(1,5)&#125; # &#123;16, 1, 4, 9&#125; 交并差集123456set5 = set(1,2,3,4)set6 = set(3,4,5,6)set5 | set6 # 并集 &#123;1, 2, 3, 4, 5, 6&#125; set5 &amp; set6 # 交集 &#123;3, 4&#125; set5 - set6 # 差集 &#123;1, 2&#125; set5 ^ set6 # 对称差集 &#123;1, 2, 5, 6&#125; 合并1set5.update(set6) # &#123;1,2,3,4,5,6&#125; 拷贝1set7 = set6.copy()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用ZXing工具生成二维码以及解析二维码]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%88%A9%E7%94%A8ZXing%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%BB%A5%E5%8F%8A%E8%A7%A3%E6%9E%90%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一、 二维码生成原理（即工作原理）二维码官方叫版本Version。Version 1是21 x 21的矩阵，Version 2是 25 x 25的矩阵，Version 3是29的尺寸，每增加一个version，就会增加4的尺寸，公式是：(V-1)4 + 21（V是版本号） 最高Version 40，(40-1)4+21 = 177，所以最高是177 x 177 的正方形。 下面是一个二维码的样例： 1、定位图案 Position Detection Pattern是定位图案，用于标记二维码的矩形大小。这三个定位图案有白边叫Separators for Postion Detection Patterns。之所以三个而不是四个意思就是三个就可以标识一个矩形了。 Timing Patterns也是用于定位的。原因是二维码有40种尺寸，尺寸过大了后需要有根标准线，不然扫描的时候可能会扫歪了。 Alignment Patterns 只有Version 2以上（包括Version2）的二维码需要这个东东，同样是为了定位用的。 2、功能性数据 Format Information 存在于所有的尺寸中，用于存放一些格式化数据的。 Version Information 在 &gt;= Version 7以上，需要预留两块3 x 6的区域存放一些版本信息。 数据码和纠错码 除了上述的那些地方，剩下的地方存放 Data Code 数据码 和 Error Correction Code 纠错码。 3、数据编码 QR码支持如下的编码： Numeric mode 数字编码，从0到9。如果需要编码的数字的个数不是3的倍数，那么，最后剩下的1或2位数会被转成4或7bits，则其它的每3位数字会被编成 10，12，14bits，编成多长还要看二维码的尺寸（下面有一个表Table 3说明了这点） Alphanumeric mode 字符编码。包括 0-9，大写的A到Z（没有小写），以及符号$ % * + – . / : 包括空格。这些字符会映射成一个字符索引表。如下所示：（其中的SP是空格，Char是字符，Value是其索引值） 编码的过程是把字符两两分组，然后转成下表的45进制，然后转成11bits的二进制，如果最后有一个落单的，那就转成6bits的二进制。而编码模式和 字符的个数需要根据不同的Version尺寸编成9, 11或13个二进制（如下表中Table 3） Byte mode, 字节编码，可以是0-255的ISO-8859-1字符。有些二维码的扫描器可以自动检测是否是UTF-8的编码。 Kanji mode 这是日文编码，也是双字节编码。同样，也可以用于中文编码。日文和汉字的编码会减去一个 值。如：在0X8140 to 0X9FFC中的字符会减去8140，在0XE040到0XEBBF中的字符要减去0XC140，然后把前两位拿出来乘以0XC0，然后再加上后两位，最 后转成13bit的编码。如下图示例： Extended Channel Interpretation (ECI) mode 主要用于特殊的字符集。并不是所有的扫描器都支持这种编码。 Structured Append mode 用于混合编码，也就是说，这个二维码中包含了多种编码格式。 FNC1 mode 这种编码方式主要是给一些特殊的工业或行业用的。比如GS1条形码之类的。 简单起见，后面三种不会在本文 中讨论。 下面两张表中， Table 2 是各个编码格式的“编号”，这个东西要写在Format Information中。注：中文是1101 Table 3 表示了，不同版本（尺寸）的二维码，对于，数字，字符，字节和Kanji模式下，对于单个编码的2进制的位数。（在二维码的规格说明书中，有各种各样的编码规范表，后面还会提到） 示例一：数字编码 在Version 1的尺寸下，纠错级别为H的情况下，编码： 01234567 把上述数字分成三组: 012 345 67 把他们转成二进制: 012 转成 0000001100； 345 转成 0101011001； 67 转成 1000011。 把这三个二进制串起来: 0000001100 0101011001 1000011 把数字的个数转成二进制 (version 1-H是10 bits ): 8个数字的二进制是 0000001000 把数字编码的标志0001和第4步的编码加到前面: 0001 0000001000 0000001100 0101011001 1000011 示例二：字符编码 在Version 1的尺寸下，纠错级别为H的情况下，编码: AC-42 从字符索引表中找到 AC-42 这五个字条的索引 (10,12,41,4,2) 两两分组: (10,12) (41,4) (2) 3.把每一组转成11bits的二进制: (10,12) 10*45+12 等于 462 转成 00111001110 (41,4) 41*45+4 等于 1849 转成 11100111001 (2) 等于 2 转成 000010 把这些二进制连接起来：00111001110 11100111001 000010 把字符的个数转成二进制 (Version 1-H为9 bits ): 5个字符，5转成 000000101 在头上加上编码标识 0010 和第5步的个数编码: 0010 000000101 00111001110 11100111001 000010 结束符和补齐符 假如我们有个HELLO WORLD的字符串要编码，根据上面的示例二，我们可以得到下面的编码， 编码 字符数 HELLO WORLD的编码 0010 000001011 01100001011 01111000110 10001011100 10110111000 10011010100 001101 我们还要加上结束符： 编码 字符数 HELLO WORLD的编码 结束 0010 000001011 01100001011 01111000110 10001011100 10110111000 10011010100 001101 0000 按8bits重排 如果所有的编码加起来不是8个倍数我们还要在后面加上足够的0，比如上面一共有78个bits，所以，我们还要加上2个0，然后按8个bits分好组： 00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 补齐码（Padding Bytes） 最后，如果如果还没有达到我们最大的bits数的限制，我们还要加一些补齐码（Padding Bytes），Padding Bytes就是重复下面的两个bytes：11101100 00010001 （这两个二进制转成十进制是236和17，我也不知道为什么，只知道Spec上是这么写的）关于每一个Version的每一种纠错级别的最大Bits限 制，可以参看QR Code Spec的第28页到32页的Table-7一表。 假设我们需要编码的是Version 1的Q纠错级，那么，其最大需要104个bits，而我们上面只有80个bits，所以，还需要24个bits，也就是需要3个Padding Bytes，我们就添加三个，于是得到下面的编码： 00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 11101100 00010001 11101100 纠错码 上面我们说到了一些纠错级别，Error Correction Code Level，二维码中有四种级别的纠错，这就是为什么二维码有残缺还能扫出来，也就是为什么有人在二维码的中心位置加入图标。 错误修正容量 L水平 7%的字码可被修正 M水平 15%的字码可被修正 Q水平 25%的字码可被修正 H水平 30%的字码可被修正 那么，QR是怎么对数据码加上纠错码的？首先，我们需要对数据码进行分组，也就是分成不同的Block，然后对各个Block进行纠错编码，对于如何分组，我们可以查看QR Code Spec的第33页到44页的Table-13到Table-22的定义表。注意最后两列： Number of Error Code Correction Blocks ：需要分多少个块。 Error Correction Code Per Blocks：每一个块中的code个数，所谓的code的个数，也就是有多少个8bits的字节。 举个例子：上述的Version 5 + Q纠错级：需要4个Blocks（2个Blocks为一组，共两组），头一组的两个Blocks中各15个bits数据 + 各 9个bits的纠错码（注：表中的codewords就是一个8bits的byte）（再注：最后一例中的（c, k, r ）的公式为：c = k + 2 * r，因为后脚注解释了：纠错码的容量小于纠错码的一半） 对每个块的纠错码 1 1 67 85 70 134 87 38 85 194 119 50 6 18 6 103 38 213 199 11 45 115 247 241 223 229 248 154 117 154 111 86 161 111 39 2 246 246 66 7 118 134 242 7 38 86 22 198 199 146 6 87 204 96 60 202 182 124 157 200 134 27 129 209 17 163 163 120 133 2 1 182 230 247 119 50 7 118 134 87 38 82 6 134 151 50 7 148 116 177 212 76 133 75 242 238 76 195 230 189 10 108 240 192 141 2 70 247 118 86 194 6 151 50 16 236 17 236 17 236 17 236 235 159 5 173 24 147 59 33 106 40 255 172 82 2 131 32 178 236 注：二维码的纠错码主要是通过Reed-Solomon error correction（里 德-所罗门纠错算法）来实现的。对于这个算法，对于我来说是相当的复杂，里面有很多的数学计算，最终编码。 穿插放置 二维码的混乱技术还没有玩完，它还要把数据码和纠错码的各个codewords交替放在一起。如何交替呢，规则如下： 对于数据码：把每个块的第一个codewords先拿出来按顺度排列好，然后再取第一块的第二个，如此类推。如：上述示例中的Data Codewords如下： 块 1 67 85 70 134 87 38 85 194 119 50 6 18 6 103 38 块 2 246 246 66 7 118 134 242 7 38 86 22 198 199 146 6 块 3 182 230 247 119 50 7 118 134 87 38 82 6 134 151 50 7 块 4 70 247 118 86 194 6 151 50 16 236 17 236 17 236 17 236 我们先取第一列的：67， 246， 182， 70 然后再取第二列的：67， 246， 182， 70， 85，246，230 ，247 如此类推：67， 246， 182， 70， 85，246，230 ，247 ……… ……… ，38，6，50，17，7，236 对于纠错码，也是一样： 块 1 213 199 11 45 115 247 241 223 229 248 154 117 154 111 86 161 111 39 块 2 87 204 96 60 202 182 124 157 200 134 27 129 209 17 163 163 120 133 块 3 148 116 177 212 76 133 75 242 238 76 195 230 189 10 108 240 192 141 块 4 235 159 5 173 24 147 59 33 106 40 255 172 82 2 131 32 178 236 和数据码取的一样，得到：213，87，148，235，199，204，116，159，…… …… 39，133，141，236 然后，再把这两组放在一起（纠错码放在数据码之后）得到： 67, 246, 182, 70, 85, 246, 230, 247, 70, 66, 247, 118, 134, 7, 119, 86, 87, 118, 50, 194, 38, 134, 7, 6, 85, 242, 118, 151, 194, 7, 134, 50, 119, 38, 87, 16, 50, 86, 38, 236, 6, 22, 82, 17, 18, 198, 6, 236, 6, 199, 134, 17, 103, 146, 151, 236, 38, 6, 50, 17, 7, 236, 213, 87, 148, 235, 199, 204, 116, 159, 11, 96, 177, 5, 45, 60, 212, 173, 115, 202, 76, 24, 247, 182, 133, 147, 241, 124, 75, 59, 223, 157, 242, 33, 229, 200, 238, 106, 248, 134, 76, 40, 154, 27, 195, 255, 117, 129, 230, 172, 154, 209, 189, 82, 111, 17, 10, 2, 86, 163, 108, 131, 161, 163, 240, 32, 111, 120, 192, 178, 39, 133, 141, 236 Remainder Bits 最后再加上Reminder Bits，对于某些Version的QR，上面的还不够长度，还要加上Remainder Bits，比如：上述的5Q版的二维码，还要加上7个bits，Remainder Bits加零就好了。关于哪些Version需要多少个Remainder bit，可以参看QR Code Spec的第15页的Table-1的定义表。 4、画二维码图 Position Detection Pattern 首先，先把Position Detection图案画在三个角上。 Alignment Pattern 然后，再把Alignment图案画上 关于Alignment的位置，可以查看QR Code Spec的第81页的Table-E.1的定义表（下表是不完全表格） 下图是根据上述表格中的Version8的一个例子（6，24，42） Timing Pattern 接下来是Timing Pattern的线（这个不用多说了） Format Information 再接下来是Formation Information，下图中的蓝色部分。 Format Information是一个15个bits的信息，每一个bit的位置如下图所示：（注意图中的Dark Module，那是永远出现的） 这15个bits中包括： 5个数据bits：其中，2个bits用于表示使用什么样的Error Correction Level， 3个bits表示使用什么样的Mask 10个纠错bits。主要通过BCH Code来计算 然后15个bits还要与101010000010010做XOR操作。这样就保证不会因为我们选用了00的纠错级别，以及000的Mask，从重造成全部为白色，这会增加我们的扫描器的图像识别的困难。 下面是一个示例： 关于Error Correction Level如下表所示： 关于Mask图案如后面的Table 23所示。 Version Information 再接下来是Version Information（版本7以后需要这个编码），下图中的蓝色部分。 Version Information一共是18个bits，其中包括6个bits的版本号以及12个bits的纠错码，下面是一个示例： 而其填充位置如下： 数据和数据纠错码 然后是填接我们的最终编码，最终编码的填充方式如下：从左下角开始沿着红线填我们的各个bits，1是黑色，0是白色。如果遇到了上面的非数据区，则绕开或跳过。 5、掩码图案 这样下来，图就填好了，但是，也许那些点并不均衡，所以还要做Masking操作QR的Spec中说了，QR有8个 Mask可以使用，如下所示：其中，各个mask的公式在各个图下面。所谓mask，说白了，就是和上面生成的图做XOR操作。Mask只会和数据区进 行XOR，不会影响功能区。 其Mask的标识码如下所示：（其中的i,j分别对应于上图的x,y） Mask过后的二维码就成最终的图了。 （以上内容来源于网络） 二、 编码实现首先，我们需要下载Google的ZXing库。下载地址：https://github.com/zxing/zxing 根据内容创建二维码12345678910111213141516171819202122232425262728293031/** * TODO 根据给定的内容生成二维码 * * @param content 二维码内容 * @param logoImagePath logo图标的路径 * @param needCompressed 是否需要压缩logo * @return 生成的二维码 * @throws IOException * @throws WriterException */private static BufferedImage createImage(String content, String logoImagePath, boolean needCompressed) throws IOException, WriterException &#123; HashMap hints = new HashMap&lt;EncodeHintType, Object&gt;(); hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); // 纠错等级 hints.put(EncodeHintType.CHARACTER_SET, CHARSET); hints.put(EncodeHintType.MARGIN, 1); // 二维码两边空白区域大小 BitMatrix bitMatrix = new MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, QRCODE_SIZE, QRCODE_SIZE, hints); int height = bitMatrix.getHeight(); int width = bitMatrix.getWidth(); BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); for (int x = 0; x &lt; width; x++) for (int y = 0; y &lt; height; y++) image.setRGB(x, y, bitMatrix.get(x, y) ? 0xFF000000 : 0xFFFFFFFF); if (logoImagePath == null || "".equals(logoImagePath)) return image; // 如果有logo，则插入logo图片 QRCode.InsertImage(image, logoImagePath, needCompressed); return image; &#125; 如果有logo则将logo插入到二维码中1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * TODO 插入logo图片 * @param sourceImage 原图片 * @param logoImagePath logo图片所在的路径 * @param needCompressed 是否需要压缩 * @throws IOException */ private static void InsertImage(BufferedImage sourceImage, String logoImagePath, boolean needCompressed) throws IOException &#123; File file = new File(logoImagePath); if (!file.exists())&#123; System.out.println("logo文件不存在！\n"); return; &#125; Image src = ImageIO.read(file); int width = src.getWidth(null); int height = src.getHeight(null); // 压缩二维码图片 if (needCompressed) &#123; if (width &gt; LOGO_WIDTH) width = LOGO_WIDTH; if (height &gt; LOGO_HEIGHT) height = LOGO_HEIGHT; Image image = src.getScaledInstance(width, height, Image.SCALE_SMOOTH); BufferedImage tag = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = tag.getGraphics(); g.drawImage(image, 0, 0, null); g.dispose(); // 释放占有的资源 src = image; // 直观的理解：Graphics2D 就相当于画笔，而BufferedImage 就是画笔绘制的结果。 &#125; // 插入logo Graphics2D graph = sourceImage.createGraphics(); int x = (QRCODE_SIZE - width) / 2; int y = (QRCODE_SIZE - height) / 2; graph.drawImage(src, x, y, width, height, null); Shape shape = new RoundRectangle2D.Float(x, y, width, width, 6, 6); graph.setStroke(new BasicStroke(3f)); graph.draw(shape); graph.dispose(); &#125; 解码过程1234567891011121314151617181920/** * TODO 解析二维码内容 * @param file 二维码 * @return 二维码包含的信息 * @throws Exception */ public static String decode(File file) throws Exception &#123; BufferedImage image; image = ImageIO.read(file); if (image == null) &#123; return null; &#125; BufferedImageLuminanceSource source = new BufferedImageLuminanceSource(image); BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source)); HashMap hints = new HashMap&lt;DecodeHintType, Object&gt;(); hints.put(DecodeHintType.CHARACTER_SET, CHARSET); Result result = new MultiFormatReader().decode(bitmap, hints); String resultStr = result.getText(); return resultStr; &#125; 测试结果源码下载地址：https://github.com/Liyzy/ZXing-QRCode开发环境：idea 2018.2]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java学习笔记3】继承&多态篇]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%91%2F</url>
    <content type="text"><![CDATA[继承 关键字extends表示继承，继承是一个is-a关系，java中只有公有继承 覆盖方法（override）将父类中的方法在子类中重新定义，以Employee类和Manager类为例，Manager继承Employee类，Employee有方法getSalary(); Manager类需要重写这个方法，加上经理所特有的奖金。 123456789101112131415161718public class Employee&#123; private double salary; ... public double getSalary()&#123; return salary; &#125;&#125;public class Manager extends Employee&#123; private double bonus; ... public double getSalary()&#123; //return salary + bonus; // 错误，不能访问超类的私有域 //return getSalary() + bonus; // 错误，调用自身直至崩溃 return super.getSalary() + bonus; // 正确 &#125;&#125;//super关键字表示调用父类的方法 子类构造器必须调用父类的构造器，并且应将这一过程放在程序的第一句 1234public Manager(String name, String id, double salary)&#123; super(name, id, salary); // 置于第一句，如果没有这句，系统自动调用父类的默认构造函数；如果没有默认构造函数有没有显式调用其他构造器就会产生错误 bonus = 0;&#125; java不支持多继承，即每一个类都只能继承最多一个类。但每一个类可以实现多个接口，这也是引入接口的一个考虑。 多态java实现多态的两种方式：重载(overloading)和覆盖(override)1234567891011121314151617181920212223242526/* override */Manager boss = new Manager("lihui", 201822, 50000);boss.setBonus(20000);Empolyee[] staff = new Empolyee[2];staff[0] = boss;staff[1] = new Employee("chengle", 201833, 60000);staff[0].setBonus(20000); // 错误，staff声明为Employee类型，Employee没有setBonus方法if(staff[0] instanceof Manager) ((Manager)staff[0]).setBonus(20000); // 正确，将staff[0]强制转换为Manager类型 for(Employee aEmpolyee: staff) System.out.println(aEmpolyee.getName() + " " + aEmpolyee.getSalary());// aEmpolyee定义为Empolyee类型，但在执行的时候，aEmpolyee引用的Empolyee和Manager调用不同的getSalary函数// 一个对象变量可以指示多种实际类型的现象称为多态。// 在运行的时候自动选择调用哪个方法称为动态绑定。/* overloading */public class Manager&#123; ... public double getSalary(String name)&#123;...&#125; public float getSalary(String name)&#123;...&#125; //错误，已经存在getSalary(String name)方法,即签名相同，说明重载与返回值无关 public double getSalary(String name, String id)&#123;...&#125; //正确的重载&#125; 方法的签名：方法的名字和参数列表称为方法的签名，返回类型不是签名的一部分。 override的规则： 子类覆盖父类中具有相同签名的方法。 返回类型是被重写方法的返回类型的子类型。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static、private、final的方法不能被重写。(private的方法本身就被定义成了final的) 构造器不能被重写。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 overloading的规则：方法名相同，参数列表必须不同，返回值可同可不同，修饰符可同可不同。 方法调用的过程1）假设调用x.f(param), 编译器一一列举x所属类中的名为f的方法以及其父类中访问属性为public的名为f的方法（超类的私有方法不可访问）。2）查看调用方法提供的参数类型。如果第一步中列举出的方法中有一个方法的参数列表与提供的参数类型完全匹配，就选择这个方法。如果没有找到与参数类型匹配的方法或者经过类型转换后有多个方法与之匹配，就会产生错误。3）如果是static、private、final方法或者构造器，编译器可以准确的知道应该调用哪个方法，静态绑定。4）动态绑定时，先查看子类中是否定义了这个方法，是则调用，否则调用父类的这个方法。 final修饰符定义类的时候加上final修饰符表示类不允许被继承，其中的方法自动的成为final，但是域不会变成final。一个方法或者一个域也可以加上final表示不可被覆盖或者不可改变域的值。 抽象类关键字abstract表示抽象类，包含有一个或多个抽象函数的类需要声明为抽象类（为了代码清晰），抽象类里的抽象方法不需要实现，在子类中对其进行实现。]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java学习笔记2】数组&运算符&权限篇]]></title>
    <url>%2F2018%2F07%2F08%2F%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E3%80%91%2F</url>
    <content type="text"><![CDATA[数组 运算符 包 访问权限 修饰符 数组1. 数组的声明：int[] a; 2. 数组的创建使用new运算符数组的创建int[] a = new int[100] 数组的长度不要求是常量：new int[n]会创建一个长度为n的数组 3. 数组的初始化可以使用for循环进行赋值，或者直接int[] a = {1, 2, 3}进行赋值；数组创建时，数字数组所有元素初始化为0，Boolean数组所有元素初始化为false，对象数组则初始化为null值。 4. 数组长度每一个数组都有成员属性length，使用a.length获得数组a的长度 5. 数组的遍历输出 a. 传统for循环12for(int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); b. for each循环123for(int element : a) System.out.print(element + " ");//对于在for循环语句中需要使用元素下标的程序来说不合适 c. 利用Arrays类的toString方法12System.out.println(Arrays.toString(a));//a为数值型的数组或Boolean数组 6. 数组拷贝12int[] b = a; //b和a引用同一个数组b[1] = 7; //此时访问a[1]也是7 如果希望把一个数组的所有值拷贝到一个新的数组,使用Arrays类的copyOf方法1int[] b = Arrays.copyOf(a, a.length); 第二个参数表示新数组的长度，比原数组长，则多余的元素被赋值为0或者false或者null，比原数组短，则只复制前面的对应长度的元素。方法Arrays.copyOfRange(type[] a, int start, int end)type为int, short, byte, long, double, float, Boolean 类型 7. 数组排序1Arrays.sort(a); //使用优化的快速排序 8. 多维数组多维数组创建123int[][] a = new int[2][3]; //正确int[][] b = new int[2][]; //正确, 第二维的长度可以动态申请，可以不同int[][] c = new int[][3]; //错误 多维数组遍历12345678910111213141516int[][] b = new int[2][];for (int i = 0; i &lt; b.length; i++) &#123; b[i] = new int[i + 1]; for (int j = 0; j &lt; b[i].length; j++) b[i][j] = i + j;&#125;//第一种方式for(int i = 0; i &lt; a.length; i++) for(int j = 0; j &lt; a[i].length) System.out.print(a[i][j] + " ");//第二种方式for (int[] row : b) for (int value : row) System.out.print(value + " ");//第三种方式System.out.println(Arrays.deepToString(b)); 多维数组的每一行是可以通过引用进行交换的。 运算符除法12345float a = 12.3f;int b = 5;a = a / 0; //得到Infinity或者NaNb = b / 0; //除零异常System.out.println(a); 取模123456789int a = 5;int b = -5;a = a % 3;b = b % 3;System.out.println(a + "," + b); //2,-2a = a % -3;b = b % -3;System.out.print(a + "," + b); //2,-2/*求模运算的结果与左操作数符号相同，与右操作数符号无关*/ 算术运算的结果不低于int型12345678byte a = 3;byte b = 2;b = a + b; //错误，a+b返回int型，int不能赋值给byteb = (byte)(a + b); //正确，强制转换b += a; //正确，b += a等价于b = (byte)(b + a)int c = 7;c = c + 5.2; //错误c += 5.2; //正确 虚箭头表示可能有精度损失的转换，实箭头表示无信息丢失的转换。 基本数据类型的数组之间不能相互赋值，因为java中数组是类。 移位运算&lt;&lt;左移，低位补0，移位中可能会出现符号变换&gt;&gt;右移，高位补符号位&gt;&gt;&gt;无符号右移，高位补01234int a = 5;// a &gt;&gt; 33等价于a &gt;&gt; 1，移的位数和数值类型的位数取模byte b = 5;// b &gt;&gt; 33等价于b &gt;&gt; 1,在b &gt;&gt; 33操作中，b自动提升为int型 ~位反运算，每一位取反 位逻辑运算位逻辑运算优先级 &amp; ^ | 三目运算符？：的第二第三操作数必须是可以赋值的 包一个类可以使用所属包中所有的类，以及其他包中的公有类。访问其他包中公有类的两种方式：在每个类前添加完整的包名；使用import语句(放在源文件的顶部，package语句的后面)。package语句对整个源文件有效，即同一个源文件里的所有类都属于这个包。 访问权限1234//public//private//protected//没有指定则为同包可访问 修饰符static 静态修饰符final 常量修饰符，也可以表示一个类不允许继承1234567891011121314public class A&#123; int i; static int j; public static void main(String[] args)&#123; i = 3; //错误，i只有在new了一个对象后才会存在 j = 7; //正确，j是静态的，不需要创建对象就存在 A a = new A(); a.i = 3; //正确 A.i = 3; //错误 A.j = 4; //正确，j是所有的A类对象所共有的，所以可以通过类名来访问 a.j = 4; //正确 &#125;&#125;]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitee(码云)、Github同时配置ssh key]]></title>
    <url>%2F2018%2F07%2F06%2FGitee(%E7%A0%81%E4%BA%91)%E3%80%81Github%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEssh%20key%2F</url>
    <content type="text"><![CDATA[一、到.ssh文件夹下cd ~/.ssh 二、通过下面的命令，依次生成两个平台的key12$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;github_id_rsa&quot;$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;gitee_id_rsa&quot; 完成后，.ssh文件夹生成以下文件 三、把public key复制到gitee和github执行命令cat github_id_rsa.pub把第二行到结尾的内容复制到github的ssh中保存 同样的操作，添加gitee的ssh 四、创建config文件解决ssh冲突在.ssh文件夹下执行命令vi config文件中添加以下内容1234567891011# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/gitee_id_rsa# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github_id_rsa 五、测试执行ssh -T git@github.com成功则返回Welcome to Gitee.com ,yourname!执行ssh -T git@gitee.com成功则返回Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access.]]></content>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java学习笔记1】数据类型&函数篇]]></title>
    <url>%2F2018%2F07%2F03%2F%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%91%2F</url>
    <content type="text"><![CDATA[Java简单介绍 第一个程序Hello World 基本数据类型 对象和类 数据声明 函数声明 参数传递 Java简单介绍 Java的优点：简单、可移植性 JDK (Java Development Kit) Java开发工具包 JRE (Java Runtime Environment) Java运行环境 只要具有JRE，就可以运行Java代码，而与操作系统的类别无关 安装完JDK后，在电脑“编辑系统环境变量”—-“环境变量”选项下，系统变量新建 变量名 JAVA_HONE 变量值 D:\Program Files\java\jdk-10.0.1(这是我的JDK位置) 系统变量找到Path变量，编辑新建D:\Program Files\java\jdk-10.0.1\bin之后在cmd 中测试命令 Java 和 Javac ，有东西输出之后就可以用Javac在cmd里编译Java程序了(生成.class文件)，用Java [option] [主类名]就可以运行程序了(java HelloWorld 而不是 java HelloWorld.class)。第一个程序 Hello World12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println("Hello World!"); &#125;&#125; 注意Java区分大小写，参数中的String的S必须大写。 基本数据类型charbooleanbyte, short, int, long, float, double char(字符型) 首先补充编码的知识ASCII码(美国信息交换标准代码，7-bits ASCII码) 七位码，共128个字符，它主要用于显示现代英语和其他西欧语言。GB2312，是中国国家标准的简体中文字符集，双字节字符集。GBK，GBK字符集主要扩展了繁体中文字的支持，双字节字符集。GB18030,GB 18030标准采用单字节、双字节和四字节三种方式对字符编码。单字节部分使用0×00至0×7F码(对应于ASCII码的相应码)。双字节部分，首字节码从0×81至0×FE，尾字节码位分别是0×40至0×7E和0×80至0×FE。四字节部分采用GB/T 11383未采用的0×30到0×39作为对双字节编码扩充的后缀，这样扩充的四字节编码，其范围为0×81308130到0×FE39FE39。其中第一、三个字节编码码位均为0×81至0×FE，第二、四个字节编码码位均为0×30至0×39。按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集(DBCS)。Unicode(万国码、统一码、单一码)，16位，也就是两个字节代表一个字符。UTF-8是一种8位的unicode字符集，编码长度是可变的，并且是ASCII字符集的严格超集，也就是说ASCII中每个字符的编码在UTF-8中是完全一样的。UTF-8字符集中，一个字符可能是1个字节，2个字节，3个字节或者4个字节长。一般来说，欧洲的字母字符长度为1到2个字节，而亚洲的大部分字符则是3个字节，附加字符为4个字节长。更多关于编码参考文章http://blog.sina.com.cn/s/blog_4b4409c30100vw9t.html 在Java中采用Unicode编码，所以char a = &#39;a&#39;; 和 char b = &#39;中&#39;一样都占两个字节(区别于C和C++)char c = &#39;\u21fa&#39;表示转义字符，格式为\u加上4位16进制数 boolean(布尔型)只有true 和 false 两个值，区别于C和C++。在C和C++中，bool类型可以用数字赋值，非零即为真，零为假。但在Java中只有boolean flag = true; 和 boolean flag = false; byte, short, int, long, float, double(数值型) 类型 存储要求 取值范围 备注 byte 1字节 -128~127 short 2字节 -32768~32767 int 4字节 超过21亿 long 8字节 很大很大 需要在数值后加后缀L float 4字节 大约为±3.402E+38 需要在数值后加后缀F，有效位6~7位 double 8字节 大约为±1.797E+308 需要在数值后加后缀D，有效位15位 float和double类型表示的的数值是离散的，可能有一些小数就是无法表示，只能为近似值。不加F后缀的浮点数值默认为double类型。float和double不能做移位运算。整形移位运算相当于除或乘2的移的位数的次幂。-1在计算机中存储形式为全一，无论移多少位都不变。 对象和类对象(哎)是现实世界中的一个实体。类是具有相同特征的对象的属性的集合。 类的声明1234567891011121314151617[修饰符1][修饰符2][修饰符...]class Student&#123; int i; //类内的变量可以不用定义时赋值，数值变量系统默认赋值为零；逻辑变量boolean默认为false static int j = 1; ... public void Func(float[] f) &#123; ... int i = 0; //函数内的变量随手赋值是个好习惯，不赋值的话，在内存中是暂时没有这个变量的 ... &#125; public static void main(String[] args) &#123; ... &#125; ...&#125; 类实例化为对象123456789Student s1 = new Student();Student s2;s2 = s1;//一个对象变量没有实际包含一个对象，而仅仅是引用一个对象。//new操作符返回的也是一个引用，即这个对象的存储地址。//上面代码中的s2 = s1;仅仅是把s1保存的引用复制一份给s2，并没有复制这个对象//可以将一个对象变量赋值为null，表明这个对象变量目前没有引用任何的对象//如果一个对象没有任何的对象变量引用它，那么这个对象就成为垃圾对象，会被系统自动清理//例如上面代码，如果添加s1 = null;那么这个对象不是垃圾对象，因为还有s2引用(指向)它。 数据声明没什么好说的。[变量类型] [变量名] = [初始值];说一些命名的规则和习惯吧(提高代码可读性)。 a. 必须是字母开头的由字母、数字、下划线组成的序列，区分大小写。虽然在命名可以使用$，但是不要使用。 b. 类名使用 UpperCamelCase(大驼峰) 风格，即每个单词首字母都要大写。 c. 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase(小驼峰) 风格，即从第二个单词开始首字母大写。如：studentName d. 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 e. 杜绝完全不规范的缩写， 避免望文不知义。 … 函数声明1[修饰符1][修饰符2][修饰符..] [函数返回值] [函数名](参数1，参数2，参数..) &#123;函数体&#125; 参数传递Java的函数参数传递只有一种方法：传值(call by value)java 成员变量(成员变量就是方法外部，类的内部定义的变量)存储在堆中的对象里面;局部变量就是方法或语句块内部定义的变量,局部变量必须初始化,局部变量的数据存在于栈内存中,栈内存中的局部变量随着方法的结束而出栈。 例子：12345678910111213141516171819202122232425public class Card&#123; int rank; public static void swap1(Card c1,Card c2) &#123; Card temp = c1; c1 = c2; c2 = temp; &#125; public static void swap2(Card c1,Card c2) &#123; int temp = c1.rank; c1.rank = c2.rank; c2.rank = temp; &#125; public static void main(String[] args) &#123; Card c1 = new Card(); c1.rank = 5; Card c2 = new Card(); c2.rank = 6; swap1(c1,c2); swap2(c1,c2); &#125;&#125; 结果是swap1并没有实现数值交换；swap2实现了数值的变换。分析：在main函数中，首先生成两个对象存储在堆中，并有引用变量c1,c2分别指向两个对象。在调用swap1，main函数的栈空间里复制c1,c2传递给函数，在函数中一波操作猛如虎，两个复制品的指向对象互换，然后函数结束，两个复制品出栈，然而原c1和c2的指向并没有改变。在swap2里，改的直接是存储在堆里的对象的变量，指向没有变化，但是内部的数值已经交换了。]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计范式]]></title>
    <url>%2F2018%2F06%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.第一范式(1NF) 定义：如果关系模式R的所有属性的域都是原子的，那么称关系模式R属于第一范式。 通俗的讲，第一范式就是属性不可再分。比如地址属性，可以再分为省、市、县等属性，所以在这种情况下，地址属性所在的关系模式就不符合第一范式。 2.第二范式(2NF) 定义：若R满足第一范式，且每一个非主属性完全函数依赖于主码，则R满足第二范式。 这里首先补充函数依赖的知识 平凡依赖和非平凡依赖如果A-&gt;B，A是B的超集，则称此函数依赖为平凡的。举个例子：A-&gt;A AB-&gt;A ABC-&gt;AB都是平凡依赖（此处的A、B、C为原子属性）非平凡依赖就是不包含自己或包含自己的集决定自己的函数依赖。 完全依赖和部分依赖函数依赖A-&gt;B称为部分依赖的条件是存在A的真子集C使得C-&gt;B。即A中的一部分就可以决定B，不需要所有的属性来决定B。反之，需要A中所有的属性才能来决定B，缺一不可，那么A-&gt;B就是一个完全依赖。 传递依赖如果A、B是两个属性集，存在A-&gt;B，如果c是一个属性，并且c不属于A或B，并且存在B-&gt;c，那么c就传递依赖于A。 根据2NF的定义，我们可以知道，单属性主键的关系模式一定符合第二范式。 3.第三范式(3NF) 定义：对于F*(F的闭包)中所有形如A-&gt;B的函数依赖（其中A、B都包含于R），以下至少一项成立： · A-&gt;B是一个平凡的函数依赖 · A是R的一个超码 · B-A中的每个属性c都包含于R的一个候选码中 简单的说，若R满足第二范式，且每一个非主属性都不传递函数依赖于主码，则R满足第三范式。即不存在如下依赖关系： 关键字段 → 非关键字段x → 非关键字段y举个例子：假定学生关系表为Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)，关键字为单一关键字”学号”，因为存在如下决定关系： (学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话) 这个数据库是符合2NF的，但是不符合3NF，因为存在如下决定关系： (学号) → (所在学院) → (学院地点, 学院电话) 即存在非关键字段”学院地点”、”学院电话”对关键字段”学号”的传递函数依赖。 4.BC范式(BCNF) 定义：若R满足第三范式，且每一个主属性都不部分函数依赖或传递函数依赖于主码，则R满足第三范式。· 每一个决定属性集（因素）都包含（候选）码· R中的所有属性（主，非主属性）都完全函数依赖于码 举个例子：假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系： (仓库ID, 存储物品ID) →(管理员ID, 数量) (管理员ID, 存储物品ID) → (仓库ID, 数量) 所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系： (仓库ID) → (管理员ID) (管理员ID) → (仓库ID) 即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。 BCNF分解算法1234567while(有违反BCNF的函数依赖)&#123; 找出违反BCNF的函数依赖A-&gt;B； 先计算A的闭包，且用A的闭包(除去A)替换B，并将其分解为&#123;A+&#125;和&#123;AU(R-(A+)&#125;; //比如A-&gt;B ，而&#123;A&#125;+=&#123;A,B,C&#125;，则用A-&gt;BC替换A-&gt;B; 求出分解后的关系满足的投影FD集合； 再看分解后的关系的FD集合是否满足BCNF，如果不满足，则继续分解&#125; 举个例子： 3NF分解算法 致谢：分解算法参考博客：https://blog.csdn.net/xiazdong/article/details/7517438]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库练习题(基础)]]></title>
    <url>%2F2018%2F06%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%E9%A2%98(%E6%AF%94%E8%BE%83%E5%9F%BA%E7%A1%80)%2F</url>
    <content type="text"><![CDATA[一、基本表的定义与删除T1.用SQL语句创建如下三张表：学生（Student）,课程表（Course）,和学生选课表（SC）,这三张表的结构如表1-1到表1-3所示。表1-1 Student表结构 列名 说明 数据类型 约束 Sno 学号 字符串 长度为7，主码 Sname 姓名 字符串 长度为10，非空 Ssex 性别 字符串 长度为2，取‘男’或‘女’ Sage 年龄 整数 取值15~45 Sdept 所在系 字符串 长度为20 默认为‘计算机系’ 123456create table Student(Sno varchar(7) primary key,Sname varchar(10) not null,Ssex varchar(2) check(Ssex='男' or Ssex='女'),Sage int check(Sage&gt;=15 and Sage &lt;=45),Sdept varchar(20) default('计算机系')); 表1-2Course表结构 列名 说明 数据类型 约束 Cno 课程号 字符串 长度为10，主码 Cname 课程名 字符串 长度为20，非空 Ccredit 学分 整数 取值大于0 Semster 学期 整数 取值大于0 Cperiod 学时 整数 取值大于0 1234567create table Course(Cno varchar(10) primary key,Cname varchar(20) not null,Ccredit int check(Ccredit&gt;0),Semster int check(Semster &gt;0),Cperiodint check(Cperiod&gt;0)); 表1-3 SC表结构表1-2Course表结构 列名 说明 数据类型 约束 Sno 学号 字符串 长度为7，主码，参照Student的外码 Cno 课程名 字符串 长度为10，主码，参照Course Grade 成绩 整数 取值0~100 1234567create table SC(Sno varchar(7),Cno varchar(10),Grade int check(Grade &gt;=0 and Grade &lt;=100),primary key(Sno,Cno),foreign key (Sno) references Student(Sno),foreign key (Cno) references Course(Cno)); PS:外码(键): 一个关系模式(r1)可能在它的属性中包含另一个关系模式(r2)的主码,这个属性在r1上称作参照r2的外码。关系r1称为外码依赖的参照关系，关系r2称为外码的被参照关系。FK一定来自另一个表的PK，FK是PK的子集。 如果外键或者主键要求命名，请使用以下语法12constraint pk_Student_Sno primary key (Sno)constraint fk_Student_Sno foreign key (Sno) references Student(Sno)//SC表，参照表后边的属性可以省略 已有表，添加外键1234alter table SCadd constraint fk_Student_Sno foreign key (Sno) references Student(Sno); 二、修改表结构T2.为SC表添加“选课类别”列，此列的定义为XKLB char(4) 1alter table SC add XKLB char(4); T3.将新添加的XKLB的类型修改为char(6)1alter table SC alter column XKLB char(6); T4.删除Course表的Cperiod列1alter table Course drop column Cperiod; T5.重命名Student表的Ssex列为sex1EXEC sp_rename 'Student.Ssex','sex'; 三、数据查询功能表3-1 Student表数据 Sno Sname Ssex Sage Sdept 9512101 李勇 男 19 计算机系 9512102 刘晨 男 20 计算机系 9512103 王敏 女 20 计算机系 9521101 张立 男 22 信息系 9521102 吴宾 女 21 信息系 9521103 张海 男 20 信息系 9531101 钱小平 女 18 数学系 9531102 王大力 男 19 数学系 12345678910insert into Studentvalues('9512101','李勇','男',19,'计算机系'),('9512102','刘晨','男',20,'计算机系'),('9512103','王敏','女',20,'计算机系'),('9521101','张立','男',22,'信息系'),('9521102','吴宾','女',21,'信息系'),('9521103','张海','男',20,'信息系'),('9531101','钱小平','女',18,'数学系'),('9531102','王大力','男',19,'数学系'); 表3-2 Course表数据 Cno Cname Ccredit Semster C01 计算机文化学 3 1 C02 VB 2 3 C03 计算机网络 4 7 C04 数据库基础 6 6 C05 高等数学 8 2 C06 数据结构 5 4 12345678insert into Course(Cno,Cname,Ccredit,Semster)values('C01','计算机文化学',3,1),('C02','VB',2,3),('C03','计算机网络',4,7),('C04','数据库基础',6,6),('C05','高等数学',8,2),('C06','数据结构',5,4); 表 3-3 SC表数据 Sno Cno Grade XKLB 9512101 c01 90 必修 9512101 c02 86 选修 9512101 c06 必修 9512102 c02 78 选修 9512102 c04 66 必修 9521102 c01 82 选修 9521102 c02 75 选修 9521102 c04 92 必修 9521102 c05 50 必修 9521103 c02 68 选修 9521103 c06 必修 9531101 c01 80 选修 9531101 c05 95 必修 9531102 c05 85 必修 12345678910111213141516insert into SC values('9512101','c01',90,'必修'),('9512101','c02',86,'选修'),('9512101','c06',NULL,'必修'),('9512102','c02',78,'选修'),('9512102','c04',66,'必修'),('9521102','c01',82,'选修'),('9521102','c02',75,'选修'),('9521102','c04',92,'必修'),('9521102','c05',50,'必修'),('9521103','c02',68,'选修'),('9521103','c06',NULL,'必修'),('9531101','c01',80,'选修'),('9531101','c05',95,'必修'),('9531102','c05',85,'必修'); T6.查询全体学生的学号与姓名12select Sno,Sname from Student; T7.查询全体学生的姓名，学号和所在系12select Sno,Sname,Sdept from Student; T8.查询全体学生的所有信息（三张表以上的关联查询）12select *from Student left join SC on Student.Sno=SC.Sno left join Course on SC.Cno=Course.Cno T9.查询全体学生的姓名及其出生年份12select Sname,2018-Sage as '出生年份'from Student T10.查询全体学生的姓名和出生年份，并在出生年份列前加入一个列，此列的每行数据均为“Year of Birth”常量值12select Sname,'Year of Birth',2018-Sage as '出生年份'from Student T11.在选课表（SC）中查询有哪些学生选修了课程，并列出学生的学号12select distinct Snofrom SC T12.查询计算机系全体学生的姓名123select Snamefrom Studentwhere Sdept='计算机系' T13.查询所有年龄在20岁以下的学生的姓名及年龄123select Sname,Sagefrom Student where Sage&lt;20 T14.查询考试成绩不及格的学生的姓名123select Snamefrom Student,SC where Student.Sno=SC.Sno and SC.Grade&lt;60 T15.查询年龄在20~23岁之间的学生的姓名，所在系和年龄123select Sname,Sdept,Sagefrom Student where Sage between 20 and 23 T16.查询年龄不在20~23之间的学生的姓名，所在系和年龄123select Sname,Sdept,Sagefrom Student where Sage not between 20 and 23 T17.查询信息系，数学系和计算机系学生的姓名和性别123select Sname,Ssexfrom Student where Sdept in ('信息系','数学系','计算机系') T18.查询既不属于信息系，数学系，也不属于计算机系的学生的姓名和性别123select Sname,Ssexfrom Student where Sdept not in ('信息系','数学系','计算机系') T19.查询学生表中姓“张”的学生的详细信息123select *from Student where Sname like '张%' T20.查询学生表中姓“张”，姓“李”和姓“刘”的学生的情况123select *from Student where Sname like '张%' or Sname like '李%' or Sname like '刘%' 使用下边的这种写法更加简便123select *from Student where Sname like '[张李刘]%' T21.查询名字中第2个字为“小”或“大”字的学生的姓名和学号123select Sname,Snofrom Student where Sname like '_[小大]%' T22.查询所有不姓“刘”的学生的姓名123select Snamefrom Student where Sname not like '刘%' T23.从学生表中查询学号的最后一位不是2，3，5的学生的情况123select *from Student where Sno not like '%[235]' T24.查询无考试成绩的学生的学号和相应的课程号123select Sno,Cnofrom SC where Grade is null T25.查询所有有考试成绩的学生的学号和课程号123select Sno,Cnofrom SC where Grade is not null T26.查询计算机系年龄在20岁以下的学生的姓名123select Snamefrom Student where Sdept='计算机系' and Sage&lt;20 T27.将学生按年龄升序排序123select *from Student order by Sage asc T28.查询选修了课程“c02”的学生的学号及其成绩，查询结果按成绩降序排列1234select Sno,Gradefrom SCwhere Cno='C02'order by Grade desc T29.查询全体学生的信息，查询结果按所在系的系名升序排列，同一系的学生按年龄降序排列123select *from Studentorder by Sdept,Sage desc T30.统计学生总人数12select count(*)from Student T31.统计选修了选修课程的学生的人数123select count(distinct Sno)from SCwhere XKLB='选修' T32.计算学号为9512101的学生的考试总成绩之和123select sum(Grade)from SCwhere Sno='9512101' T33.计算课程“c01”的学生的考试平均成绩123select avg(Grade)from SCwhere Cno='C01' T34.查询选修了课程“c01”的学生的最高分和最低分123select max(Grade),min(Grade)from SCwhere Cno='C01' T35.统计每门课程的选课人数，列出课程号和人数123select Cno,count(Sno) as '选课人数'from SCgroup by Cno T36.查询每名学生的选课门数和平均成绩123select Sno,count(Cno) as '选课门数',avg(Grade) as '平均成绩'from SCgroup by Sno T37.查询选修了3门以上课程的学生的学号1234select Snofrom SCgroup by Snohaving count(Cno)&gt;3 T38.查询选课门数等于或大于4门的学生的平均成绩和选课门数1234select Sno,avg(Grade) as '平均成绩',count(*) as '选课门数'from SCgroup by Snohaving count(*)&gt;=4 四、多表查询T39.查询每个学生的情况及其选课的情况12select *from Student left outer join SC on Student.Sno=SC.Sno T40.查询计算机系学生的选课情况，要求列出学生的名字，所修课的课程号和成绩123select Sname,Cno,Gradefrom Student,SCwhere Student.Sno=Sc.Sno and Sdept='计算机系' T41.查询信息系选修VB课程的学生的成绩，要求列出学生姓名，课程名和成绩123select Sname,Cname,Gradefrom Student,SC,Coursewhere Student.Sno=SC.Sno and SC.Cno=Course.Cno and sdept='信息系' and Cname='VB' 123select Sname,Cname,Grade from Student join SC on Student.Sno=SC.Sno join Course on Course.Cno=SC.Cno where Sdept = '信息系' and Cname = 'VB'; T42.查询所有选修了VB课程的学生的情况，要求列出学生姓名和所在的系123select Sname,Sdeptfrom Student join SC on Student.Sno=SC.Sno join Course on Course.Cno=SC.Cno where Cname='VB' T43.查询与刘晨在同一个系学习的学生的姓名和所在系12345select Sname,Sdeptfrom Studentwhere Sdept=(select Sdept from Student where Sname='刘晨') 123select s2.Sname,s2.Sdeptfrom Student as s1,Student as s2where s1.Sname='刘晨' and s2.Sname !='刘晨' and s1.Sdept=s2.Sdept T44.查询学生的选课情况，包括选修课程的学生和没有修课的学生12select *from Student left join SC on Student.Sno=SC.Sno T45.查询数学系成绩在80分以上的学生的学号，姓名123select Student.Sno,Snamefrom Student join SC on Student.Sno=SC.Snowhere Sdept='数学系' and Grade&gt;80 T46.查询计算机系考试成绩最高的学生的姓名123456select Snamefrom Student join SC on Student.Sno=SC.Snowhere Sdept='计算机系' and Grade=(select max(Grade) from Student join SC on Student.Sno=SC.Sno Group by Sdept having Sdept='计算机系') 五、嵌套子查询(T43) T47.查询成绩大于90分的学生的学号和姓名12345select Sno,Snamefrom Studentwhere Sno in (select Sno from SC where Grade&gt;90) T48.查询选修了“数据库基础”课程的学生的学号和姓名1234567select Sno,Snamefrom Studentwhere Sno in (select Sno from SC where Cno in (select Cno from Course where Cname='数据库基础')) T49.查询选修了刘晨没有选修的课程的学生的学号和所在系123456789select Sno,Sdeptfrom Studentwhere Sno in (select Sno from SC where Cno not in (select Cno from SC where Sno=(select Sno from Student where Sname='刘晨'))) T50.查询选修了课程“c02”且成绩高于此课程的平均成绩的学生的学号和成绩12345select Sno,Gradefrom SCwhere Cno='C02' and Grade&gt;(select avg(Grade) from SC where Cno='C02') T51.查询选修了课程“c01”的学生姓名12345select Snamefrom Studentwhere Sno in (select Sno from SC where Cno='C01') 12345select Snamefrom Studentwhere exists (select * from SC where Sno=Student.Sno and Cno='C01') PS.一般来说，在SQL中in子查询都可以用exists代替。EXISTS子查询可以看成是一个独立的查询系统，只为了获取真假逻辑值，EXISTS子查询与外查询查询的表是两个完全独立的毫无关系的表，当我们在子查询中添加了Sno关联之后，EXISTS子查询与外查询查询的表就统一了，是二者组合组建的虚表，是同一个表（这样当子查询查询到虚表中当前行的Cno为C01时，则将虚表当前行中对应的Sname查询到了）. 重点在于Sno关联之上，添加Sno关联，数据库会先将两张表通过Sno关联组合成一张虚表，所有的查询操作都在这张虚表上完成。 六、自查询T52.查询所有成绩大于C01课程最高成绩的学生的学号12345select SC2.Snofrom SC as SC1,SC as SC2where SC1.Sno=SC2.Sno and SC1.Cno=SC2.Cno and SC2.Grade&gt;all(select Grade from SC where SC.Cno='C01') 七、更新数据T53.将所有学生的年龄加112update Studentset Sage=Sage+1 T54.将“9512101”学生的年龄改为21岁123update Studentset Sage=21where Sno='9512101' T55.将计算机系学生的成绩加5分12345update SCset Grade=Grade+5where Sno in (select Sno from Student where Sdept='计算机系') 八、删除数据T56.删除所有学生的选课记录1DELETE FROM SC T57.删除所有不及格学生的选课记录12delete from SCwhere Grade&lt;60 T58.删除计算机系不及格学生的选课记录1234delete from SCwhere Grade&lt;60 and Sno in (select Sno from Student where Sdept='计算机系') 数据来源于网络，整理@lihui测试代码：建表代码题目代码测试环境：SQL Server 2017 考试结束了，烤糊了😭…附上题目留与后人吧2017-2018学年大连理工大学软件学院数据库考试题目说明 20分 10个选择（比较简单，复习注意概念，比如DBS，DB，DBMS都是什么。其中有两个有关事务的题，即第十二章内容，分别是ACID的四个性质内容和结束事务并回滚的语句是什么问题） 50分 4个关系代数，6个SQL，一个5分。考了not exists和not in 相互转换, not exists…except结构, 标量子查询，分组聚集的内容（懵的一匹@_@） 10分 范式分解 属性闭包和候选码（6分），判断第几范式（2分），BCNF分解（2分） 20分 ER图 画ER图（10分），转换成关系模式（10分）。（回忆版）商店记录商品信息和客户信息，商品信息包括商品编号、名称、单价等，客户信息包括客户编号、客户姓名、电话等。一个顾客可以购买多个商品，一件商品可以购买不同数量，一次性的购物记录在一个购物单里，商品销售时价格可以调整。要求商店可以查询一个客户的消费记录和消费总额。根据题意设计ER图，可以自己添加必要属性。]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【python learning 1】从Hello world!开始（print()函数解析）]]></title>
    <url>%2F2018%2F06%2F06%2F%E3%80%90python%20learning%E3%80%91hello%20world%2F</url>
    <content type="text"><![CDATA[老规矩，学习一门语言，肯定要从Hello world开始啦 python2print &quot;Hello world!&quot; python3print(&quot;Hello world!&quot;)不同的原因是，在python3中，print只作为一个函数调用，括号中的内容作为函数的参数。 但是，在python2中使用括号也没有问题。 print()函数: print（*objects,sep=&#39; &#39;,end=&#39;\n&#39;,file=sys.stdout,flush=False） 参数意义 *objects 表示要输出的值，可以是多个，用逗号分隔 sep 表示多个输出值之间的间隔，可以自己赋值，默认为一个空格 end 表示输出语句最末尾附加的字符串，默认为’\n’，即换行 #ps: 在Python2中，如果不想换行则在输出语句的末尾加一个逗号，Python3中写成print(“hhh”,end=’’)就好了。 file 表示输出的对象，可以是文件也可以是数据流，默认是sys.stdout flush 表示是否立刻将输出语句输出的目标对象，默认为False]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
