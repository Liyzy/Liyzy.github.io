<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[软件工程[4] 总体设计]]></title>
    <url>%2F2019%2Fsystem-design.html%2F</url>
    <content type="text"><![CDATA[设计过程总体设计的两个阶段 系统设计阶段：确定系统的具体实现方案 结构设计阶段：确定软件结构 🔖系统设计关注：物理组成、成本、工期，这些都是方案的组成部分。 典型的总体设计过程 设想供选择的方案 选取合理的方案 推荐最佳方案 功能分解 设计软件结构 设计数据库 制定测试计划 书写文档 审查与复审 🔖文档包括：系统说明、用户手册、测试计划、详细的实现计划和数据库的设计结果。 设计原理模块化模块化就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。模块化的理论依据是$E(P_1+P_2)&gt;E(P_1)+E(P_2)$，$E(P)$代表解决P问题的成本，即把复杂的问题分解成许多容易解决的小问题，从而降低成本。但随着模块数的增多，接口成本会随之增加，所以应根据这两个因素，得到最适当的模块数。 抽象抽出事务的本质特性——事物、状态或过程之间总存在着某些相似的方面(共性)——而暂时不考虑它们的细节，它是人类认识复杂事物时最有力的思维工具。从抽象到具体分析和构造软件的层次结构，是进行软件设计的一种有效的方法。复杂的动态系统：高级的抽象概念构造和理解$\rightarrow$较低的层次$\rightarrow$ … $\rightarrow$最低层次、具体元素 逐步求精“为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。”帮助软件工程师把精力集中在与当前开发阶段最相关的方面；目前不需要考虑的细节留到以后考虑；把一个时期内必须解决的问题按照优先级排序；自顶向下的策略。求精实际上是细化过程。抽象使得设计者能够说明过程和数据，同时却忽略低层细节。事实上，可以把抽象看作是一种通过忽略多余的细节同时强调有关的细节，而实现逐步求精的方法。求精帮助设计者在设计过程中揭示出低层细节。 信息隐藏与局部化局部化是指把一些关系密切的软件元素物理地放得彼此靠近。在模块中使用局部数据是局部化的一个例子。信息隐藏指的是应该这样设计和确定模块，使得一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。 模块独立“模块独立”概念是模块化、抽象、逐步求精和信息隐藏等概念的直接结果，也是完成有效的模块设计的基本标准。模块的独立程度可以由两个定性标准来度量，这两个标准分别称为耦合(Coupling)和内聚(Cohesion)。 耦合衡量不同模块彼此间互相依赖(连接)紧密程度 内聚衡量一个模块内部各个元素彼此结合的紧密程度 📌好的设计应力争：高内聚低耦合 耦合耦合的强弱取决于模块间接口的复杂程度，进入或访问一个模块的点，以及通过接口的数据。在软件设计中应该追求尽可能松散耦合的系统。在这样的系统中可以研究、测试或维护任何一个模块，而不需要对系统的其他模块有很多了解。此外，由于模块间联系简单，发生在一处的错误传播到整个系统的可能性就很小。因此，模块间的耦合程度的强弱将直接影响系统的可理解性、可测试性、可靠性和可维护性。 数据耦合一个模块访问另一个模块时，彼此之间是通过简单数据参数 (不是控制参数、公共数据结构或外部变量) 来交换输入、输出信息。 控制耦合传递的信息中有控制信息，尽管有时这种控制信息是数据的形式。控制耦合可以把模块适当分解后用数据耦合代替它。 特征耦合把整个数据结构作为参数传递，而被调用的模块仅需使用其中一部分数据。 公共环境耦合一组模块都访问同一个公共数据环境，公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。 内容耦合最高程度的耦合。出现以下情况之一就是发生了内容耦合： 一个模块直接访问另一个模块的内部数据 一个模块不通过正常入口转到另一模块内部(goto语句) 两个模块有一部分程序代码重迭(只可能出现在汇编语言中) 一个模块有多个入口(一个模块有几种功能) 🔖公共环境耦合的复杂程度随耦合模块的个数增加而显著增加。若只是两模块间有公共数据环境，则公共耦合有两种情况：松散公共环境耦合和紧密环境公共耦合。 松散公共环境耦合。一个模块往公共环境送数据，一个模块从中取数据，这是数据耦合的一种形式。 紧密环境公共耦合。两个模块都既往公共环境中送数据又从中取数据，介于数据耦合和控制耦合之间。 📌设计原则：尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全避免内容耦合。 内聚内聚标志一个模块内各个元素彼此结合的紧密程度，理想内聚的模块只做一件事情。设计时应该力求做到高内聚，通常中等程度的内聚也是可以采用的，而且效果和高内聚相差不多。内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间的松耦合。实践表明内聚更重要，应该把更多注意力集中到提高模块的内聚程度上。 低内聚 偶然内聚一个模块任务间关系松散或者没有关系。 逻辑内聚模块完成的任务在逻辑上属于相同或者相似的一类(如都是输出)。 时间内聚包含的任务必须在同一段时间内执行 (如初始化模块)。 中内聚 过程内聚一个模块内的处理元素相关，并且以特定的次序执行。通过研究程序流程图划分的模块一般是过程内聚。 通信内聚模块中所有元素都使用同一个输入数据和/或产生同一个输出数据。 高内聚 顺序内聚一个模块内的处理元素和同一个功能密切相关，并且必须顺序执行（前一个处理的输出是后一个处理的输入）。 功能内聚模块内所有处理元素属于一个整体，完成一个单一的功能。 🎈判断内聚方式的方法：模块是否只完成单一功能，是则为功能内聚，否则考虑模块内各组成部分的关系；如果是数据流的关系，那么考虑次序是否重要，是则为顺序内聚，否则为通信内聚；如果是控制流的关系，那么考虑次序是否重要，是则为过程内聚，否则为时间内聚；如果既不是数据流也不是控制流，那么考虑功能间逻辑是否类似，是则为逻辑内聚，否则为偶然内聚。 表示软件结构的图形工具层次图(H图)和HIPO图在层次图中一个矩形框代表一个模块。框间的连线表示调用关系(位于上方的矩形框所代表的模块调用位于下方的矩形框所代表的模块)。🔖H图与需求分析时介绍的层次方框图看起来是一样的，但内容和含义完全不同。H图方框间的连线表示调用关系，而不是组成关系。 HIPO图：带编号的H图(最顶层的方框不加编号)+带编号的IPO图。 结构图图中一个方框代表一个模块，框内注明模块的名字或主要功能；方框之间的箭头(或直线)表示模块的调用(call)关系。在结构图中通常还用带注释的箭头表示模块调用过程中来回传递的信息，可以利用注释箭头尾部的形状来区分传递的信息是数据还是控制信息：尾部是空心圆表示传递的是数据；实心圆表示传递的是控制信息。]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程[3] 需求分析]]></title>
    <url>%2F2019%2Frequirement-analysis.html%2F</url>
    <content type="text"><![CDATA[需求分析的任务 确定对系统的综合要求 分析系统的数据要求 导出系统的逻辑模型 修正系统开发计划 🔖系统的综合要求包括：功能需求、性能需求、可靠性和可用性需求、出错处理需求、接口需求、约束、逆向需求和将来可能提出的要求。🔖通常用数据流图、实体-联系图、状态转换图、数据字典和主要的处理算法描述系统的逻辑模型。 分析建模需求分析过程应建立三种模型： 数据模型(使用实体-联系图，即E-R图) 功能模型(使用数据流图) 行为模型(使用状态转换图) 实体-联系图数据模型包含三种相互关联的信息：数据对象、数据对象的属性及数据对象彼此间相互连接的关系。 数据对象数据对象是对软件必须理解的复合信息的表示。所谓复合信息是指具有一系列不同性质或属性的事物，因此，仅有单个值的事物(例如长度，名称)不是数据对象。可以由一组属性来定义的实体都可以认为是数据对象。（联系或称关系也可能有一组属性，但它不是数据对象）数据对象只封装了数据，没有包含作用于这些数据上的操作。 属性属性定义了数据对象的性质和特征。为了唯一地标识数据对象的某一个实例，定义数据对象中的一个属性或几个属性为关键字，简称键 (key)。 联系数据对象彼此之间相互连接的方式称为联系(关系)。 一对一联系(1∶1)🌰一个班级有一位班长．一个班长只能在一个班级任职，班级和班长这两个实体的联系是一对一的。 一对多联系(1∶N)🌰一个班级有多个班干部，一个班干部只能在一个班级任职，班级和班干部这两个实体的联系是一对多的。 多对多联系(M∶N)🌰一个学生可以选修多门课，一门课可以有多个学生选修，学生和课程这两个实体之间的联系是多对多的。 表示方法通常用矩形框代表实体，用连接相关实体的菱形框表示关系。用椭圆形或圆角矩形表示实体(或关系)的属性。并用无向边把实体(或关系)与其属性连接起来。 状态转换图(STD)状态转换图(State Transition Diagram, STD)通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。 状态状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。在STD中用圆形框或椭圆框表示状态，通常在框内标上状态名。状态规定了系统对事件的响应方式。系统对事件的响应，既可以是做一个(或一系列)动作，也可以是仅仅改变系统本身的状态，还可以是既改变状态又做动作。在状态图中定义的状态主要有：初态、终态和中间状态。在一个状态图中只能有一个初态，终态可以有零个或多个。 事件事件是在某个特定时刻发生的事情，它是对引起系统从一个状态转换到另一个状态的外界事件的抽象。简而言之，事件就是引起系统状态转换的控制信息。在状态图中，从一个状态到另一个状态的转换用箭头线表示，箭头表明转换方向，箭头线上标上事件名。必要时可在事件名后面加一个方括号，括号内写上状态转换的条件（守卫条件）。也就是说，仅当方括号内所列出的条件为真时，该事件的发生才引起箭头所示的状态转换。 符号 初态用实心圆表示；终态用同心圆（内圆为实心圆）表示。 中间状态用圆角矩形表示，用两条水平横线分为上中下三部分。上面为状态名，必须有的；中间为状态变量的名字和值（比如，timer=0），可选的；下面为活动表（语法格式为：事件名/动作表达式），可选的。活动表🌰：do/开始录音；exit/播放音乐 状态间转换用有向箭头，箭线上标明事件表达式。 其他图形工具层次方框图树形结构，树形结构的顶层是一个单独的矩形框，它代表完整的数据结构，下面各层的矩形框代表这个数据结构的子集，最底层的各个框代表组成这个数据的实际数据元素。 Wariner图花括号内的信息条目构成顺序关系；花括号从左至右排列表示树型层次结构；符号“⊕”表示不可兼具的选择关系；“￣”表示“非”；圆括号内的数字表示重复次数，（1,n）表示重复结构，（1）或不标次数表示顺序结构，（0,1）表示选择结构。 IPO图(Input Process Output Diagram)左边框中列出有关的输入，中间框中列出主要的处理，右边框中列出产生的输出。处理的顺序暗示了执行的顺序，箭头指出数据通信的情况。]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Depreciation]]></title>
    <url>%2F2019%2Fdepreciation.html%2F</url>
    <content type="text"><![CDATA[What can be depreciation? Assets must be used in business or held for production of income. Assets must have a definite useful life and a life &gt; one year. Assets that must be sth that wears out, gets used up, become obsolete or lose value. 🔖Depreciable property includes buildings, machinery, equipment, vehicles and some intangible properties(such as copyrights, designs, etc). Cost basisThe total cost that is claimed as an expense over an asset’s life, which includes the actual cost of the asset and all incidental expenses such as freight, insurance, and site preparation. Salvage valueThe salvage value of an asset is an asset’s estimated value at the end of its life.It is the amount eventually recovered through sale, trade-in, or salvage. Method of depreciationStraight-Line Method(直线折旧法)$D _ { n } = ( I - S ) / N , and\ constant\ for\ all\ n$$I = cost\ basis, S = salvage\ value, N = depreciable\ life$ Modified Accelerated Cost Recovery System(MACRS,修正的加速折旧法) Only a half-year of depreciation is allowed for the first year. A full year’s depreciation is allowed in each of the remaining years. The remaining half-year’s depreciation is incurred in the year following the end of the recovery period. A half-year of depreciation is also allowed for the year in which the property is disposed of, or is otherwise retired from service, anytime before the end of the recovery period. Switching from the DB method to the SL method. 🔖关键在于：项目的第一年只允许计提半年的折旧。如果项目生命周期大于折旧年限（比如5年），那么需要在第六年计提第一年剩下的半年的折旧。如果项目生命周期小于折旧年限，那么在项目的最后一年计提半年的折旧。🌰5-YEAR MACRS n DDB SL 1 1/2 * DDB=1/2 * 1/5 * 2 = 20% \ 2 2 * 1/5 * （1 - 20%）= 32% \ 3 2 * 1/5 * （1 - 20% - 32%）= 19% \ 4 2 * 1/5 * （1 - 20% - 32% - 19%）= 11.6% 1/2.5 * （1 - 20% - 32% - 19%）= 11.6% 5 2 * 1/5* （29% - 11.6%）= 6.96% 1/1.5 * （29% - 11.6%）= 11.6% 6 \ 0.5 * 11.6% = 5.8% Declining Balance Method(余额递减法)加速折旧法的一种。$\alpha = ( 1 / N ) \times (multiplier) \quad D _ { n } = \alpha B _ { n - 1 }$$\alpha B _ { n - 1 }$为上一年的$Book\ value$，$B_n=B_{n-1}-D_n$🔖If $\alpha$ is chosen to be the upper bound, $\alpha$ = 2(1/N), we call it a 200% DB or double declining balance method.(双倍余额递减法)🔖因为余额递减折旧法是按比例折旧，所以在不考虑有残值的情况($S=0$)下，使用余额递减折旧法永远也不能将固定资产(cost basis)计提干净。🔖因为余额递减折旧法不考虑残值，所以要注意在有残值的情况下，不允许固定资产的账面折余值小于预计残值收入。国内对折旧期年限到期以前的两年折旧额的处理采用直线法，即倒数第二年的期初账面余额减去残值，然后除以2，得到最后两年的平均年折旧额。 Switching policy(DB Switching to SL)🌰Assum S=0, cost basis=10000, depreciation life=5, double declining balance:Without switching table n Depreciation Book value 1 10000*0.4=4000 6000 2 6000*0.4=2400 3600 3 3600*0.4=1440 2160 4 2160*0.4=864 1296 5 1296*0.4=518 778 With switching to SL table n Depreciation Book value 1 10000/5=2000&lt;4000 6000 2 6000/4=1500&lt;2400 3600 3 3600/3=1200&lt;1440 2160 4 2160/2=1080&gt;864 1080 5 1080/1=1080&gt;518 0 📌使用转换策略时，SL计算中的N是还剩下的折旧年数。 Units-of-Production Method(单位产品工作量法)$D _ { n } = \frac { \text { Service units consumed for year } n } { \text { total service units } } ( I - S )$]]></content>
      <tags>
        <tag>工程经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Payback period and AE analysis]]></title>
    <url>%2F2019%2Fpayback-period-and-others.html%2F</url>
    <content type="text"><![CDATA[Payback periodConventional Payback Period(静态回收期)Formula静态回收期=累计净现金流量开始出现正值的年份数 - 1 + [上年累计净现金流量的绝对值/当年净现金流量] WeaknessDoes not consider the time value of money. Discounted Payback Period(动态回收期)Formula动态回收期=累计净现金流量折现值开始出现正值的年份数 - 1 + [上年累计净现金流量折现值的绝对值/当年净现金流量折现值] WeaknessCash flows occurring after discounted payback period(DPP) are ignored. CalculateMethod1:Method2: Capitalized Equivalent Worth(等值资本化)A special case of the PW criterion is useful when the life of a proposed project is perpetual or the service life is extremely long.The capitalized cost represents the amount of money that must be invested today in order to yield a certain return A at the end of each and every period forever.一次性投入以在以后的每个阶段(例如每年、每月等)产生一个确定的回报A。 Formula$C E ( i ) = P W ( i ) = A ( P / A , i , N ) = A / i \ (n\rightarrow \infty)$ Annual equivalent worth(年金等值分析)在评估项目时，如果使用现值分析(PW)应当保证两个项目的分析期(项目存活周期)相同。如果不同，可以采用最小公倍数法统一分析期，但这种方法很麻烦。这种情况下，可以使用年金等值分析，计算每一年的平均花费，然后进行比较。二者的关系是$\mathrm { AE } ( \mathrm { i } ) = \mathrm { PW } ( \mathrm { i } ) ( \mathrm { A } / \mathrm { P } , \mathrm { i } , \mathrm { N } )$。 Capital–Recovery Cost(资本重置费用)$\begin{aligned} \mathrm { CR } ( i ) &amp; = I ( A / P , i , N ) - S ( A / F , i , N ) \\ &amp; = ( I - S ) ( A / P , i , N ) + i S \end{aligned}$$I$为一开始购进设备的花费，$S$为设备的残值。]]></content>
      <tags>
        <tag>工程经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Economic Equivalence Computation]]></title>
    <url>%2F2019%2Feconomic-equivalence.html%2F</url>
    <content type="text"><![CDATA[Single-Payment SeriesCompound-Amount Factor(复利系数)$F = P ( 1 + i ) ^ { N } = P ( F / P , i , N )$ Present-Worth Factor(现值系数)$P = F [1 / ( 1 + i )] ^ { N } = F ( P / F , i , N )$ Equal-Payment SeriesCompound-Amount Factor(复利系数)$F = A ( F / A , i , N )$ Sinking-Fund Factor(偿债基金系数)$A = F ( A / F , i , N )$ Capital-Recovery Factor(投资回收系数)$A = P ( A / P , i , N )$ Present-Worth Factor(现值系数)$P = A ( P / A , i , N )$ Gradient Series(梯度序列)Linear Gradient Series(线性梯度系列)$P = G ( P / G , i , N )$ Geometric Gradient Series(几何梯度系列)$P = A_1 ( P / A_1 , g, i , N )$ Composite cash flow此处插入图片（后期）]]></content>
      <tags>
        <tag>工程经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cost of Capital]]></title>
    <url>%2F2018%2Fcost-of-capital.html%2F</url>
    <content type="text"><![CDATA[Types of Financing:Equity financingEquity financing uses retained earnings or funds raised from an issuance of stock to finance a capital. Debt financingDebt financing uses money raised through loans or by an issuance of bonds to finance a capital investment. Cost of CapitalWeighted average of Cost of Equity($i_e$) and Cost of Debt($i_d$) Cost of Equity$i _ { e } = r _ { f } + \beta \left[ r _ { M } - r _ { f } \right]$ $r_f$ = risk free interest rate (commonly referenced to U.S. Treasury bond yield) $r_M$ = market rate of return (commonly referenced to average return on S&amp;P 500 stock index funds) $\beta$ = A number greater than one (β &gt; 1) means that the stock is more volatile than the market on average; a number less than one (β &lt; 1) means that the stock is less volatile than the market on average. the after-tax Cost of Debt$i _ { d } = \left( c _ { s } / c _ { d } \right) k _ { s } \left( 1 - t _ { m } \right) + \left( c _ { b } / c _ { d } \right) k _ { b } \left( 1 - t _ { m } \right)$ $c_s$ = the amount of the term loan $c_b$ = the amount of bond financing $k_s$ = the before-tax interest rate on the term loan $k_b$ = the before-tax interest rate on the bond $t_m$ = the firm’s marginal tax rate $c_d$ = $c _ { s } + c _ { b }$ Cost of Capital$k = \frac { i _ { d } c _ { d } } { V } + \frac { i _ { e } c _ { e } } { V }$ $c_d$ = Total debt capital(such as bonds) in dollars $c_e$ =Total equity capital in dollars $V$ = $c_d+c_e$ $i_e$ = Average equity interest rate per period considering all equity sources $i_d$ = After-tax average borrowing interest rate per period considering all debt sources $k$ = Tax-adjusted weighted-average cost of capital]]></content>
      <tags>
        <tag>工程经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interest Rate]]></title>
    <url>%2F2018%2Finterest-rate.html%2F</url>
    <content type="text"><![CDATA[Simple interest(单利)Interest earned on only the principal amount during each interest period.仅用本金计算利息，而不计算利息所产生的利息。🌰如果有n个计息周期，周期利率为i，本金为P，则到投资期末，本利和F为：$F=P(1+i\times n)$ Compound interest(复利)The interest earned in each period is calculated based on the total amount at the end of the previous period.除了本金的计算外，还要计算利息所产生的利息。🌰如果有n个计息周期，周期利率为i，本金为P，则到投资期末，本利和F为：$F=P(1+i)^n$ Cyclic Interest Rate(周期利率)Cyclic interest rate refers to the interest rate which is calculated more than once in a year, and the average interest rate is the cyclic interest rate.周期利率是指一年内计息超过一次以上，平均每次计息的利率就是周期利率。$i=r/n$，$i$为周期利率，$r$为名义利率，$n$为一年内的计息周期(interest period)数 Nominal Interest Rate(名义利率)Interest rate quoted based on _an annual period_—-annual percentage rate(APR)年百分率 Effective Interest Rate(实际利率)Actual interest earned or paid in a year or some other time period.如果计息周期和支付周期一致，$i_a=(1+r/n)^n-1=(1+i)^n-1$，$i_a$为实际利率，$r$为名义利率，$i$为周期利率如果一年有K个支付周期(payment period)，每个支付周期内有C个计息周期(interest period)，那么一个支付周期内的实际利率为$i_p = [ 1 + r / C K ] ^ { C } - 1$，当C特别大趋近于无穷时，$i_p = e^{r/K}-1$ Equivalence Analysis using Effective Interest RatesTwo conceptspayment period: 支付周期interest period: 计息周期 StepsIn all financial analysis, we need to convert the APR into an appropriate effective interest rate based on a payment period.(which is the interest amount accumulated over a given period). Identify the payment period (e.g., annual, quarter, month, week, etc) Identify the interest period (e.g., annually, quarterly, monthly, etc) Find the _effective interest_ rate that covers the payment period. Example Suppose your savings account pays 9% interest compounded quarterly. If you deposit ￥10,000 for one year, how much would you have?$i = \frac { 9 \% } { 4 } = 2.25 \%$$i _ { a } = ( 1 + 0.0225 ) ^ { 4 } - 1 = 9.31 \%$$F= 10,000 (F/P,2.25 \% ,4)=10,000(F/P,9.31 \% ,1)=10,931$ A series of equal quarterly payments of ￥5,000 for 10 years is equivalent to what present amount at an interest rate of 9% compounded(a) quarterly (b) monthly (c) continuously(a) Payment period: Quarterly; Interest Period: Quarterly$i = \frac { 9 \% } { 4 } = 2.25 \%$ per quarter$N = 40 quarters$$P = 5,000 ( P / A , 2.25 \% , 40 ) = 130,968$(b) Payment period: Quarterly; Interest Period: Monthly$i = \frac { 9 \% } { 12 } = 0.75 \%$ per month$i _ { p } = ( 1 + 0.0075 ) ^ { 3 } = 2.267 \%$ per quarter$N = 40 quarters$$P = 5,000 ( P / A , 2.267 \% , 40 ) = 130,586$(c) Payment period: Quarterly; Interest Period: Continuously$i = e ^ { 0.09 / 4 } - 1 = 2.276 \%$ per quarter$N = 40 quarters$$P = 5,000 ( P / A , 2.276 \% , 40 ) = 130,384$]]></content>
      <tags>
        <tag>工程经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程[2] 可行性研究]]></title>
    <url>%2F2018%2Ffeasibility-study.html%2F</url>
    <content type="text"><![CDATA[可行性研究的任务不是解决问题，而是确定问题是否值得去解决。分析可能解法的利弊；判定系统规模和目标是否能够实现；效益是否可观。进一步分析和澄清问题定义；之后导出系统的逻辑模型；从逻辑模型出发，探索主要解法（实现方案）；对每种解法从以下方面研究可行性： 技术可行性 现有技术能否实现目标系统？ 经济可行性 能否收回投资并获得利润？ 操作可行性 操作方式是否适用于用户组织？ 法律、社会效益可行性 是否符合法律要求？ 可行性研究的过程 复查系统规模和目标 研究目前正在使用的系统（完成它的基本功能；解决它存在的问题；增加收入或减少支出） 导出系统的高层逻辑模型（数据流图、数据字典） 进一步定义问题（分析员与用户复查问题定义、工程规模和目标） 导出和评价供选择的解法（从技术等方面研究可行性） 推荐行动方针（是否继续进行该项目，若是则选择最佳解法，并进行成本/效益分析） 草拟开发计划 书写文档提交审查 系统流程图系统流程图是概括地描绘物理系统的传统工具。系统流程图表达的是数据在系统各部件之间流动的情况，而不是对数据进行加工处理的控制过程（程序流程图）。程序流程图是描述过程设计的工具。 数据流图(DFD)在数据流图中没有任何具体的物理部件，只是描绘数据在软件中流动和被处理的逻辑过程。 基本符号 符号 含义 正方形或立方体 数据源点或终点 圆角矩形或圆形 变换数据的处理 开口矩形或两条平行线 数据存储 箭头 特定数据流动方向 分层 顶层（0层）数据流图。仅包含一个加工，它代表被开发系统。 中间层数据流图。对其上层父图的细化，其每一加工可能继续细化，形成子图。 底层数据流图。加工不需再做分解（基本加工）的数据流图。 数据字典数据字典是描述数据的信息的集合，是对系统中使用的所有数据元素的定义的集合。系统的逻辑模型由DFD和数据字典共同构成，缺一不可。 数据字典的内容 一般信息。名字，别名，描述等。 定义。数据类型，长度，结构等。 使用特点。值的范围，使用频率，使用方式（输入，输出，本地），条件值等。 控制信息。来源，用户，使用它的程序，改变权，使用权等。 分组信息。父结构，从属结构，物理位置（记录、文件和数据库）等。 定义数据的方法 符号 含义 栗子 = 定义为 + 和 x=a＋b，表示x由a和b组成 [..$\mid$..] 或 x=[a$\mid$b]，表示x由a或由b组成 {} 重复 x=3{a}8，表示x中至少出现3次a, 至多出现8次a，也可以用上下标的形式表示次数限制 () 可选 x=(a)，表示a可在x中出现,也可不出现 🌰发票 = 单位名称 + 1{商品名+数量+单价+金额}5 + 总金额 + 日期 + (营业员) 成本/效益分析成本估计 代码行技术。人力成本=每行代码成本*代码行数。 任务分解技术。对于每个任务，估计人力成本（人月为单位）。 自动估计成本技术。采用相关软件自动估算。 成本/效益分析的方法 货币的时间价值。工程经济学P和F的关系。 投资回收期。越短越好。 纯收入。越多越好。 投资回报率。衡量工程经济效益时最重要的参考依据。 learn more: 工程经济学]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程[1] 软件工程学概述]]></title>
    <url>%2F2018%2Fsoftware-engineering-outline.html%2F</url>
    <content type="text"><![CDATA[软件危机介绍在计算机软件的开发和维护过程中所遇到的一系列严重问题。软件危机包含下述两方面的问题：如何开发软件，以满足对软件日益增长的需求；如何维护数量不断膨胀的已有软件。 产生原因与软件本身特点有关： 缺乏“可见性”，管理和控制软件开发过程相当困难。 不可能测试出全部错误，软件维护意味着改正或修改原来的设计，使得软件较难维护。 规模庞大，在技术和管理上异常复杂和困难。 与软件开发与维护的方法不正确有关： 忽视软件需求分析的重要性。 轻视软件维护。 消除的途径 对计算机软件正确认识：软件是程序、数据及相关文档的完整集合。 既要有技术措施(方法和工具)，又要有科学的组织管理措施 严密管理，良好组织，发扬团队精神 推广使用在实践中总结出来的开发软件的成功的技术和方法，并且研究探索更好更有效的技术和方法，尽快消除错误概念和做法 开发和使用更好的软件工具 软件生命周期软件生命周期由软件定义（包括问题定义、可行性研究和需求分析三个阶段）、软件开发（包括总体设计、详细设计、编码及单元测试和综合测试四个阶段，前两个阶段又称为系统设计，后两个阶段又称为系统实现）和运行（软件）维护3个时期组成。 问题定义“要解决的问题是什么” ——问题性质、工程目标、工程规模 可行性研究“上一个阶段所确定的问题是否有行得通的解决办法” ——技术、经济、操作、法律、社会效益等方面 需求分析“目标系统必须做什么” ——经用户确认的系统逻辑模型以及规格说明书 总体设计“概括地回答怎样实现目标系统?” ——实现目标系统的几种可能的方案；确定程序由哪些模块组成以及模块间的关系（体系结构） 详细设计“应该怎样具体地实现这个系统” ——详细设计每个模块；确定实现模块功能所需的算法和数据结构 编码和单元测试写出正确的、容易理解、容易维护的程序模块单元测试：对编写出的每个程序模块进行测试 综合测试通过各种类型的测试(及相应的调试)使软件达到预定的要求。最基本的测试是集成测试和验收测试。必要时可以用现场测试或平行运行进一步测试检验。保留正式的文档把测试计划、详细测试方案及实际测试结果保存，作为软件配置的一部分。 运行维护 改正性维护。诊断和改正在使用过程中发现的软件错误。 适应性维护。适应性修改软件以适应环境的变化。 完善性维护。根据用户的要求改进或扩充软件使它更完善。 预防性维护。修改软件为将来的维护活动预先做准备。 软件过程瀑布模型(Waterfall Model) 右图中实线表示开发过程，虚线表示维护过程 传统的瀑布模型开发软件特点： 阶段间具有顺序性和依赖性 前一阶段完成后才能开始后一阶段的工作。 前一阶段输出作为后一阶段输入，只有前一阶段有正确输出时，后一阶段才有可能正确结果。（实际上不可避免地会犯错误，因此实际的瀑布模型是带反馈环的） 推迟实现的观点 可避免急于求成而导致的返工。 将系统分析与逻辑设计同物理实现清楚分开开来。 尽可能推迟程序的物理实现。 质量保证的观点（文档驱动的模型） 每个阶段都必须完成和提交规定的文档，否则则认为该阶段任务未完成。 每个阶段结束前都要对所完成的文档进行严格评审，以尽早发现问题，纠正错误。 优点： 提供了一种规范，使得分析、设计、编码、测试与维护工作可以在该规范的指导下有序地展开，避免了软件开发、维护过程中的随意状态。 对于需求确定、不随时间发生变化的项目，瀑布模型仍然是一种可以考虑采用的过程模型。 缺点： 完全依赖静态文档，不适应需求经常发生变更的环境。 瀑布倒流导致开发成本高，只有到项目的开发晚期才能够得到程序的可运行版本。 出现“阻塞”状态 快速原型模型(Rapid Prototype Model)特点： 不带”反馈环“，线性顺序开发。 快速原型的本质是“快速”，尽可能使用快速开发工具尽快地建造出原型系统，以加速软件开发过程，节约软件开发成本。 原型的用途是获知用户的真正需求，一旦需求确定了，原型将被完全或部分抛弃。 优点： 减少由于需求的不明确而带来的开发风险。 缺点： 不适用于大型复杂系统的开发。 缺乏规范化的文档，内部结构可能不够好。 增量模型(Incremental Model)特点： 每个构件由多个相互作用的模块构成，并且能够完成特定的功能。 第一个增量构件往往实现软件的基本需求，提供最核心的功能。 然后以”滚雪球“的方式逐步扩充系统功能。 优点： 较短时间内提交可以部分工作的产品。 减少全新产品带给客户的冲击。 重要功能被首先交付使用，可以得到更多测试。 缺点： 集成新的增量构件时，必须保证不破坏原有系统。（需要开放式架构） 螺旋模型(Spiral Model)使用原型和风险分析相结合来尽量降低风险，可以理解为在每个阶段之前都增加了风险分析过程的快速原型模型。优点： 对可选方案和约束条件的强调有利于已有软件的重用。 有助于把软件质量作为软件开发的重要目标。 减少了过多/过少测试带来的风险。 维护作为开发的一个周期，与开发没有本质区别。 风险驱动型：风险过大时能及时终止项目。缺点： 风险驱动：需要专业的风险评估人员。 喷泉模型(Fountain Model) 以用户需求为动力，以对象为驱动的模型，是典型的面向对象生命周期模型。 体现了面向对象软件开发过程迭代和无缝的特性 圆圈重叠：活动之间存在交迭。 OO方法在概念和表示方法上的一致性保证了各项开发活动间的无缝过渡。 向下箭头：阶段内的迭代（求精）。 各项活动无明显边界，可同步进行。（为避免活动开发过分无序，应把“线性过程” （快速原型模型或如图中的中轴线）作为总目标） RUP (Rational Unified Process)(1) 9个核心工作流，前6个为核心过程工作流程，后3个为核心支持工作流程。(2) 把软件生命周期划分为四个连续的阶段：初始阶段、精化阶段、构建阶段和移交阶段。(3) 强调采用迭代和渐增的方式来开发软件。 敏捷过程与极限编程（Agile Software Process &amp; XP）敏捷宣言： 个体和互动高于流程和工具 工作的软件高于面面俱到的文档 客户合作高于合同谈判 响应变化高于遵循计划 敏捷开发的特点： 渐增式。短周期、小版本渐进交付。 协作。业务人员和开发人员长期紧密地在一起工作和交流。 简单易懂。方法本身易学、易修改和易存档。 适配性。即使在最后时刻也能够处理需求变化。 微软过程（MSF）微软过程软件生命周期：规划阶段、设计阶段、开发阶段、完成开发工作、准备好可发布版本。]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中间语言表示]]></title>
    <url>%2F2018%2FIntermediate-language-representation.html%2F</url>
    <content type="text"><![CDATA[编译器构成编译器分为前端和后端：前端：依赖于源语言，独立于目标机器。包括词法分析器、语法分析器、语义分析器和中间代码生成器。后端：依赖于目标机器，独立于源语言。包括代码优化器和代码生成器。 中间语言表示后缀表示 如果$E$是变量或常数，那么$E$的后缀表示就是$E$本身。 如果$E$是形式为$E_1 \ op \ E_2$的表达式，那么$E$的后缀表示是$E_1^{\prime}\ E_2^{\prime} \ op$，其中$E_1^{\prime}$和$E_2^{\prime}$分别是$E_1$和$E_2$的后缀表示。 如果$E$是形式为$(E_1)$的表达式，那么$E_1$的后缀表示也是$E$的后缀表示。 后缀表示不需要括号。 🌰(8 - 4) + 2 的后缀表示是8 4 - 2 + 图形表示——语法树有向无环图DAG 三地址代码三地址代码是语法树或DAG的一种线性表示。一般形式：$x := y\ op\ z$，其中，如果x不是最终结果，那么x作为临时变量放在活动记录的临时变量区中。🌰$a := (-b + cd ) + cd$的DAG的三地址代码12345t1 = -b;t2 = c * d;t3 = t1 + t2;t4 = t2 + t3;a = t4;]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L属性定义的计算]]></title>
    <url>%2F2018%2FComputation-of-L-attribute-definition.html%2F</url>
    <content type="text"><![CDATA[L属性定义的自上而下计算L属性定义如果每个产生式$A \rightarrow X _ { 1 } X _ { 2 } \cdots X _ { n }$的每条语义规则计算的属性是A的综合属性；或者是$X_j$的继承属性，$1 \leq j \leq n$, 但它仅依赖： 该产生式中$X_j$左边符号$X _ { 1 } , X _ { 2 } , \dots , X _ { j - 1 }$的属性 A的继承属性 显然，S属性定义属于L属性定义，因为上面的两条限制是对继承属性的限制。 L属性定义与S属性定义的区别S属性定义中，只要将产生式作为一个整体看待即可，语义规则可以视为是附着在整个产生式上。L属性定义则不一样，它跟属性所属的符号在产生式中的位置有关系，于是需要翻译方案。 翻译方案它的语义动作（在此不叫语义规则）放在花括号{}内，并且插入到产生式右部合适的地方。这是一种动作和分析交错的方法，以表示动作的执行时机。只有综合属性时：为每一个语义规则建立一个包含赋值的动作，并把这个动作放在相应的产生式右边的末尾。既有综合属性又有继承属性时： 产生式右部符号的继承属性必须在先于这个符号的动作中计算。 一个动作不能引用该动作右边符号的综合属性。 左部非终结符的综合属性只能在它所引用的所有属性都计算完后才能计算。计算该属性的动作通常放在产生式右端的末尾。 总的来说就是要保证动作在引用属性时其值已经可用，也就是要保证动作不会引用还没有计算出值的属性。 🌰对于文法$S \rightarrow A _ { 1 } A _ { 2 } \quad \left\{ A _ { 1 } .in : = 1 ; A _ { 2 } .in : = 2 \right\}$$A \rightarrow a \quad \{ p r i n t ( A.in ) \}$不符合条件一。在分析$A_1$时，要把它推导成$a$然后输出$A_1.in$，然而，这个时候还不知道$A_1.in$的值，因为赋值动作在整个产生式的末尾。如果把第一条产生式改为$S \rightarrow\{ A _ { 1 } .in : = 1 ; A _ { 2 } .in : = 2\}A _ { 1 } A _ { 2 }$，则是合理的翻译方案。 预测分析器的设计构造预测分析器时，必须要消除左递归，而消除左递归可能会引起继承属性的出现。原因是翻译分案的属性信息（语法树结点指针）的流动方向和归约的方向不一致。 构造方法(1) 函数的形参、返回值和局部变量 对每个非终结符A构造一个函数过程，对A的每个继承属性设置一个形式参数。 函数的返回值为A的综合属性（作为记录，或指向记录的一个指针，记录中有若干域，每个属性对应一个域）。为了简单，假设每个非终结只有一个综合属性。 A对应的函数过程中，为出现在A的产生式中的每一个文法符号的每一个属性都设置一个局部变量。 (2) 非终结符A对应的函数过程中，根据当前的输入符号决定使用哪个产生式候选。(3) 每个产生式对应的程序代码中，按照从左到右的次序，对于单词符号（终结符）、非终结符和语义动作分别作以下工作： 对于带有综合属性x的终结符X，把x的值存入为X.x设置的变量中。然后产生一个匹配X的调用，并继续读入一个输入符号。 对于每个非终结符B，产生赋值语句$c = B \left( b _ { 1 } , b _ { 2 } , \cdots , b _ { k } \right)$其中，$b _ { 1 } , b _ { 2 } , \cdots , b _ { k }$是为B的继承属性设置的变量，c是为B的综合属性设置的变量。 对于语义动作，把动作的代码抄进分析器中，用代表属性的变量来代替对属性的每一次引用。 用综合属性代替继承属性L属性定义的自下而上计算它能实现任何基于LL(1)文法的L属性定义，也能实现许多（但不是所有的）基于LR(1)的L属性定义。 L属性自下而上计算需要解决的问题自下而上的分析中，语义动作的执行是在使用产生式对句柄进行归约的时候。但是，L属性定义的继承属性的计算需要嵌在产生式右部不同的地方。🌰对于文法$A \rightarrow X Y \{ Z . i = X . x \} Z$在$Z$还没有开始处理前，继承属性$Z.i$在栈中就没有对应的$val$条目供其使用。 解决方案通过改写文法，使得所有嵌入在产生式中间的动作变换成只在产生式的最右端出现。分以下三种情况讨论： 删除翻译方案中嵌入的动作在文法中加入推出空串的标记非终结符，让每个嵌入动作由不同的标记非终结符M代表，并把该动作放在产生式$M \rightarrow \varepsilon$的右端。🌰$E \rightarrow T R$$R \rightarrow + T \left\{ p r i n t \left( ^ { \prime } + ^ { \prime } \right) \right\} R _ { 1 } | - T \left\{ p r i n t \left(^ { \prime } - ^ { \prime } \right) \right\} R _ { 1 } | \varepsilon$$T \rightarrow n u m \{p r i n t (n u m. v a l) \}$删除嵌入动作后：$E \rightarrow T R$$R \rightarrow + T M R _ { 1 } \left| - T N R _ { 1 } \right| \varepsilon$$M \rightarrow \varepsilon \{ print ( ^ { \prime } + ^ { \prime } )\}$$N \rightarrow \varepsilon \{ print ( ^ { \prime } - ^ { \prime } )\}$$T \rightarrow n u m \{p r i n t (n u m. v a l) \}$ 分析栈上的继承属性第一种情况：所依赖的属性在分析栈上的位置能静态确定对于产生式$A\rightarrow XY$，因为$Y$以下的任何子树在规约前，$X.s$的值已经在栈中，所以它的值可以被$Y$继承。如果$Y$的继承属性由复写规则$Y.i=X.s$定义，$X.s$是综合属性，那么在需要使用$Y.i$的地方，都可以使用$X.s$代替，如果能静态的确定$X.s$在栈中的位置。第二种情况：所依赖的属性在分析栈上的位置不能静态确定🌰 产生式 语义规则 $S\rightarrow aAC$ $C.i=A.s$ $S\rightarrow bABC$ $C.i=A.s$ $C\rightarrow c$ $C.s=g(C.i)$ 由于B可能在、也可能不在A和C之间，因此在使用$C\rightarrow c$规约时$C.i$的值（也就是$A.s$的值）在$stack[top-2].val$或者在$stack[top-1].val$。可以添加一个标志非终结符M，使$M.i$继承A的综合属性值，然后第二个产生式中的C继承M的综合属性值，这样，无论是用第一个产生式还是第二个产生式，$C.i$的值都可以在$stack[top-1].val$中得到。 产生式 语义规则 $S\rightarrow aAC$ $C.i=A.s$ $S\rightarrow bABMC$ $M.i=A.s;\ C.i=M.s$ $C\rightarrow c$ $C.s=g(C.i)$ $M\rightarrow \varepsilon$ $M.s=M.i$ 模拟继承属性的计算如果继承属性并不直接等于某个综合属性，而是它的一个函数，可以使用标记非终结符来模拟继承属性的计算。🌰 产生式 语义规则 $S \rightarrow a A C$ $C.i =f(A.s)$ $C \rightarrow c$ $C.s=g(C.i)$ 产生式 语义规则 $S \rightarrow a A N C$ $N . i = A . s; \ C.i = N.s$ $N \rightarrow \varepsilon$ $N.s=f(A.s)$ $C \rightarrow c$ $C.s=g(C.i)$ 引进标记非终结符号对基础文法的影响基础文法是LL(1)文法没有影响，修改后的文法仍将保持LL(1)文法。因为每个标记非终结符号是唯一的，而且只有唯一一个的$\varepsilon$产生式。任何一个LL(1)文法一定是LR(1)文法，因此加标记非终结符不会引起LR分析动作的冲突。基础文法是LR(1)文法可能使修改后的文法变成非LR(1)文法。]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运行时存储空间的组织与管理]]></title>
    <url>%2F2018%2FOrganization-and-Management-of-Runtime-Storage-Space.html%2F</url>
    <content type="text"><![CDATA[几个概念过程：是一个声明，最简单的形式是将一个名字和一个语句联系起来。名字是过程名，语句是程序体。过程的活动：过程的一次执行被称为过程的一次活动。活动记录：过程的每次活动所需信息的存储空间。生存期：从过程体开始执行到执行结束的时间，包括消耗在其调用过程和调用过程中调用其它过程所花费的时间。 局部存储分配名字的作用域作用域：一个声明起作用的程序部分。即使一个名字在程序中只声明一次，该名字在程序运行时也可能表示不同的数据对象。比如对函数的一个形参，每次赋不同的值，形参的名字只声明了一次，但可以表示不同的保存值的存储单元。 名字到存储单元的绑定环境把名字映射到左值（存储单元），而状态把左值映射到右值（值）。赋值改变状态，但不改变环境。如果环境将名字x映射到存储单元s，就说x被绑定到s。 名字 -- 环境 --> 存储单元 -- 状态 --> 值 活动记录一般的活动记录包括以下内容： 域 用途 临时数据 保存临时值，比如寄存器不足时，将计算的中间结果存放在这 局部数据 保存本过程内部定义的局部变量 保存的机器状态 用于保存本过程调用前的机器状态 访问链 通过访问链访问非局部数据 控制链 指向调用者的活动记录 返回值 存放本过程返回给调用过程的值 参数 存放调用过程提供的实在参数 局部数据的布局字节是可编址内存的最小单位。一个过程所声明的局部变量，按这些变量声明时出现的次序，在活动记录的局部数据区中依次分配空间。局部数据的地址可以用相对于某个位置（本过程对应的活动记录的起始位置）的偏移来表示。数据对象的存储安排深受目标机器寻址方式的影响，存在对齐问题。例如，要求整数（int，long）的相对地址可以被4整除。由于对齐而引起的无用空间称为衬垫空白区。12345678910111213// 对于以下两个结构体，因为衬垫区的存在，其size不同struct s1&#123; char c1; char c2; int i1; double d1;&#125;;struct s2&#123; char c1; int i1; double d1; char c2;&#125;; 全局栈式存储分配运行时内存空间的划分 区 用途 代码 存放目标代码（.exe） 静态区 全局变量，静态变量等 堆 动态分配的内存 空闲内存 为堆和栈提供动态支持 栈 活动记录 堆和栈是动态的，在它们占用的存储空间不断变化时，相向增长。在实际机器中，堆向高地址增长，栈向低地址增长。 内存分配策略静态分配策略名字在程序被编译时绑定到存储单元，不需要运行时的任何支持。绑定的生存期是程序的整个运行时间。控制再次进入该过程时，局部变量的值和控制上一次离开时的一样。每个活动记录的大小是固定的。过程调用时保存信息的地址在编译时也是已知的。 栈式分配策略——活动树和运行栈栈式分配主要用于管理过程的活动记录。局部变量的生存期是过程活动的时间。控制进入该过程时，局部变量绑定到存储单元，过程活动结束后，局部变量的空间释放。 活动树 每个结点代表某过程的一个活动 根结点代表主程序的活动 结点a是结点b的父结点，当且仅当控制流从a的活动进入b的活动 结点a 处于结点b 的左边，当且仅当a的生存期先于b的生存期 活动的执行顺序（程序的控制流）对应活动树的后根遍历（深度优先）。 运行栈把控制栈中的信息拓广到包括过程活动所需的所有局部信息（即活动记录）。不要把静态的数据画在运行栈里。 栈上可变长数据活动记录的长度在编译时不能确定的情况。🌰局部数组的大小要等到过程激活时才能确定。解决方案：编译时，在活动记录中为这样的数组分配存放数组指针的单元。运行时，这些指针指向分配在栈顶的数组存储空间。运行时，对数组的访问都要通过相应指针来间接访问。 悬空引用引用某个已被释放的存储单元12345678910int* dangle()&#123; int i = 20; return &amp;i; // return之后，i的存储单元被释放掉了&#125;int main()&#123; int* p; p = dangle(); return 0;&#125; 堆式分配策略内存分配与释放按照任意次序进行。堆中可能包含交错的正在使用的和已经释放的区域。 三种分配策略的比较 \ 静态分配 栈式分配 堆式分配 使用范围 外部变量、静态局部变量、常量 局部变量、形参 动态变量 分配时间 程序开始前 进入过程前 用户决定 释放时间 程序结束后 过程结束 用户决定 地址计算时间 编译时 运行时 运行时 存取速度 快 慢 慢 非局部名字的访问静态作用域无过程嵌套的静态作用域由于没有过程嵌套，声明在过程外的所有变量都可以分配在静态区。过程体中的非局部引用可以直接使用静态确定的地址（非局部数据此时就是全局数据）。 有过程嵌套的静态作用域过程嵌套深度设主程序的嵌套深度为1，从一个过程进入一个被包围的过程时，嵌套深度加1。变量的嵌套深度：它的声明所在过程的嵌套深度作为该名字的嵌套深度。 访问链（静态链）如果过程p直接嵌在过程q中，那么过程p的活动记录的访问链直接指向最靠近的属于过程q的活动记录的访问链。假定过程p的嵌套深度为$n_p$，它调用嵌套深度为$n_x$的过程x:(1) $n_p &lt; n_x$。表明被调用过程比p嵌的更深，而且过程x肯定嵌在过程p里，否则无法调用。这种情况下需要追踪访问链$n_x-n_p$次。(1) $n_p \geq n_x$。追踪访问链$n _ { p } - n _ { x } + 1$次到达了静态包围x和p的且离它们最近的那个过程的最新活动记录。所到达的访问链就是x的活动记录中的访问链应该指向的那个访问链。 动态作用域被调用过程的非局部名字a和它在调用过程中引用的是同样的存储单元。新的绑定仅为被调用过程的局部名字建立，这些名字在被调用过程的活动记录中占用存储单元。总结的说，动态作用域就是谁调用的找谁。 参数传递值调用实参的右值传给被调用过程。把形参当作所在过程的局部名看待，形参的存储单元在该过程的活动记录中。调用过程计算实参，并把右值放入形参的存储单元中。 对形参的任何操作不会影响调用者实参的值。 引用调用实参的左值传给被调用过程。把实参的左值放入形参的存储单元。在被调用过程的目标代码中，任何对形参的引用都是通过传给该过程的指针来间接引用实参的。 对形参的任何赋值都会影响调用者实参的值。 换名调用用实参表达式对形参进行正文替换。12345678910111213141516program main(input,output); var a,b: integer; procedure p(x,y,z: integer); begin y:＝y+1; z:＝z+x; end; begin a:＝2; b:＝3; p(a+b, a, a); print a; end．&#123;值调用结果为2，不改变实参值&#125;&#123;引用调用结果为8，a+b的结果5放在临时变量中，传参时将临时变量地址传过去&#125;&#123;换名调用可以看作是执行a=a+1;a=a+(a+b);注意在第二条语句中右边的每一个a都等于3&#125;]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语法制导的定义]]></title>
    <url>%2F2018%2FSyntax-Directed-Definition.html%2F</url>
    <content type="text"><![CDATA[语法制导语义分析的主流技术是语法制导翻译技术。语法制导是带有属性和规则的上下文无关文法。属性：在上下文无关文法的基础上，为每个文法符号（终结符或非终结符）配备若干相关的“值”，称为属性。属性可以计算和传递。规则：对于文法的每个产生式都配备了一组属性的计算规则。 综合属性和继承属性每个文法产生式$A \rightarrow \alpha$有一组形式为$b : = f \left( c _ { 1 } , c _ { 2 } , \cdots , c _ { k } \right)$的语义规则，其中$f$是函数，$b$和$c _ { 1 } , c _ { 2 } , \cdots , c _ { k }$是该产生式文法符号的属性。 综合属性如果$b$是$A$的属性，$c _ { 1 } , c _ { 2 } , \cdots , c _ { k }$ 是产生式右部文法符号的属性或$A$的其它属性。属性值由分析树中它的子结点的属性值来计算。 继承属性如果$b$是产生式右部某个文法符号$A$的属性， $c _ { 1 } , c _ { 2 } , \cdots , c _ { k }$是产生式右部文法符号的属性或$A$的其它属性。属性值由结点的兄弟结点及父结点的属性值来计算。 关于属性 终结符只有综合属性，并且这些综合属性通常由词法分析器提供。因为终结符没有任何的子结点。 非终结符号既有综合属性也可有继承属性，文法的开始符号没有继承属性，除非另外加以说明。因为开始符号没有任何的兄弟结点或者父结点。 文法符号的综合属性集和继承属性集的交集应为空。 对出现在产生式右边的继承属性和出现在产生式左边的综合属性都必须提供一个计算规则。属性计算规则中只能使用相应产生式中的文法符号的属性。 出现在产生式左边的继承属性和出现在产生式右边的综合属性不由所给的产生式的属性计算规则进行计算，它们由其它产生式的属性规则计算或者由属性计算器的参数提供。 属性文法属性文法是指语义规则函数无副作用的语法制导定义。副作用指的是过程调用或程序段（比如打印值、输出中间代码等）。🌰在产生式的语义规则中定义print(E.val) 注释分析树每个结点的属性值都标注出来的分析树，称为注释分析树。分析树是（最左、最右）推导的图形表示。每个分支结点由非终结符标记，子结点由该终结符本次推导所用产生式的右部的各符号依次标记。 属性依赖图在一棵分析树中的结点的继承属性和综合属性之间的相互依赖关系可以由称作依赖图的一个有向图来描述。 构造方法 为每一个包含过程调用的语义规则引入一个虚拟综合属性b，这样把每一个语义规则都写成$b : = f \left( c _ { 1 } , c _ { 2 } , \cdots , c _ { k } \right)$的形式。 依赖图中为每一个属性设置一个结点，如果属性b依赖于属性c，则从属性c的结点有一条有向边连到属性b的结点。 简单的说，如果一个属性n需要另一个属性m才能进行计算，那么添加一个有向线由m指向n。 属性的计算次序良定义的：若一个属性文法不存在属性之间的循环依赖关系，则称该文法为良定义的。如果是良定义的，那么依赖图的任一拓扑排序都是一个合理的属性计算顺序。]]></content>
      <tags>
        <tag>编译原理</tag>
        <tag>语法制导</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自下而上的语法分析]]></title>
    <url>%2F2018%2FBottom-up-parsing.html%2F</url>
    <content type="text"><![CDATA[句柄右句型$\gamma$的句柄是一个产生式的右部$\beta$，并且该句柄$\beta$通过产生式$A\rightarrow\beta$归约后，得到的是最右推导中的前一个句型。右句型：所有在最右推导中出现的句型都是右句型。🌰$S \Rightarrow _ { r m }$ aABe $\Rightarrow _ { r m }$ aAde $\Rightarrow _ { r m }$ aAbcde $\Rightarrow _ { r m }$ abbcde文法为$S \rightarrow$ aABe${ A \rightarrow A b c | b }$$B \rightarrow d$abbcde中的第一个b通过$A\rightarrow b$归约后得到aAbcde，是最右推导的前一个句型，所以第一个b是句柄。而第二个b通过$A\rightarrow b$归约后得到aAAcde，不是最右推导的前一个句型，所以第二个b不是句柄。（栗子中加粗部分为句柄） 句柄的右边仅含终结符。 如果文法二义，那么句柄可能不唯一。 两个冲突移进-归约冲突：既可以移进又可以归约时，无法决定。归约-归约冲突：当不止一个产生式可以归约，无法决定对哪个产生式进行归约。 活前缀活前缀：右句型的前缀，该前缀不超过最右句型句柄的右端。在移进-归约分析中，出现在栈中的串都是活前缀。🌰$\mathcal { S } \Rightarrow * _ { r m } \gamma A w \Rightarrow _ { r m } \gamma \beta w$$\gamma \beta$的任意前缀（包括$\varepsilon$和$\gamma \beta$本身）都是活前缀，这里的$\beta$是句柄。 LR分析表L表示从左到右扫描输入串，R表示最右推导。分为LR(0)/SLR(1)、LR(1)、LALR三种。 构造SLR分析表 拓广文法，即添加产生式$S ^ { \prime } \rightarrow S$ 构建识别活前缀的DFA 根据DFA构建SLR分析表 构建识别活前缀的DFALR(0)闭包函数closure(I) I中的所有项都属于closure(I) 如果$A \rightarrow \alpha \cdot B \beta$属于closure(I)，并且$B \rightarrow \gamma$是产生式，那么如果$B \rightarrow \cdot \gamma$还不在closure(I)中，则把它加入closure(I)中。 重复上面两个步骤，直至closure(I)不再变化。 LR(0)状态转换函数goto(I, X)I状态集中所有形如$[ A \rightarrow \alpha \cdot X \beta ]$的产生式对应的产生式$[ A \rightarrow \alpha X \cdot \beta ]$的LR(0)闭包。X为终结符或非终结符。🌰$S \rightarrow$ aABe ；${ A \rightarrow A b c | b }$ ；$B \rightarrow d$对于$I_0: S’ \rightarrow S$；$S \rightarrow \cdot aABe$$I_1=goto(I_0, a):$ $S \rightarrow a \cdot ABe$；$A \rightarrow \cdot Abc$；$A \rightarrow \cdot b$ 识别文法G活前缀的DFA通过下面的方式构造： 令$C = \{closure(S’ \rightarrow S)\}$ 对$C$中的每一个项目集应用转换函数goto(I, X)得到新的项目集$I_n$，并把$I_n$加入到$C$中。 重复第二步，直到$C$不再增大为止。 根据DFA构建SLR分析表状态i从$I_i$构造，它的action函数如下确定： 如果$[ A \rightarrow \alpha \cdot a \beta ]$在$I_i$中，并且goto($I_i$,a )=$I_j$，那么置action[i, a]为$s_j$。 如果$[ A \rightarrow \alpha \cdot ]$在$I_i$中，那么对FOLLOW(A)中的所有终结符a，置action[i, a]为$r_j$，$j$是产生式$A \rightarrow \alpha \cdot$的编号。 如果$\left[ \mathcal { S } ^ { \prime } \rightarrow \mathcal { S } \cdot \right]$在$I_i$中，那么置action[i, 💲]为接受acc。 如果出现动作冲突，那么该文法就不是SLR(1)的。 构造状态i的goto函数：对所有的非终结符A，如果goto($I_i$,A)= $I_j$, 那么goto[i, A]=$j$。 不能由上面两步定义的条目都为error。 SLR(1)文法的问题每个SLR(1)文法都不是二义的，但是，有许多非二义的文法不是SLR(1)，文法描述能力弱。SLR(1)是在构造完DFA的LR(0)项目集之后才应用预测符号的，即对需要归约的产生式，当其遇到产生式左部非终结符的FOLLOW集中的终结符时才进行归约，而在LR(0)的构造中没有考虑预测。 构造规范的LR分析表基本步骤同SLR一样，只在第二步和第三步时有所不同，只说不同的地方。 构建识别活前缀的DFA使用LR(1)文法，1表示项目$[A \rightarrow \alpha \cdot \beta , a]$中搜索符的长度。LR(1)闭包函数closure(I) I中的所有项都属于closure(I) 若$[A\rightarrow \alpha \cdot B \beta, a]$属于closure(I)，$B\rightarrow \gamma$是产生式，则对于每个终结符b$\in FIRST(\beta a)$，项$[B\rightarrow \cdot \gamma ,b]$也加入到closure(I)中。 重复上面两个步骤，直至closure(I)不再变化。 搜索符b的集合是FOLLOW(B)的一个子集。 LR(1)状态转换函数goto(I, X)I状态集中所有形如$[ A \rightarrow \alpha \cdot X \beta,b ]$的产生式对应的产生式$[ A \rightarrow \alpha X \cdot \beta,b ]$的LR(1)闭包。X为终结符或非终结符。注意这里的搜索符集b是直接由前面对应的项目抄过来的。 识别文法G活前缀的DFA通过下面的方式构造： 令$C = \{closure([S’ \rightarrow S, doller])\}$注：这里的doller指💲，latex解析不正确这样代替一下… 对$C$中的每一个项目集应用转换函数goto(I, X)得到新的项目集$I_n$，并把$I_n$加入到$C$中。 重复第二步，直到$C$不再增大为止。 根据DFA构建SLR分析表基本同SLR，不同点在于：在action函数中，如果有归约，SLR是根据左部非终结符的FOLLOW集决定进行归约；LR(1)是根据搜索符决定进行归约。 LR(1)文法的问题LR(1)文法描述能力较强，但是由于状态数目多，分析表较大。 构造LALR分析表LALR是在SLR(1)和LR(1)之间进行了文法描述能力与分析表紧凑程度之间做的折中。 LALR的做法合并识别LR(1)文法的活前缀的DFA中的同心项目集。 同心项目集略去搜索符后相同的项目集。🌰$B \rightarrow \cdot b B$ 和 $B \rightarrow \cdot b B ,b / a$ 合并同心集引起的冲突同心集的合并不会引起新的移进-归约冲突。🌰如果同心集中有移进-归约冲突$\left[ A \rightarrow \alpha \cdot, a / b \right][ B \rightarrow \beta \cdot a \gamma , c / d ]$，当面对输入符号a时不知道该移进还是归约。合并前的项目集应该有$\left[ A \rightarrow \alpha \cdot, x \right][ B \rightarrow \beta \cdot a \gamma , y ]$，肯定有个x为a，所以一定存在移进-归约冲突，说明合并之前就存在移进-归约冲突了。 同心集的合并有可能产生新的归约-归约冲突。🌰合并前项目集$[A \rightarrow c \cdot, d][B \rightarrow c \cdot, e]$和$[A \rightarrow c \cdot, e][B \rightarrow c \cdot, d]$，合并后为$[A \rightarrow c \cdot, e/d][B \rightarrow c \cdot, d/e]$，此时就产生了新的归约-归约冲突。 安利求LR分析表的工具：LR(0)/SLR(1) SLR(1) LALR]]></content>
      <tags>
        <tag>编译原理</tag>
        <tag>语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自上而下的语法分析]]></title>
    <url>%2F2018%2FTop-down-parsing.html%2F</url>
    <content type="text"><![CDATA[进行自上而下的语法分析，基于文法是LL(1)文法。分为递归下降的预测分析和非递归下降的预测分析。 提取左公因子对产生式组$A \rightarrow \alpha | \alpha b_1 | \alpha b_2 | \ldots | \alpha b_m | \gamma_1 | \gamma_2 | \ldots | \gamma_p$用如下产生式组替换$A \rightarrow \alpha A ^ { \prime } \left| \gamma _ { 1 } \right| \gamma _ { 2 } | \ldots | \gamma _ { p }$$A ^ { \prime } \rightarrow \varepsilon | b _ 1| b _ 2 | \dots | b _ { \mathrm { m } }$ 消除左递归对产生式组$A \rightarrow A \alpha _ { 1 } | A \alpha _ { 2 } | \cdots | A \alpha _ { n } | \beta _ { 1 } | \beta _ { 2 } | \ldots | \beta _ { m }$用如下产生式组替换$A \rightarrow \beta _ { 1 } A ^ { \prime } | \beta _ { 2 } A ^ { \prime } | \ldots | \beta _ { m } A ^ { \prime }$$A ^ { \prime } \rightarrow \alpha _ { 1 } \mathrm { A ^ { \prime } } | \alpha _ { 2 } \mathrm { A ^ { \prime } } |\ldots | \alpha _ { \mathrm { n } } \mathrm { A ^ { \prime } } | \varepsilon$Tips: 消除左递归并非一定产生等价的LL(1)文法。🌰$S\rightarrow Aa \mid b, A\rightarrow SB, B\rightarrow ab$ 如果把A的产生式代入S的产生式得到等价文法是LL(1)的。 如果把S的产生式代入A的产生式得到等价文法不是LL(1)的。 LL(1)文法第一个L代表从左到右扫描输入串，第二个L代表最左推导，1表示分析的每一步只需向前查看一个符号。LL(1)文法具有无二义性、无左公因子、无左递归的性质。对于文法的任何非终结符，使用它匹配输入串时，能够根据所面临的输入符号准确的选择产生式，如果该产生式匹配成功，那么这个匹配不是虚假匹配，如果该产生式匹配不成功，则用其他的产生式也一定不会匹配成功。 判断一个文法是否是LL(1)文法对于文法中的任何两个产生式$A\rightarrow\alpha\mid\beta$，满足： FISRT($\alpha$)$\bigcap$FISRT($\beta$)=$\varnothing$ 如果$\beta\Rightarrow^*\varepsilon$，那么$FISRT(\alpha)\bigcap FOLLOW(\beta)=\varnothing$ 非递归分析预测分析表的构建 对文法的每个产生式$A\rightarrow\alpha$，执行第二步和第三步。 对FIRST($\alpha$)的每个终结符a，把$A\rightarrow\alpha$加入 M[A, a]（即加入表中A行a列）。 如果$\varepsilon$在FIRST($\alpha$)中，对FOLLOW(A)的每个终结符b（包括💲）, 把$A\rightarrow\alpha$加入M[A, b]。 M的其它没有定义的条目都是error。]]></content>
      <tags>
        <tag>编译原理</tag>
        <tag>语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用例图中拓展(extend)和包含(include)的区别]]></title>
    <url>%2F2018%2Fthe-difference-between-include-and-extend-in-use-case-diagram.html%2F</url>
    <content type="text"><![CDATA[定义拓展(Extend)扩展关系是扩展用例的泛化关系继续基本用例的行为。扩展用例通过在概念上将附加动作序列插入基本用例序列来实现这一点。这允许扩展用例在基本用例中达到适当的扩展点并且满足扩展条件时继续基本用例的活动序列。当扩展用例活动序列完成时，基本用例继续。扩展用例通常定义可选的行为，这些行为本身并不一定有意义。注册用例本身就是完整且有意义的。它可以通过可选的Get Help On Registration用例进行扩展。拓展点为Registration Help。 包含(include)包含的用例的执行类似于编程中的子程序调用或宏命令。包含用例取决于所包含的用例的添加，这是必需的而非可选的。_用例B从较大的用例A中提取到一个单独的用例中。__用例B和C从较大的用例A中提取到单独的用例中。__用例C是从用例A和B中提取出来的，两个用例都使用UML包含关系重用。__结帐用例包括几个用例 - 扫描项目，计算总额和税金以及付款_ 区别用例之间的依赖关系在拓展关系中，基本用例是不依赖拓展用例来完成自身功能的。在包含关系中，基本用例必须依赖包含的用例才能完成自身的功能。 基本用例完整性在拓展关系中，基本用例是完整的；而在包含关系中，基本用例是不完整的，是抽象用例。 通过拓展点区别拓展关系是具有拓展点的，如果在两个用例之间可以找到一个合理的拓展点，那么可以认为两个用例之间是具有拓展关系的。 通过目的区别包含关系旨在重用由另一个用例建模的行为，而拓展关系旨在为现有用例添加部分以及为可选系统服务建模。Include =重用功能Extends =新功能和/或可选功能 用例关系的比较 参考：uml-diagrams.orgStack Overflow: What’s is the difference between include and extend in use case diagram?Reuse in Use-Case Models: extend, include, and Inheritance]]></content>
      <tags>
        <tag>软件工程</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FISRT集和FOLLOW集]]></title>
    <url>%2F2018%2Ffirst-set%26follow-set.html%2F</url>
    <content type="text"><![CDATA[FIRST集什么是FIRST集FIRST($\alpha$)是从$\alpha$推导出的串的起始终结符的集合。特殊情况：$\alpha\Rightarrow^{*}\varepsilon$时，规定$\varepsilon\in FIRST(\alpha)$ 怎么求FIRST集 若X$\rightarrow$a…， 则将终结符a加入FIRST(X)中； 若X$\rightarrow\varepsilon$，则将$\varepsilon$加入FIRST(X)中； 若X$\rightarrow$Y…，且Y属于非终结符，则将FIRST(Y)$-${$\varepsilon$}加入到FIRST(X)中； 若X$\rightarrow Y_1Y_2…Y_K$,且$Y_1,Y_2,..Y_{i-1}$ (2$\leqslant$i$\leqslant$k)都是非终结符，且$Y_1,Y_2,…Y_{i-1}$ 的FIRST集合中均包含$\varepsilon$，则将FIRST($Y_j$)的所有非$\varepsilon$元素加入到FIRST(X)中，(j=1,2,…i)。特别地，若$Y_1$~$Y_K$均有$\varepsilon$产生式，则将$\varepsilon$加到FIRST(X)中。 FISRT集中有$\varepsilon$。 FOLLOW集什么是FOLLOW集FOLLOW($\alpha$)是在所有句型中紧跟在$\alpha$后面的终结符集合。特殊情况：如果A是某个句型的最右符号$(S\Rightarrow^{*}\beta A)$，那么终结符💲属于FOLLOW(A)。 怎么求FOLLOW集 对文法的开始符号S，将$加入到FOLLOW(S)中。 若有$A\rightarrow\alpha B\beta$，则将FIRST($\beta$)$-${$\varepsilon$}加入到FOLLOW(B)中。$\alpha$可以为空串。 若$A\rightarrow\alpha B$或$A\rightarrow\alpha B\beta$，且$\beta\Rightarrow^{*}\varepsilon$，则将 FOLLOW(A)加入FOLLOW(B)中。$\alpha$可以为空串。 FOLLOW集中没有$\varepsilon$。 安利安利一个求FISRT集和FOLLOW集的工具：Toolbox]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由NFA转DFA以及DFA的化简]]></title>
    <url>%2F2018%2FNFA-transform-to-MinDFA.html%2F</url>
    <content type="text"><![CDATA[NFA(Non-deterministic Finite Automata)不确定有限自动机构造NFA分成两步：画出每一个小单元的NFA；将每一个小单元的NFA组合。 小单元的NFA 单个输入符号a 连接运算ab 选择运算a|b添加两个状态（选择运算开始状态和结束状态），在开始状态引两个路径通过$\varepsilon$分别到两个单输入符号的NFA，同时两个NFA都通过$\varepsilon$到结束状态。 闭包运算添加两个状态（闭包运算开始状态和结束状态），四条线：闭包运算开始状态到单元开始状态；单元结束状态到闭包运算结束状态；闭包运算开始状态到闭包运算结束状态；单元结束状态到单元开始状态。(a|b)(ab)a* 组合在组合时，每一个小单元的NFA的开始状态不变，结束状态和下一个单元的开始状态合并。(a|b)*ab NFA转DFA(Deterministic Finite Automata)两个概念$\varepsilon$-$closure(\{1,2,…,n\})$：状态集{1,2,…,n}的$\varepsilon$闭包。上式的含义为求1，2，…，n状态仅通过零个或多个$\varepsilon$可以到达的所有状态组成的集合。$move(A,a)$：状态转换集。A中的所有状态通过a可以到达的所有状态组成的集合。 以$(a|b)*ab$为例 标记A集合A集合为开始状态（即0状态）的$\varepsilon$闭包。如img-7中，0状态通过$\varepsilon$可以到达1状态，7状态；1状态通过$\varepsilon$又可以到达2状态和4状态；再加上本身：故A={0, 1, 2, 4, 7}。 找出所有的输入字母如$(a|b)*ab$中，所有的输入字母为{a, b} 根据输入字母寻找A集合的$\varepsilon$闭包如img-7中，A集合中遇到a能发生状态转变的只有2和7，转换到状态3和8，所以$move(A,a)$={3,8}；然后求$\varepsilon$-$closure(move(A,a))$，即$\varepsilon$-$closure(\{3,8\})$，可以得到结果为{3, 8, 6, 1, 2, 4, 7}=B。$move(A,b)$={5},然后求$\varepsilon$-$closure(\{5\})$={5, 6, 1, 2, 4, 7}=C。 根据输入字母寻找所有新产生的集合的$\varepsilon$闭包$\varepsilon$-$closure(move(B,a))$={1,2,3,4,6,7,8}=B$\varepsilon$-$closure(move(B,a))$={1,2,4,5,6,7,9}=D$\varepsilon$-$closure(move(C,a))$={1,2,3,4,6,7,8}=B$\varepsilon$-$closure(move(C,a))$={1,2,4,5,6,7}=C$\varepsilon$-$closure(move(D,a))$={1,2,3,4,6,7,8}=B$\varepsilon$-$closure(move(D,a))$={1,2,4,5,6,7}=C包含NFA结束状态的集合为DFA结束状态，在例子中D状态为结束状态；A状态为开始状态。 根据以上的计算结果画出DFA DFA的化简 加入死状态如果一个DFA的转换函数不是全函数，那么必须加入一个死状态$S_d$，死状态只有输入而没有输出。例如一个状态S对a没有转换，即move(S,a)=$\varnothing$，则$\varepsilon$-$closure(move(S,a))$=$S_d$。 把状态集分为接受状态集和非接受状态集接受状态集指包含NFA结束状态的集合；非接受状态集指不包含NFA结束状态的状态集。例如，在例子中，可以把状态机划分为{A,B,C}和{D}。 合并不可区分状态对上一个步骤中的每一个集合的进行划分。如果集合中只有一个元素，那就不必再划分，如{D}；如果集合中有多个元素，则寻找哪几个元素经过所有输入字母的转换后可以产生非本集合的元素，则将其分离成一个新的集合，如果两个状态通过所有的输入字母都转换到该集合的相同元素，那么它们不必再分。 对于上一个步骤中产生的新划分，重复上一步骤，直至不可再分。 如果结果中有死状态，则去除死状态，把所有到死状态的转换都改为无定义。 栗子 其实可以把划分的过程看成是一个集合内部排异的过程。栗子🌰：首先根据接受和非接受划分为集合{A,B,C}和{D,E,F,G,H,I}对于集合{A,B,C}，A说我可以到B和C，C说我可以到B和C，B说我可以到B和D。A和C听了就不高兴了，我们两个不论怎么变都是到我们这个小集体里，你咋还跑出去了呢，我俩不和你好了。于是就分成了{A,C}和{B}。A和C又开始继续交流，但是他俩通过变换都跑到了{A,C}的外边，一起叛变，而且对于每一个输入符号，两人都是到同一个元素，只有这样，两人还是朋友，嗯，{A,C}成为一个集合。对于集合{D,E,F,G,H,I}，兄弟六人怎么变都还是在这兄弟六人内部，于是六个人是一个团结的集体。所以，原来的9个状态，经过划分之后，就变成了3个状态。栗子🌰🌰：再给一个栗子自己体会吧化简之后： 安利安利一个求NFA,DFA,Min-DFA的工具：Toolbox]]></content>
      <tags>
        <tag>编译原理</tag>
        <tag>词法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pyhton GUI编程之tkinter]]></title>
    <url>%2F2018%2Ftkinter%2F</url>
    <content type="text"><![CDATA[tkinter控件使用图片问题_tkinter.TclError: couldn&#39;t recognize data in image file &quot;xxx&quot;参考The Tkinter PhotoImage Class，PhotoImage for images in PGM, PPM, GIF and PNG formats. The latter is supported starting with Tk 8.6.想要使用其他类型的图片需要使用PIL(Python Imaging Library)处理。首先安装Pillowpip install Pillow然后123456from PIL import Image, ImageTkimage = Image.open("you image path")photo = ImageTk.PhotoImage(image)label = Label(image=photo)label.image = photo # keep a reference!label.pack() 设置窗口标题1root.title("yZip 1.0.0") # 窗口标题 设置窗口居中显示12345678# maxsize()获得当前显示器分辨率nScreenWid, nScreenHei = root.maxsize() # 窗口应有大小，若使用winfo_width()则返回当前窗口大小，如果还未调用mainloop(),则返回0nCurWid = root.winfo_reqwidth() nCurHeight = root.winfo_reqheight()# &#123;&#125;x&#123;&#125;设置窗口初始大小，如果没有这个设置，窗口会随着组件大小的变化而变化;&#123;&#125;+&#123;&#125;表示窗口距离屏幕左上角的位置root.geometry("&#123;&#125;x&#123;&#125;+&#123;&#125;+&#123;&#125;".format(nCurWid, nCurHeight, (nScreenWid - nCurWid)//2, (nScreenHei - nCurHeight)//2)) 设置窗口背景颜色1root.configure(background='RoyalBlue') # 窗口背景颜色 设置窗口置顶1root.wm_attributes('-topmost', 1) 禁止窗口最大化12root = Tk()root.resizable(False, False) 创建下拉菜单Combobox123456# 下拉选择菜单ziptype = StringVar() # 窗体自带的文本，新建一个值typeChoices = Combobox(frame2, width=12, textvariable=ziptype)typeChoices['values'] = ('zip', '7z', 'tar') # 设置下拉列表的值typeChoices.grid(row=3, column=1, sticky=NW)typeChoices.current(0) # 设置下拉列表默认显示的值，0为 numberChosen['values'] 的下标值 创建输入框Entry12345678sv1 = StringVar() # 可以使用sv1.get()获得输入框的内容，当在初始化时定义了textvariable=sv1entryKey = Entry(frame3, width=20, bg="white", fg="black", show='*', state=DISABLED, textvariable=sv1, # 初始状态设为不可用 validate="focusout", # validate密码格式验证在该输入框失去焦点后 invalidcommand=invalid, # 密码格式不正确即validatecommand返回False时调用invalid validatecommand=(self.top.register(validateKey), '%P')) # 密码格式验证函数，这里只需验证第一个输入框即可entryKey.grid(row=5, column=1, padx=10) 创建复选框Checkbutton12345678910111213check = IntVar()def testCheckButton(): print("var is " + str(check.get()))c = Checkbutton(frame2, text="输入密码：", font="YaHei, 10", variable=check, command=testCheckButton)c.grid(row=5, column=0, sticky=NW)'''check变量具有值0或者1可以用check.get()获得check的值，即Checkbutton的状态（0为未勾选，1为勾选）当初始时设置了variable=check''' 事件绑定123456789101112import tkinter# 一般情况下的事件绑定def handler(): '''事件处理函数''' print ("handler") if __name__=='__main__': root = tkinter.Tk() btn = tkinter.Button(text=u'按钮', command=handler) btn.pack() root.mainloop() 123456789101112import tkinter# handler()函数需要参数的情况下使用lambdadef handler(a, b, c): '''事件处理函数''' print ("handler", a, b, c) if __name__=='__main__': root = tkinter.Tk() btn = tkinter.Button(text=u'按钮', command=lambda : handler(a=1, b=2, c=3)) btn.pack() root.mainloop() 创建消息框messagebox12345678910import tkinterimport tkinter.messagebox tkinter.messagebox.showinfo('提示', '明天有雨') # 提示信息tkinter.messagebox.showwarning('警告','木马文件') # 警告信息tkinter.messagebox.showerror('错误','密码不匹配') # 错误信息tkinter.messagebox.askokcancel('询问','继续?') # 是否继续某操作tkinter.messagebox.asktrycancel('询问','再次尝试?') # 是否再次尝试某操作tkinter.messagebox.askquestion('问题','你喜欢音乐么？') # 询问一个 是/否 问题tkinter.messagebox.askyesno('问题','你喜欢音乐么？') # 询问一个 是/否 问题 画布工具Canvas12345678910111213141516171819canvas = tk.Canvas(root, bg='gray', height=200, width=100) image_file = tk.PhotoImage(file='tkinter.gif')image = canvas.create_image(10, 10, anchor='nw', image=image_file) x0, y0, x1, y1 = 20, 20, 40, 40# 从坐标(20,20)到(40,40)画一条直线。line = canvas.create_line(x0, y0, x1, y1) # 从0度到180度画一个扇形arc = canvas.create_arc(x0+30, y0+30, x1+30, y1+30, start=0, extent=180) # 创建一个矩形rect = canvas.create_rectangle(100, 30, 100+20, 30+20)# 创建一个填充色为red的圆oval = canvas.create_oval(x0, y0, x1, y1, fill='red') canvas.pack() 列表Treeview12345678910111213141516171819202122232425262728columns = ("文件名", "文件大小", "文件夹路径")treeview = Treeview(frame1, height=18, show="headings", columns=columns, yscrollcommand=scrollBar.set)# 设置每列宽度和对齐方式treeview.column("文件名", width=200, anchor='center')treeview.column("文件大小", width=200, anchor='center')treeview.column("文件夹路径", width=380, anchor='center')# 设置每列表头标题文本treeview.heading("文件名", text="文件名")treeview.heading("文件大小", text="文件大小")treeview.heading("文件夹路径", text="文件夹路径")treeview.pack()# 插入def SelectFiles(treeview): fnames = askopenfilenames() for i in range(0, len(fnames)): basename = os.path.basename(fnames[i]) size = os.path.getsize(fnames[i]) treeview.insert("", "end", values=[basename, size, fnames[i]])# 删除选中条目def DeleteFilesFromTreeview(treeview): selected_files = treeview.selection() for i in range(0, len(selected_files)): treeview.delete(selected_files[i])# 得到所有的条目值children = treeview.get_children()for c in children: print(treeview.item(c)["values"][0]) # 要得到第二列值则改为treeview.item(c)["values"][1] 字符串类型的一串数字格式化输出1234567# 格式化输出if 0 &lt; size &lt; 1024 * 1024: size = "%(size).1f" % &#123;'size': size / 1024&#125; + "KB"elif size &lt; 1024 * 1024 * 1024: size = "%(size).2f" % &#123;'size': size / (1024 * 1024)&#125; + "MB"else: size = "%(size).2f" % &#123;'size': size / (1024 * 1024 * 1024)&#125; + "GB" 窗口隐藏（或最小化）与显示123456789# 隐藏窗口mainwindow.withdraw() # 显示窗口mainwindow.update()mainwindow.deiconify()# 最小化窗口mainwindow.iconify()# 显示窗口mainwindow.deiconify()]]></content>
      <tags>
        <tag>python</tag>
        <tag>tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络与信息安全复习]]></title>
    <url>%2F2018%2F%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[第一章安全攻击分类被动攻击：信息内容泄露、流量分析主动攻击：伪装、重播、消息修改、拒绝服务 安全服务认证：保证通信的真实性。确保通信双方的身份是可信的。访问控制：防止资源非授权使用数据保密性：防止传输消息受到被动攻击。数据完整性：与主动攻击有关，检测而不是阻止。不可否认性：防止通信方对通信行为的否认，包括源不可否认性和宿不可否认性。可用性：系统或系统资源能够按照要求根据系统性能规范被授权系统的实体访问和使用。 第二章理论安全与实际安全理论安全：攻击者无论截获多少密文，都无法得到足够的信息来唯一地决定明文。香农证明只有一次一密才能达到理论安全，不实用。实际安全（计算安全）：在有限的资源内，攻击者都不能通过系统的分析方法来破解系统。 密码体制对称密码体制与非对称密码体制对称密码：加密密钥和解密密钥相同，或者一个密钥可以从另一个导出，能加密就能解密，加密能力和解密能力是结合在一起的，开放性差。非对称密码：加密密钥和解密密钥不相同，从一个密钥导出另一个密钥是计算上不可行的，加密能力和解密能力是分开的，开放性好。 序列密码体制和分组密码体制序列密码：密文不仅与最初给定的算法和密钥有关，同时也与明文位置有关(是所处位置的函数)。分组密码：经过加密所得到的密文仅与给定的密码算法和密钥有关，与被处理的明文数据在整个明文中的位置无关。 确定型密码体制和概率型密码体制确定型密码:当明文和密钥确定后，密文也就唯一地确定了。概率密码：当明文和密钥确定后，密文通过客观随机因素从一个密文集合中产生，密文形式不确定。 单向函数型密码体制和双向变换型密码体制单向函数型密码体制：适用于不需要解密的场合，容易将明文加密成密文，如哈希函数。双向变换型密码体制：可以进行可逆的加密、解密变换。 现代密码学的基本原则设计加密系统时，总是假定密码算法是可以公开的，需要保密的是密钥。一个密码系统的安全性不在算法的保密，而在于密钥，即Kerckhoff原则。 对加密系统的要求系统应该是实际安全的(practical secure)，截获密文或已知明文－密文对时，要决定密钥或任意明文在计算上是不可行的。加密解密算法适用于密钥空间中的所有元素。系统易于实现，使用方便。系统的安全性不依赖于对加密体制或加密算法的保密，而依赖于密钥。系统的使用不应使通信网络的效率过分降低。 对加密信息的攻击类型 攻击类型 攻击者持有的信息 唯密文攻击 加密算法、待解密密文 已知明文攻击 加密算法 、待解密密文、与待解密密文（同一密钥加密）的明密文对 选择明文攻击 加密算法 、待解密密文、攻击者选择的明文及对应的（同一密钥加密）密文 选择密文攻击 加密算法 、待解密密文、攻击者选择的（同一密钥加密）密文及对应的明文 选择文本攻击 加密算法 、待解密密文、攻击者选择的（同一密钥加密）密文及对应的明文、攻击者选择的明文及对应的（同一密钥加密）密文 代换与置换代换法是将明文字母替换成其他字母、数字或符号的加密方法。如果把明文看成是二进制序列的话，代换就是用密文位串来代换明文位串。代换法改变明文内容的表示形式，保持内容元素之间相对位置不变。由于语言的冗余性（即字母单词使用频率的统计特性），单表代换虽然密钥空间很大，但并不安全。置换法是改变明文内容元素的相对位置，保持内容的表现形式不变。通过重新安排消息字母的位置来隐藏明文信息，而不是用其他字母来代换明文字母。这种方法是很容易破译的，因为密文拥有与明文一样的字母频率统计特性。 隐写术隐写术不是加密技术。比如将信息通过改变像素内容隐藏到图片中，不可见的墨水等。 一次一密两个限制：产生大规模随机密钥有实际困难、密钥的分配和保护无法保证 第三章流密码与分组密码流密码：每次加密数据流的一位或一个字节。分组密码：将一个明文分组作为一个整体进行加密，并且一般得到等长的密文。 扩散和混淆扩散：明文统计特征消散在密文中。可以通过让多个明文数字影响一个密文数字，或者每个明文数字可以影响多个密文数字。混淆：使密文和加密密钥之间的统计关系尽量复杂。 Confusion means that each binary digit (bit) of the ciphertext should depend on several parts of the key, obscuring the connections between the two.Diffusion means that if we change a single bit of the plaintext, then (statistically) half of the bits in the ciphertext should change, and similarly, if we change one bit of the ciphertext, then approximately one half of the plaintext bits should change. Since a bit can have only two states, when they are all re-evaluated and changed from one seemingly random position to another, half of the bits will have changed state.In Shannon’s original definitions, confusion refers to making the relationship between the ciphertext and the symmetric key as complex and involved as possible; diffusion refers to dissipating the statistical structure of plaintext over the bulk of ciphertext. This complexity is generally implemented through a well-defined and repeatable series of substitutions and permutations. Substitution refers to the replacement of certain components (usually bits) with other components, following certain rules. Permutation refers to manipulation of the order of bits according to some algorithm. To be effective, any non-uniformity of plaintext bits needs to be redistributed across much larger structures in the ciphertext, making that non-uniformity much harder to detect. 第四章同余给定整数$a, b$及$n≠0$, 当且仅当$a-b=kn$时，$a$与$b$在模$n$时同余，记为$a≡b\ mod\ n$ 或 $a≡nb$。如果$n|(a-b)$, 则$a≡b\ mod\ n$。 模运算$(a1\ op\ a2)\ mod\ n =[(a1\ mod\ n )]\ op\ (a2\ mod\ n)]\ mod\ n$ 乘法逆元如果一个整数与$n$互素，那么它在$Z_n$中存在一个乘法逆元。对于任何一般的模数$n$，如果$a$与$n$互素，那么用乘数$a$作用到$Z_n$(即0,1,2,…,n-1)然后模$n$会得到完整的$Z_n$(元素顺序可能不同，也可以叫做$Z_n$的一个置换)。 Z8 0 1 2 3 4 5 6 7 乘以5 0 5 10 15 20 25 30 35 剩余类 0 5 2 7 4 1 6 3 欧几里得算法与拓展欧几里得算法欧几里得算法又称辗转相除法。欧几里德定理：$ gcd(a, b) = gcd(b , a\%b)$ 拓展欧几里得算法对于不完全为$0$的非负整数 $a，b，gcd（a，b$表示$a，b$的最大公约数，必然存在整数对$x，y$，使得$gcd（a，b）=ax+by$。 第五章双重DES因为对单重DES进行穷举攻击是可行的（密钥长度仅有56位）。双重DES存在着中间相遇攻击。$C = E_{K2}(E_{K1}(P))， P = D_{K1}(D_{K2}(C))$，因为$X = E_{K1}(P) = D_{K2}(C)$，用所有可能的密钥加密明文P并把结果存储起来，然后用所有可能的密钥解密密文C，寻找匹配的X值，因此复杂度只有O($2^{56}$)。攻击单重DES复杂度为O($2^{55}$)。 三重DES使用两个密钥的三重DES$C=E_{K1}[D_{K2}[E_{K1}[P]]$如果$K1=K2$，那么就变成了单重DES，从而实现对单重DES的兼容。 使用三个密钥的三重DES$C = E_{K3}[D_{K2}[E_{K1}[P]]]$如果$K1=K2$或者是$K2=K3$，那么就变成了单重DES，从而实现对单重DES的兼容。 分组密码的工作模式分组密码的安全不仅和秘钥长度有关还和分组长度有关。 电子密码本模式ECB明文分成64的分组进行加密，必要时填充，每个分组用同一密钥加密，相同明文分组加密得相同密文。ECB模式特别适合数据较少的情况，如安全传输DES密钥。一段明文消息中若有几个相同的明文组，则密文也将出现几个相同的片段。对于很长的消息，ECB是不安全的，如果消息是非常结构化的，密码分析可能利用其结构特征来破解。ECB的弱点来源于其加密过的密文分组是互相独立的。优点：操作简单，易于实现；分组独立，可以并行加密；传输错误不会传播。缺点：掩盖不了明文结构信息，可以进行统计分析攻击。 密文分组链接模式CBC加密输入是当前明文分组和前一密文分组的异或，形成一条链，使用相同的密钥， 这样每个明文分组的加密函数输入与明文分组之间不再有固定的关系。每个密文分组依赖于所有明文分组。发送方和接收方需要共享初始向量Initial Value(IV)。如果IV被明文传送，则攻击者可以预先改变IV中的某些位，则接收者收到的P1也就相应改变了。因此，IV必须是一个固定的值或者使用伪随机数、计数器IV用ECB方式在消息之前加密传送。在消息的最后，还要处理不够长度的分组进行填充。明文消息中的任何一点变化都会影响所有的密文分组。优点：能掩盖明文结构信息，保证相同密文可得不同明文，安全性好于ECB；适合传输长度较长的报文。缺点：不可并行；传递错误，即一个分组错误导致后续分组均错误；初始向量IV的选取比较复杂。 密文反馈模式CFB可以视为流密码，不再要求报文被填充成整个分组，可以实时运行，如果要传输一个字符流，每个字符都可以使用面向字符的流密码加密后立即传输。加密：加密函数的输入是一个64位的移位寄存器，产生初始向量IV。加密函数高端s位与明文P1的第一单元异或，产生s位密文C1进入移位寄存器低端，继续加密，与P2输入异或，如此重复直到所有明文单元都完成加密。解密：采用相同方案，但是使用加密函数而非解密函数。设$MSB_s(X)$表示X的最左边s位。则$C1=P1 \bigoplus MSB_s[E(K,IV)]$从而有$P1=C1 \bigoplus MSB_s[E(K,IV)]$如果在传输过程中某一个分组的密文发生改变，则会影响到这个分组及其后的分组的明文正确性。优点：可以实时运行，及时加密小于分组大小的数据；隐藏了明文结构。缺点：不可并行；传输错误会扩散。 输出反馈模式OFB结构上类似CFB，但是OFB中加密函数输出被反馈回移位寄存器，CFB中是密文单元被反馈回移位寄存器（对比两个图，可以看到反馈位置是不同的）。优点是传输中的比特差错不会传播，缺点是比CFB更容易受报文流篡改攻击。OFB的IV必须是时变值。OFB的一个优点是，传输过程中在某位上发生的错误不会影响到其他位。比如，C1中有1位发生了错误，只会影响到P1的恢复，后续的明文单元不受影响。OFB的缺点是，抗消息流篡改攻击的能力不如CFB。即密文中的某位取反，恢复出的明文相应位也取反。优点：可以实时运行，及时加密小于分组大小的数据；隐藏了明文结构；传输过程中在某位上发生的错误不会影响到其他位。缺点：不可以并行；比CFB更容易受报文流篡改攻击。 计数器模式CTR与OFB很像，但是加密的是计数器的值而不是任何反馈回来的值。每一个明文分组都必须使用一个不同的密钥和计数器值，决不要重复使用。高效、可以做并行加密对高速链路的突发数据加密尤其有效可以对被加密的分组进行随机存取安全、简洁不需要填充 第八章费马定理若$p$是素数, $a$是正整数且不能被$p$整除, 则$a^{p-1}\ mod\ p=1$证明：$对于X=\{ a\ mod\ p,2a\ mod\ p,…, (p-1)a\ mod\ p\}$$\because a是正整数且不能被p整除$$\therefore X内的元素均大于零$$假设ja≡ka(modp)，其中1\leqslant j&lt;k\leqslant p-1$$\because a与p互素$$\therefore 两边可以把a消去，则推出j ≡ k(mod p)，与假设矛盾$$也就是说，X内的元素均为正整数且互不相等$$\because \{ a\ mod\ p, 2a\ mod\ p, …, (p-1)a\ mod\ p\} 是\{ 1, 2, …, (p-1)\} 的置换形$$\therefore (aｘ2aｘ … ｘ (p-1)a)≡(1ｘ2ｘ … ｘ(p-1))\ (mod\ p)≡ (p-1)!\ (mod\ p)$$\because aｘ2aｘ…ｘ(p-1)a=(p-1)!a^{p-1}，即 (p-1)!a^{p-1}≡(p-1)!\ (mod\ p)$$两边去掉(p-1)!，即得 a^{p-1}\mod\ p = 1$ 欧拉函数$\varphi (n)$是比n小且与n互素的正整数的个数，定义$\varphi (1)=1$。 欧拉函数定理$p和q是素数, n=p\times q, \varphi (n)= \varphi (p)\varphi (q)=(p-1)(q-1)$证明：$考虑余数集合\{ 0, 1, …, (pq-1)\} 中不与n互素的余数集合是\{ p, 2p, …, (q-1)p\} , \{ q, 2q, …, (p-1)q\}, $$所以\varphi (n)= (pq-1)-[(q-1)+(p-1)]=pq-(p+q)+1= (p-1)(q-1)=\varphi (p)\varphi (q)$ 欧拉定理对任意互素的$a$与$n$，$a^{\varphi (n)} \equiv 1\ (mod\ n)$证明：$若n为素数，则根据\varphi (n)=n-1和a^{p-1}\ mod\ p=1可知成立。但这是不完全的证明。$$考虑集合R=${$x_1,x_2,…,x_{\varphi (n)}$},$每一个元素都有gcd(x_i,n)=1。$$令S=\{ (ax_1\ mod\ n),(ax_2\ mod\ n),…,(ax_{\varphi (n)}\ mod\ n)\}$$S是R的一个置换，因为$$(1) a与n互素，且x_i与n互素，所以ax_i必与n互素，这样S中所有元素均小于n且与n互素。$$(2) S中没有重复元素，因为如果ax_i\equiv ax_j(modn)，则x_i=x_j，显然不成立。$$\prod_{i=1}^{\varphi (n)}(ax_imodn)=\prod_{i=1}^{\varphi (n)}x_i$$\prod_{i=1}^{\varphi (n)}ax_i\equiv \prod_{i=1}^{\varphi (n)}x_i(modn)$$a^{\varphi (n)}\times [\prod_{i=1}^{\varphi (n)}x_i]\equiv \prod_{i=1}^{\varphi (n)}x_i(modn)$$两边同时消去，得到a^{\varphi (n)} \equiv 1(modn)$ 中国剩余定理中国余数定理CRT说明某一范围内的整数可通过它对两两互素的整数取模所得的余数来重构。例如：$Z_{10}(0,1,…,9)$中的10个整数可通过它们对2和5(10的素因子)取模所得的两个余数来重构. 假设数$x$的余数$r_2=0$ 且$r_5=3$, 即$x\ mod\ 2=0$, $x\ mod\ 5=3$, 则$x$是$Z_{10}$中的偶数且被5除余3, 唯一解$x=8$。 一种CRT的表示形式$令M=\prod_{i=1}^{k}m_i, 其中m_i两两互素, 1\leqslant i, j\leqslant k, i≠j, gcd(m_i, m_j)=1。将Z_M中的任一整数对应一个k元组,$$该k元组的元素均在Z_{m_i}中, 对应关系为A\leftrightarrow (a_1,a_2,…,a_k), 其中A∈Z_M, 对1\leqslant i\leqslant k, a_i∈Z_{m_i},$$且a_i = A\ mod\ m_i。$ 计算例子今有物不知其数, 三三数之剩二, 五五数之剩三, 七七数之剩二, 问物几何。(1) 计算$n=3\times 5\times 7$，记$d_1=3,d_2=5,d_3=7$; $r_1=2,r_2=3,r_3=2$(2) 根据$(\frac{n}{d_i})y_i\ mod\ d_i=1$，计算$y_i$$(\frac{105}{3})y_i\ mod\ 3=1 $，得$y_1=2$$(\frac{105}{5})y_i\ mod\ 5=1 $，得$y_2=1$$(\frac{105}{7})y_i\ mod\ 7=1 $，得$y_3=1$(3) $x=[\prod (\frac{n}{d_i})y_ir_i]\ mod\ n$$x=(35\times 2\times 2+21\times 1\times 3+15\times 1\times 2)\ mod\ 105=23$ 第九章对称密码与非对称密码对称密码体制的问题加密能力与解密能力是捆绑在一起的。密钥更换、传递和交换需要可靠信道，密钥分发困难。如有N用户，则需要$C=\frac {N\times (N-1)}{2}$个密钥，n=1000时，C(1000, 2)≈500000, 密钥管理困难。无法满足不相识的人之间通信的保密要求。不能实现数字签名。 非对称密码体制的基本特点加密能力与解密能力是分开的。密钥分发简单。需要保存的密钥量大大减少，N个用户只需要N个密钥。可满足不相识的人之间保密通信。可以实现数字签名。 公钥密码体制的应用加密/解密：发送方用接收方的公钥对消息加密。数字签名：发送方用其私钥对消息签名，可以对整体消息签名或对消息的摘要签名。密钥交换：通信双方交换会话密钥。 RSA算法流程随机选择两个秘密大素数$p$和$q$计算公开模数$n=p\times q$计算秘密的欧拉指数函数$\varphi (n)=(p-1)(q-1)$选择一个与$\varphi (n)$互素的数，作为$e$或$d$用Euclid算法计算模$\varphi (n)$的乘法逆元素，即根据$ed\ mod\ φ(n)=1$, 求$d$或$e$加密：$C=M^e\ mod\ n$解密：$M=C^d\ mod\ n = (M^e\ mod\ n)^d\ mod\ n=M^{ed}\ mod\ n=M$公钥：$PU=\{ e,n\}$ 私钥：$PR=\{ d,n\}$ 需要满足的条件有可能找到e, d, n的值, 使得对所有$M&lt;n$有$M^{ed}\ mod\ n = M$。对于所有$M&lt;n$的值, 要计算$M^e$和$C^d$是相对容易的。在给定e和n时, 计算d是不可行的。 证明已知：$ed\ mod\ \varphi (n)=1，M&lt;n，p和q是素数$求证：$M^{ed}\ mod\ n=M$ 可能的攻击方式穷举攻击：尝试所有可能的密钥数学攻击：对两个素数乘积的因子分解(FAC问题)计时攻击：依赖于解密算法的运行时间RSA的安全性问题依赖于大合数的素因子分解。 第十章几种公钥分配方法公开发布、公开可访问的目录、公钥授权、公钥证书 公开发布 公开可访问的目录一个可信实体或组织负责这个公开目录的维护和分配。 目录包含{name, public-key}等项。 每一通信方通过目录管理员以安全的方式注册一个公钥。 通信方在任何时刻可以用新的密钥替代当前的密钥。 目录定期更新。目录可通过电子方式访问。安全问题：一旦攻击者获得目录管理员私钥，则可传递伪造的公钥，可以假冒任何通信方以窃取消息，或者修改已有的记录。 公钥授权(1) A发送带有时间戳的消息给公钥管理员, 请求B的当前公钥。(2) 管理员给A发送用其私钥$KR_{auth}$加密的消息, A用管理员的公钥解密，可以确信该消息来自管理员。 B的公钥$KU_b$，用来加密；原始请求$Request$，A可以验证其请求未被修改；原始时间戳$Time_1$, A可以确定收到的不是来自管理员的旧消息。 (3) A保存B的公钥, 并用它对包含A的标识$ID_A$和$N_1$的消息加密, 然后发送给B。(45) B以同样方式从管理员处得到A的公钥。(6) B用$KUa$对A的$N_1$和B的$N_2$加密, 发送给A。(7) A用B的公钥对$N_2$加密并发送给B, 使B相信其通信伙伴是A。 公钥证书有了公钥证书使得不通过实时访问公钥授权部门而实现公钥交换成为可能。公钥证书将一个通信方的身份与他的公开密钥绑定在一起，通常还包括有效期和使用方法等。证书的所有内容必须经由可信公钥授权方或者证书授权方签名后方可生效。知道公钥授权当局公开密钥的任何人都可以验证一个用户的公开密钥证书的有效性。 对于申请者A，管理员提供的证书为：$C_A = E_{KR_{auth}} [Time_1, ID_A, KU_a]$其他人读取并验证：$D_{KU_{auth}}[C_A]=D_{KU_{auth}} [E_{KR_{auth}} [Time_1, ID_A, KU_a]]=(Time_1, ID_A, KU_a)$ 公钥密码分配传统密码体制密码公钥密码算法速度较慢，因此更适合作为传统密码中实现秘密密钥分配的一种手段。下图是一个利用公钥密码体制分配（传输）对称式密码（会话密钥$K_s$）的例子：(1) A用$KU_b$加密消息$N_1$和$ID_A$发送给B。(2) 只有B拥有B的私钥，即$N_1$只有B可见，B产生随机值$N_2$，和$N_1$一起加密后发送给A，A看到$N_1$后即可确定消息是B发来的。(3) 同理，$N_2$只有A可见，B可以确定消息是A发来的。(4) A产生本次会话的密钥，先用自己的私钥加密再用B的公钥加密发送给B。上述过程中存在的安全问题：消息(4)可以进行重放攻击。在下次会话时上次的会话密钥可能已经泄露，攻击者可以重放上次的消息(4)进行攻击。解决方案是将消息(3)和消息(4)合并发送，即(3)$E_{KU_b}[N_2 || E_{KR_a}[K_s]]$。 Diffie-Hellman密钥交换Diffie-Hellman密钥交换算法是一种公钥分发机制。它不是用来加密消息的，所生成的是通信双方共享的会话密钥，必须保密，其值取决于通信双方的私钥和公钥信息。 流程通信双方约定一个大素数(或多项式)p, 和模p的一个素根α（p与α是公开的）双方分别选择一个秘密钥(整数值)，如$x_A&lt; p， x_B&lt; p$计算公钥, 如$y_A = α^{x_A}\ mod\ p, y_B = α^{x_B}\ mod\ p$, 并相互交换双方共享的会话密钥$K_{AB}$可以如下算出$K_{AB} = α^{x_Ax_B}\ mod\ p= y_A^{x_B}\ mod\ p (which\ B\ can\ compute) = y_B^{x_A}\ mod\ p (which\ A\ can\ compute) $$K_{AB}$是双方用对称密码通信时共享的密钥如果双方继续通信，可以继续使用这个密钥，除非他们要选择新的密钥 安全性攻击者如果想要获得x, 则必须解决DLP(离散对数)问题。$X_B=dlog_{α,p}Y_B$，即求$Y_B$的以$α$为底的模$p$的离散对数。 中间人攻击 ELGamal概率密码系统流程假设A和B互相通信，共享大素数$p$，本原元素$α，1≤m≤p-1$加密：A选择$k∈[1, p-1]$, $k$的作用其实即为$x_A$, A访问公共区域找到B的公开密钥$Y_B = α^{x_B}\ mod\ p$, 计算：$K = (Y_B)^k\ mod\ p, 即K = α^{x_Bk}\ mod\ p$$c1 = α^k\ mod\ p$$c2 = mK\ mod\ p$密文即为 $(c1, c2)$解密：B首先恢复K：K $= c1^{x_B}\ mod\ p = α^{kx_B}\ mod\ p$然后恢复m：m $=c2K^{-1}\ mod\ p$。这里的$K^{-1}$指$KK^{-1}\ mod\ p=1$ 效率及安全性ElGamal密码体制加密效率是50%，因为密文大小是明文的两倍。ElGamal密码体制是概率密码体制，同样的明文每次加密得到不同的密文, 因为每次随机选择k。ElGamal密码体制的破译难度同Diffie-Hellman的方法,即基于DLP，离散对数问题，最快的算法需要T=exp((ln(p)lnln(p)1/2)次运算。 第十一章消息认证消息认证就是验证接受的消息确实来自真正的发送方，且是未经修改过的消息，并且可以认证消息的顺序和及时性。 消息认证函数消息加密消息加密本身提供了一种认证手段。对称加密 保密性：如果除了源和宿没有其他人知道密码，那么就保证了保密性。 认证：宿可以确信消息是由源产生的，因为除了宿以外只有源拥有加密密钥，产生出用此密钥可以解密的密文。因此宿如果可以恢复出明文，则可以认为每一位都没有被修改过，建立在明文具有可读性的基础上。 如果消息可以是任意的位模式，接收方无法确定收到的消息是合法明文的密文（不具有可读性）。因此要求明文具有某种易于识别的结构，如在加密前对每个消息附加一个帧校验序列FCS。FCS和加密函数E执行的顺序很重要。图中(a)为内部错误控制，攻击者很难产生密文使得控制码仍为正确，所以可以提供认证。图中(b)为外部错误控制，攻击者可以构造出具有正确控制码的消息，虽然不知道解密后的消息是什么，但是可以混淆破坏通信。公钥加密(b) 保密性：只有接受方具有私钥可以解密消息，因此具有保密性；但公钥是公开的，任何人都可以假冒发送方给接收方发送消息，不能保证消息的真实性，因此没有认证。(c) 认证和签名：接收方接收到密文并可以解密出明文（如果明文是具有某种结构的，即具有可读性以区分真实的明文和随机串）就可以确定发送方是真实的。只有发送方有自己的私钥，加密后就相当于是一个签名。(d) 保密性、认证和签名：发送方先用自己的私钥加密以作为签名，再用接收方的公钥加密实现保密性，同时明文具有某种结构的情况下实现了认证。缺点是一次通信执行四次公钥算法（两次加密两次解密）。 消息认证码MAC利用密钥产生一个固定长度的短数据块。假如通信双方共享密钥K，则MAC=C(K,M)。如果接收方通过密钥和消息计算的MAC与收到的一致，那么可以确信(1)消息未被修改过(2)消息来自真正的发送方(3)如果消息中含有序列号，那么可以确定消息顺序是正确的。因为MAC是定长的，而消息数远大于MAC的取值范围，因此MAC是一个多对一的函数。因为K是通信双方所共有的，所以MAC不是数字签名。同时MAC不需要解密，因此不需要具有可逆性，使得MAC比加密更加难以破解。(a) 消息认证：整个消息以明文发送，没有保密性，但有消息认证。(b) 与明文捆绑的消息认证和保密性：对明文做MAC然后与明文一起加密。(c) 与密文捆绑的消息认证和保密性：对明文加密，然后对密文做MAC，与密文一起发送。MAC函数应具有满足以下需求： 若攻击者已知$M$和$C(K,M)$，则构造满足$C(K,M’)=C(K,M)$的消息$M’$在计算上是不可行的 $C(K,M)$应该是均匀分布的，即对任何随机选择的消息$M$和$M’$，$C(K,M’)=C(K,M)$的概率是$2^{-n}$，其中n是MAC的位数 设M’是M的某个已知的变换，即M’=f(M)，如f可能表示逆转M的一位或多位，那么$C(K,M)=C(K,M’)$的概率是$2^{-n}$ 散列函数HASH一个散列函数以变长的报文M作为输入，产生定长的散列码H(M)作为输出，亦称作报文摘要。 散列码是报文所有比特的函数值，具有差错检测能力，报文任意一比特的改变都将引起散列码的改变。Hash函数的安全性需求 需求 描述 输入长度可变 H可以应用于任意大小的数据块 输出长度固定 H产生固定长度的输出 效率 对任意给定的明文x，计算H(x)容易，可由硬件或软件实现 抗原像攻击（单向性） 对任意给定的散列码h，找到满足H(x)=h的x，在计算上不可行 抗第二原像攻击（抗弱碰撞性） 对任何给定的分组x，找到满足y≠x且H(x)=H(y)的y，在计算上不可行 抗强碰撞性 找到任何满足H(x)=H(y)的偶对(x, y)，在计算上不可行 伪随机性 H的输出满足伪随机性测试标准 满足前五条的称为弱哈希函数，如果第六条也满足则称为强哈希函数。应用在数字签名上的Hash函数必须是强哈希函数。三个安全特性之间的关系抗强碰撞那么一定抗弱碰撞，反之不成立。抗强碰撞不一定抗原像，反之亦然。抗弱碰撞不一定抗原像，反之亦然。抗强碰撞可以看作是在人群中寻找两个名字相同的人，抗弱碰撞性可以看作是给定一个名字，然后在人群中找一个和这个名字相同的人。 Hash函数提供的消息认证方式(a) 使用对称密码加密消息和Hash码。对称式密钥保证了保密性，并且可以确定发送方的真实性；Hash码提供了消息认证的功能。(b) 使用对称式密码仅加密Hash码。对于无需保密性的应用，减少了加解密的负担。实现了消息认证。(c) 不使用加密算法，双方共享秘密值s，并且s不在信道上传输，仅实现了消息认证。(d) 在(c)的基础上提供保密性。 Hash函数提供的数字签名方式(a) 使用发送方的私钥，仅对Hash码进行加密。实现了消息认证和数字签名。(b) 在(a)的基础上使用对称式密码加密，同时实现保密性。 第十三章数字签名概述数字签名实现方法数字签名是一种认证机制，它使得消息的产生者可以添加一个起签名作用的码字。通过计算消息的散列值并用产生者的私钥加密散列值来生成签名。签名保证了消息的来源和完整性。数字签名标准(DSS)是NIST标准，它使用安全散列算法(SHA)。 数字签名的要求在收发双方不能完全信任的情况下，需要除认证之外的其他方法来解决假冒和否认的问题，数字签名则是解决办法；签名接收者能容易地验证签字者对消息所做的数字签名，包括日期和时间；任何人，包括签名接收者，都不能伪造签名者的签字；发生争议时，可由第三方解决。 数字签名与消息认证的区别消息认证使收方能验证消息发送者及所发消息内容是否被窜改过。当收发者之间没有利害冲突时，这对于防止第三者的破坏来说是足够了。但当收者和发者之间有利害冲突时，就无法解决他们之间的纠纷，此时须借助满足前述要求的数字签名技术。 直接数字签名用共享的密钥（对称密钥）对明文及签名一起加密。注意先进行签名，然后执行外层的加密，这样在发生争执时，第三方可以查看消息及其签名。若先加密再签名，则第三方必须知道解密密钥才能查看消息。先签名再加密，接收方可以保留消息及其签名留作争执时使用。直接数字签名的有效性依赖于发送方私钥的安全性。发送方如果想要否认一条消息，他可以声称自己的私钥丢失或被盗用。可以使用加入时间戳的方式减少这种威胁。另一种威胁是，攻击者在T时刻盗用了发送方的私钥，并发送了一条签名的消息加盖T时刻之前的时间戳。解决上述问题的方法是使用数字证书的证书管理中心。 ELGamal数字签名方案首先，基本元素是素数p和原根αA用户生成随机整数$X_A\in (1,p-1)$，计算$Y_A=α^{X_A}\ mod\ p$计算消息的Hash码，m=H(M)产生签名选择整数$K\in [1,p-1]$，并且K与p-1互素计算$S_1 = \alpha ^K\ mod\ p$计算K模p-1的逆，即$K^{-1}\ mod\ (p-1)$计算$S_2=K^{-1}(m-X_AS_1)\ mod\ (p-1)$签名即为$(S_1,S_2)$验证签名计算$V_1=\alpha ^m\ mod\ p$计算$V_2=(Y_A)^{S_1}(S_1)^{S_2}\ mod\ p$如果$V_1=V_2$，那么签名合法。]]></content>
      <tags>
        <tag>网络信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【python learning】词法结构]]></title>
    <url>%2F2018%2F%E3%80%90python%20learning%E3%80%91%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[字符集通常，python的源代码必须完全由ASCII码组成。若想在程序中的注释和字符串常量中使用非ASCII字符，需在源代码的第一行添加注释# -*- coding: &lt;encoding-name&gt; -*- 标识符通常python的风格是类名称以大写字母开始，其他的标识符都是小写字母。以单个下划线开始的标识符是私有的，以两个下划线开始的标识符是非常强的私有标识符；如果标识符还以两个下划线结尾，则表示该标志符是python语言定义的特殊名称。 关键字(3.7.1版本)False await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if or yield 逻辑行与物理行逻辑行由一个或多个物理行组成。 当某一物理行以backslash(\)结束，并且后面没有注释，就会连接到下一个物理行作为一个逻辑行。 1234if 1900 &lt; year &lt; 2100 and 1 &lt;= month &lt;= 12 \ and 1 &lt;= day &lt;= 31 and 0 &lt;= hour &lt; 24 \ and 0 &lt;= minute &lt; 60 and 0 &lt;= second &lt; 60: # Looks like a valid date print("It's a valid date.") 如果一个左边的圆括号、方括号、花括号还没有对应的右括号，则python会自动把多个物理行连接成一个逻辑行。 1234month_names = ['January', 'February', 'March', # These are the 'April', 'May', 'June', # Dutch names 'July', 'August', 'September', # for the months 'October', 'November', 'December'] # of the year]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[僕が死のうと思ったのは]]></title>
    <url>%2F2018%2F%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"http://pg60us30v.bkt.clouddn.com//vedio/%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.mp4","pic":"http://pg60us30v.bkt.clouddn.com//image/image-video/%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <tags>
        <tag>music</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java学习笔记】全系列内容提要篇]]></title>
    <url>%2F2018%2F%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%85%A8%E7%B3%BB%E5%88%97%E5%86%85%E5%AE%B9%E6%8F%90%E8%A6%81%E7%AF%87%2F</url>
    <content type="text"><![CDATA[【java学习笔记1】基本数据类型对象和类数据声明函数声明参数传递 【java学习笔记2】数组运算符包访问权限修饰符 【java学习笔记3】继承多态 【java学习笔记4】异常处理 【java学习笔记5】抽象类、抽象函数接口 【java学习笔记6】Object类Class类String类System类包装类 【java学习笔记7】泛型 【java学习笔记8】集合类，集合接口Collection类List LinkedList ArrayListMap HashMap TreeMapSet HashSet TreeSet 【java学习笔记9】FileRandomAccessFile文本流Preoperties // 配置文件的使用多线程 【java学习笔记10】线程同步、锁 【java学习笔记11】网络编程 【java学习笔记12】数据库编程 我比较懒，另一方面由于还在上学，时间比较少，慢慢更新~]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双系统安装Ubuntu18.04]]></title>
    <url>%2F2018%2F%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[制作启动盘以Ubuntu18.04为例 方式一工具为软碟通UltraISO。 准备一个U盘，格式化。 以管理员身份运行软碟通，菜单栏里选择“启动-&gt;写入硬盘映像”，写入方式选择“usb-HDD+”，“便捷启动-&gt;写入新的驱动程序引导扇区-&gt;Syslinux”。 方式二工具为rufus。 这是一个Ubuntu官方推荐的工具，用起来还是很方便的。唯一需要注意的就是选择Partition schema为MBR还是GPT。 查看硬盘分区表类型可以使用windows下的磁盘管理。点击要查看的硬盘，右键，“属性-&gt;卷”就能看到了。还有很多其他的工具可用，不一一赘述了。 安装系统 首先，重启电脑进入BIOS，关闭安全启动(如果之前装过双系统的话应该关掉了)，设置第一启动项为U盘启动，设置完成后保存退出。 这时候电脑应该会自动重启，重启之后应该就是Ubuntu的安装引导了，选择Install Ubuntu。 选择语言和键盘布局。 在联网这一项上，选择暂不连接网络，这样可以加快安装的进度，一些东西可以安好系统后自己选择安装。 选择最小安装，其他的不用选。 如果要装双系统，选择与Windows共存就好了，Ubuntu可以自己选择你未分配的空间作为安装空间(前提是你有未分配的空间)。网上的一些教程都交了如何自己分区，非老手且没有什么特殊需求建议不要尝试了，没什么用。如果只保留Ubuntu，选择只保留Ubuntu就好了。 接下来就是一些时区，用户名的设置了。 设置完后，安装就开始了，大约需要30分钟左右吧(当然这要视电脑情况而定😝)。 系统升级如果之前你是16.04或者17.10等其他的版本，也可以升级到18.04版本。(注意提前做好备份，万一装崩了呢🙊) 首先，更新升级已安装的软件包。 1234sudo apt upgradesudo apt updatesudo apt dist-upgradesudo apt autoremove 在软件更新器里选择更新版本为长期支持版本。 安装update-manager-core sudo apt-get install update-manager-core 执行sudo do-release-upgrade -d等待完成就ok了，我大概用了100分钟的时间。 安装Gnome插件Ubuntu18.04回归了gnome桌面，意味着我们可以使用很多有用的插件来使它更加的高效和炫酷。如何安装gnome插件呢？网上说了很多方法，在官网下载后解压到对应路径下的最多，但是这样就很麻烦。之后我发现在Ubuntu的软件中心有一个附加组件项，点进去，卧槽，这不就是现成的嘛…推荐几个插件吧：Simple net speed 顶栏实时网速显示Openweather 顶栏显示天气EasyScreenCast 录屏Coverflow alt-tab 效果超赞的 alt-tab 切换效果……更多有趣的插件自己探索吧~]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[词法分析器]]></title>
    <url>%2F2018%2F%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[词法分析 In computer science, lexical analysis, lexing or tokenization is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of tokens (strings with an assigned and thus identified meaning).在计算机科学中，词法分析，lexing或标记化是将一系列字符（例如在计算机程序或网页中）转换成一系列标记（具有指定且因此标识的含义的字符串）的过程。 编码目标给定一个源代码文件，能够将其转化为词法记号流。比如规定int的词法记号为30，输出就是(30, int)；数字的词法记号为11，则输入123，输出为(11, 123)。 约定把程序中的词法单元分为四类：标识符（分为关键字和一般标识符）、数字、特殊字符、空白（空格、Tab、回车换行等） 程序流程图对于运算符等符号，这里只考虑两个字符的组合情况，不考虑三个字符组成的运算符。之所以要在读到特殊字符之后在往后读一个字符是因为有可能在表中存在类似&gt;=和&gt;的运算符，要保证最长字符匹配。 关键代码首字符类型判断1234567891011121314151617181920212223public static String getCharType(String str) &#123; String regex_Letter = "[a-zA-Z]"; String regex_Number = "[0-9]"; String regex_Blank = "\\s"; Pattern pattern; pattern = Pattern.compile(regex_Letter); Matcher matcher = pattern.matcher(str); if (matcher.find()) return "LETTER"; pattern = Pattern.compile(regex_Number); matcher = pattern.matcher(str); if (matcher.find()) return "NUMBER"; pattern = Pattern.compile(regex_Blank); matcher = pattern.matcher(str); if (matcher.find()) return "BLANK"; return "SPECIAL"; &#125; 如果首字符为字母123456789101112131415case "LETTER": pattern = Pattern.compile(regex_ID); matcher = pattern.matcher(srcCode); if (matcher.lookingAt()) &#123; String result = matcher.group(); if (LexicalToken.isKeyWord(result)) &#123; int token = lextok.getToken(result); System.out.printf("&lt;%d,%s&gt; ", token, result); &#125; else &#123; int token = lextok.getToken("ID"); System.out.printf("&lt;%d,%s&gt; ", token, result); &#125; &#125; srcCode = srcCode.substring(matcher.end()); break; 如果首字符是数字12345678910case "NUMBER": pattern = Pattern.compile(regex_NUM); matcher = pattern.matcher(srcCode); if (matcher.lookingAt()) &#123; String result = matcher.group(); int token = lextok.getToken("NUM"); System.out.printf("&lt;%d,%s&gt; ", token, result); &#125; srcCode = srcCode.substring(matcher.end()); break; 如果首字符是空格123case "BLANK": srcCode = srcCode.substring(1); break; 如果首字符是特殊符号1234567891011121314151617181920212223case "SPECIAL": if (srcCode.length() &gt; 1) &#123; String secondChar = srcCode.substring(1, 2); String result; LinkedHashMap tokenMap = lextok.getLexicalTokenMap(); Set set = tokenMap.keySet(); result = firstChar + secondChar; if (getCharType(secondChar).equals("SPECIAL") &amp;&amp; set.contains(result)) &#123; int token = lextok.getToken(result); System.out.printf("&lt;%d,%s&gt; ", token, result); srcCode = srcCode.substring(2); &#125;else &#123; result = firstChar; int token = lextok.getToken(result); System.out.printf("&lt;%d,%s&gt; ", token, result); srcCode = srcCode.substring(1); &#125; &#125; else &#123; // 字符串中只有一个字符时 int token = lextok.getToken(srcCode); System.out.printf("&lt;%d,%s&gt; ", token, srcCode); srcCode = srcCode.substring(1); &#125; break; 源码地址：https://github.com/Liyzy/Lexer开发环境：IJ idea 2018.2]]></content>
      <tags>
        <tag>编译原理</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双系统卸载]]></title>
    <url>%2F2018%2F%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%8D%B8%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[本文主要针对windows+Linux双系统卸载Linux/Unix系统(Ubuntu\Deepin...)。 删除系统在windows上，右键开始打开磁盘管理(或者直接搜索“磁盘管理”)，看到装有Linux系统的硬盘分区，右键删除卷，删除后分区变为“未分配”。如果不安装新的系统，可以“新建简单卷”；如果还要安装别的系统，就暂不处理。 如果之前Linux/Unix系统是第一启动项，那么这时候你重启计算机的话是会出现错误的，因为引导找不到这个系统了。而且，在BIOS的启动项里还存在着这个系统。这时我们就要修复引导。 修复引导我们用到一个工具：EasyUEFI 下个试用版就OK。运行EasyUEFI，选择“管理EFI启动项”，可以看到你要卸载的系统的启动项，选中，选择“删除选中项”。之后在进入BIOS查看启动项，发现只剩下一个windows的启动项了，成功！]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【python学习笔记1】数据类型篇]]></title>
    <url>%2F2018%2F%E3%80%90python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%91%2F</url>
    <content type="text"><![CDATA[python简单介绍 作为一种解释型语言，Python的设计哲学强调代码的可读性和简洁的语法（尤其是使用空格缩进划分代码块，而非使用大括号或者关键词）。与Scheme、Ruby、Perl、Tcl等动态类型编程语言一样，Python拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。其本身拥有一个巨大而广泛的标准库。Python是完全物件导向的语言。函数、模组、数字、字串都是物件。并且完全支持继承、重载、派生、多重继承，有益于增强原始码的复用性。Python支持重载运算符，因此Python也支持泛型设计。Python编译器本身也可以被集成到其它需要脚本语言的程式内。因此，有很多人把Python作为一种“胶水语言”使用。使用Python将其他语言编写的程式进行集成和封装。Python属于动态类型语言，动态类型语言是在运行期间检查数据的类型，不得不保持描述变量值的实际类型标记，程序在每次操作变量时，需要执行数据依赖分支，而静态类型语言相对于动态类型语言，在声明变量时已经指定了数据类型和表示方法，根据这一原理导致Python相对于C、Visual Basic等静态类型语言来说运行速度较慢。 摘录自Wikipedia python数据类型常量python中没有关键字表示常量，用大写来代表这是一个常量。例如NUM=5，NUM就是一个常量。因此，在编写python代码时，要严格区分大小写。 变量python中变量声明不需要声明变量类型。但是，python是一种强类型语言，不能因此而判断python是弱类型的。python是动态的、强类型的语言。Why is Python a dynamic language and also a strongly typed language？ 数据类型分为两大类：内置数据类型、自定义数据类型内置数据类型分为：数值、序列、集合、字典、特殊、其他数值数据类型：整数、浮点数、布尔、复数序列数据类型：字符串、元组、字节序列、列表、字节数组集合数据类型：集、不可变集 内置的type()函数可以用来查询变量所指的对象类型123&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))&lt;type 'int'&gt; &lt;type 'float'&gt; &lt;type 'bool'&gt; &lt;type 'complex'&gt; int类型12345myInt = 5 myInt = int(5) #int对象方式int(5.4) #自动类型转换int("123") #自动类型转换#二进制以0b开头，八进制以0开头，十六进制以0x开头 float类型12myFloat = float(3.14)myFloat = float(4) #自动类型转换，输出结果4.0 复数数据类型 虚部必须用j1234561+1j #不可写成1+j0+0j #0不能省略complex(1,2) #其中1为实部，2为虚部c1=complex(6) #输出c1为6+0j,等同于complex(6,0) complex(6,)c2=complex(2.1,3.2) #实部与虚部可以为浮点数#real:复数的实部 imag:复数的虚部 c2.real输出结果2.1,c2.imag输出结果3.2 bool类型12345"""True False开头首字母必须大写bool对象 bool(False)bool(0),bool(0.0) 结果为False,任何非零均为True例如 bool('0'),bool(5),bool(2.3),bool("abc")""" String类型表现形式&quot;abc&quot; &#39;abc&#39; &#39;&#39;&#39;abc&#39;&#39;&#39; &quot;&quot;&quot;abc&quot;&quot;&quot; 前两个表示一行，后两个表示可以跨行 字符串拼接与重复123456&gt;&gt;&gt; "abc"+'def' #使用+进行字符串连接'abcdef'&gt;&gt;&gt; "abc" 'def' #默认自动连接'abcdef'&gt;&gt;&gt; "abc"*2 # *表示重复，*后的整数表示重复次数'abcabc' 转义字符 转义字符 含义 \n 换行 \r 回车 \t 水平制表符 \v 垂直制表符 \b 退格 \f 换页 使用r或R为开头的字符串成为原始字符串，其中包含的任何字符都不可进行转义。123&gt;&gt;&gt; myStr = r"abc\n"&gt;&gt;&gt; print(myStr)'abc\n' str对象str()str(.14) 输出结果为 ‘0.14’ ，浮点数前导0可省略,隐式类型转换。 字符串索引Python中的字符串有两种索引方式，第一种是从左往右，从0开始依次增加；第二种是从右往左，从-1开始依次减少。注意，没有单独的字符类型，一个字符就是长度为1的字符串。12345&gt;&gt;&gt; word = 'Python'&gt;&gt;&gt; print(word[0], word[5])P n&gt;&gt;&gt; print(word[-1], word[-6])n P 字符串截取子串用冒号分隔两个索引，形式为变量[头下标:尾下标]。截取的范围是前闭后开的，并且两个索引都可以省略：123456789&gt;&gt;&gt; word = 'ilovepython'&gt;&gt;&gt; word[1:5]'love'&gt;&gt;&gt; word[:]'ilovepython'&gt;&gt;&gt; word[5:]'python'&gt;&gt;&gt; word[-10:-6]'love' Python字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。 列表列表的创建方式字面量[x1,x2,x3,x4,…,xn]列表中元素类型可以不同，如[1, 2, 3, ‘q’, True]列表中的元素可以是表达式，如123x = 1temp = [x + x, x * x, 11]list = [[1,2,3,4],[5,6,7],8] 对象123list1 = list() #空列表list2 = list("abcd") #结果['a', 'b', 'c', 'd']list3 = list(range(3)) #结果[0, 1, 2] 推导式使用非常简单的表达式满足特定的列表表达式 for 变量 in 序列123list4 = [x*x for x in range(1,10)]print(list4) #结果[1, 4, 9, 16, 25, 36, 49, 64, 81]list5 = [i for i in list4 if i%2==0] #结果[4, 16, 36, 64] 列表的操作列表的操作包括：索引、切片、连接、重复、成员关系、比较、求长度、最大值、最小值等 索引访问123list6 = [1, 2, 3]print(list6[0], list6[-1]) #结果１ ３list6[0] = 10 #list中的值可以改变，此时list6为[10, 2, 3] 删除列表中的元素12list7 = [1,2,3,4,5] #[1,2,3,4,5]del list7[1] #[1,3,4,5] 求长度、最大值、最小值、和1234567891011121314151617181920list８ = [1,2,3,4,5,6] #[1,2,3,4,5,6]len(list8) #6min(list8) #1max(list8) #6sum(list8) #21list9 = [1,2,3,4,'a',5]len(list9) #6max(list9) #TypeError: unorderable types: str() &gt; int(), min和sum同样错误。list10 = ['a', 'b', 'c'] #可以算len,max,min，但不能求和# python 2.7.15中测试结果如下&gt;&gt;&gt; list1 = [1,2,3,4,5,'a', 6]&gt;&gt;&gt; max(list1)'a'&gt;&gt;&gt; min(list1)1&gt;&gt;&gt; sum(list1)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: unsupported operand type(s) for +: 'int' and 'str' 切片s[i:j] 从索引i开始，到j结束，左闭右开。省略i从0开始，省略j到结尾结束s[i:j:k] k表示步长1234list1 = [1, 2, 3, 4, 5, 6, 7]temp = list1[1:6:2]print(temp) # 结果[2, 4, 6]list1[:1] = [] # list1变为[2,3,4,5,6,7] 连接与重复连接+ 重复*12345list2 = [1,2,3]list3 = [3,4,5]print(list2+list3) # 结果[1, 2, 3, 3, 4, 5],只连接不去重print(2*list2) # 结果[1, 2, 3, 1, 2, 3]list2 += list3 # 结果[1, 2, 3, 3, 4, 5],等价于list2 = list2 + list3 成员关系操作判断一个元素是否在列表中in 和not in12345list1 = [1, 4, 3, 3, 2, 2, 3]print(7 in list1) # Falseprint(3 in list1) # Trueprint(list1.count(3)) # 3 计算某一个元素在列表中出现的次数print(list1.index(3, 2, 6)) # 2 查找某个元素在给定范围内第一次出现的索引,例子中范围为[2,6) 比较运算12345678list1 = ['a', 'b']list2 = ['a', 'b']list3 = ['a', 'b', 'c']list4 = ['c', 'b', 'a']print(list1 == list2) # Trueprint(list3 &gt; list2) # Trueprint(list3 &gt; list4) # False# 从第一个元素开始比较 列表的排序sorted(list1)) any()和all()any() 列表中是否有元素为Trueall() 列表中的元素是否都为True 列表的拆分1234list1 = [1,2,3,4]a,b,c,d = list1print(a,b,c,d) # 结果１ ２ ３ ４# 应保证前面的变量数与列表的长度相同 元组定义与声明定值表，用来存储不变值表123456789t = 1,2,3,4 # 表示元组t = (1,2,3,4) # 表示元组t = () # 表示空元组t = 1, # 表示只有一个元素的元组，必须有逗号t = tuple(1,2,3,4) # 错误写法，只能有一个参数t = tuple([1,2,3,4])# 正确写法t = tuple("abcd") # 结果为（'a','b','c','d'）t = tuple(range(8)) t = tuple(2*x for x in range(1,5)) # 结果为(2,4,6,8) 元组的操作索引访问、切片、连接、重复、成员关系、最大值、最小值、和、长度、排序等与列表的操作类似，可以进行对比。一些内容不作赘述。 元组的排序123456789tuple1 = tuple([2,1,9,5,4,6])print(tuple1)print(sorted(tuple1))print(tuple1)# 结果为(2, 1, 9, 5, 4, 6)[1, 2, 4, 5, 6, 9] # 输出的是列表(2, 1, 9, 5, 4, 6) # 原元组没有变化 元组的拆分123456789a, *s, d, f = tuple1 print(a, d, f) # 结果为 2 4 6a, s, d, *f = tuple1print(a, s, d) # 结果为 2 1 9# 元组的拆分前面变量的个数必须与元组元素个数相等。如果元组元素个数过多，可以使用*代表多个变量_, a, b, _, *_ = tuple1print(a, b, _) # 结果为 1 9 [4, 6]# 没有意义的命名可以使用临时变量下划线(_)表示。输出临时变量，只会保留最后一个。 字典字面量{键:值,键:值,键:值,键:值,} 字典对象dict()12345print(dict([['优',90],['良',80]]))print(dict((('优',90),('良',80))))print(dict(zip(['优','良'],[90,80])))# 结果均为 &#123;'优': 90, '良': 80&#125;dict1 = dict(a="apple", b="banane") # &#123;'a':'apple', 'b':'banane'&#125; fromkeys()123dict2 = &#123;&#125;.fromkeys(['优','良'],"大于70分") # &#123;'优': '大于70分', '良': '大于70分'&#125;dict3 = &#123;&#125;.fromkeys(['优','良']) # &#123;'优': None, '良': None&#125;dict4 = &#123;&#125;.fromkeys(['优','良'],None) # &#123;'优': None, '良': None&#125; 推导式1dict5 = &#123;n:n**2 for n in range(1,5)&#125; # &#123;1:1,2:4,3:9,4:16&#125; 得到键对应的值12345678dict2['优'] # 大于70分dict2.get('优') # 大于70分dict2.get('秀') # 没有反应，也没有报错dict2.get('秀','自定义错误提示') # 如果有“秀”对应的值，则输出对应的值；否则输出后面的提示信息dict2.get('优', '自定义错误提示') # 大于70分dict2.items() # 获取所有的键值对dict2.keys() # 返回所有的键值dict2.values() #返回所有的值 添加键值对12dict1['c'] = cat # &#123;'a':'apple', 'b':'banane', 'c':'cat'&#125; 没有则添加dict1['a'] = allen # &#123;'a':'allen', 'b':'banane'&#125; 有则修改 合并12345dict6 = &#123;'No1':'java','No2':'python'&#125;dict7 = &#123;'No3':'C++'&#125;dict8 = &#123;'No2','C'&#125;dict6.update(dict7) # dict6为&#123;'No1': 'java', 'No2': 'python', 'No3': 'C++'&#125;dict6.update(dict8) # dict6为&#123;'No1':'java','No2':'C'， 'No3': 'C++'&#125; 删除123456789del(dict6['No2'])print(dict6) # &#123;'No1': 'java'， 'No3': 'C++'&#125;del dict6print(dict6) # 报错，未定义dict1dict6.pop('No2','自定义错误提示') # 存在则删除；不存在输出自定义错误提示，即参数二dict9 = &#123;'No1':'java','No2':'python','No3':'C++'&#125;dict9.popitem() # 从后往前删除，每次删除一个。先删除No3,再删除No2...dict9.clear() # dict9为 &#123;&#125; 集合可变集合(set) 不可变集合(frozenset)没有顺序，没有重复元素 字面量1234print(&#123;1,2,3,4&#125;) # &#123;1, 2, 3, 4&#125;print(&#123;1,2,1,4&#125;) # &#123;1, 2, 4&#125;print(&#123;1,True&#125;) # &#123;1&#125;print(&#123;1,False&#125;) # &#123;False, 1&#125; 对象1234set1 = set('hello') # &#123;'h', 'e', 'l', 'o'&#125;set2 = set((1,2,3,4)) # &#123;1, 2, 3, 4&#125;set3 = set([1,2,3,4]) # &#123;1, 2, 3, 4&#125;set4 = set((1,[2,3,4]))# 错误 推导式1&#123;x*x for x in range(1,5)&#125; # &#123;16, 1, 4, 9&#125; 交并差集123456set5 = set(1,2,3,4)set6 = set(3,4,5,6)set5 | set6 # 并集 &#123;1, 2, 3, 4, 5, 6&#125; set5 &amp; set6 # 交集 &#123;3, 4&#125; set5 - set6 # 差集 &#123;1, 2&#125; set5 ^ set6 # 对称差集 &#123;1, 2, 5, 6&#125; 合并1set5.update(set6) # &#123;1,2,3,4,5,6&#125; 拷贝1set7 = set6.copy()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用ZXing工具生成二维码以及解析二维码]]></title>
    <url>%2F2018%2F%E5%88%A9%E7%94%A8ZXing%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%BB%A5%E5%8F%8A%E8%A7%A3%E6%9E%90%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一、 二维码生成原理（即工作原理）二维码官方叫版本Version。Version 1是21 x 21的矩阵，Version 2是 25 x 25的矩阵，Version 3是29的尺寸，每增加一个version，就会增加4的尺寸，公式是：(V-1)4 + 21（V是版本号） 最高Version 40，(40-1)4+21 = 177，所以最高是177 x 177 的正方形。 下面是一个二维码的样例： 1、定位图案 Position Detection Pattern是定位图案，用于标记二维码的矩形大小。这三个定位图案有白边叫Separators for Postion Detection Patterns。之所以三个而不是四个意思就是三个就可以标识一个矩形了。 Timing Patterns也是用于定位的。原因是二维码有40种尺寸，尺寸过大了后需要有根标准线，不然扫描的时候可能会扫歪了。 Alignment Patterns 只有Version 2以上（包括Version2）的二维码需要这个东东，同样是为了定位用的。 2、功能性数据 Format Information 存在于所有的尺寸中，用于存放一些格式化数据的。 Version Information 在 &gt;= Version 7以上，需要预留两块3 x 6的区域存放一些版本信息。 数据码和纠错码 除了上述的那些地方，剩下的地方存放 Data Code 数据码 和 Error Correction Code 纠错码。 3、数据编码 QR码支持如下的编码： Numeric mode 数字编码，从0到9。如果需要编码的数字的个数不是3的倍数，那么，最后剩下的1或2位数会被转成4或7bits，则其它的每3位数字会被编成 10，12，14bits，编成多长还要看二维码的尺寸（下面有一个表Table 3说明了这点） Alphanumeric mode 字符编码。包括 0-9，大写的A到Z（没有小写），以及符号$ % * + – . / : 包括空格。这些字符会映射成一个字符索引表。如下所示：（其中的SP是空格，Char是字符，Value是其索引值） 编码的过程是把字符两两分组，然后转成下表的45进制，然后转成11bits的二进制，如果最后有一个落单的，那就转成6bits的二进制。而编码模式和 字符的个数需要根据不同的Version尺寸编成9, 11或13个二进制（如下表中Table 3） Byte mode, 字节编码，可以是0-255的ISO-8859-1字符。有些二维码的扫描器可以自动检测是否是UTF-8的编码。 Kanji mode 这是日文编码，也是双字节编码。同样，也可以用于中文编码。日文和汉字的编码会减去一个 值。如：在0X8140 to 0X9FFC中的字符会减去8140，在0XE040到0XEBBF中的字符要减去0XC140，然后把前两位拿出来乘以0XC0，然后再加上后两位，最 后转成13bit的编码。如下图示例： Extended Channel Interpretation (ECI) mode 主要用于特殊的字符集。并不是所有的扫描器都支持这种编码。 Structured Append mode 用于混合编码，也就是说，这个二维码中包含了多种编码格式。 FNC1 mode 这种编码方式主要是给一些特殊的工业或行业用的。比如GS1条形码之类的。 简单起见，后面三种不会在本文 中讨论。 下面两张表中， Table 2 是各个编码格式的“编号”，这个东西要写在Format Information中。注：中文是1101 Table 3 表示了，不同版本（尺寸）的二维码，对于，数字，字符，字节和Kanji模式下，对于单个编码的2进制的位数。（在二维码的规格说明书中，有各种各样的编码规范表，后面还会提到） 示例一：数字编码 在Version 1的尺寸下，纠错级别为H的情况下，编码： 01234567 把上述数字分成三组: 012 345 67 把他们转成二进制: 012 转成 0000001100； 345 转成 0101011001； 67 转成 1000011。 把这三个二进制串起来: 0000001100 0101011001 1000011 把数字的个数转成二进制 (version 1-H是10 bits ): 8个数字的二进制是 0000001000 把数字编码的标志0001和第4步的编码加到前面: 0001 0000001000 0000001100 0101011001 1000011 示例二：字符编码 在Version 1的尺寸下，纠错级别为H的情况下，编码: AC-42 从字符索引表中找到 AC-42 这五个字条的索引 (10,12,41,4,2) 两两分组: (10,12) (41,4) (2) 3.把每一组转成11bits的二进制: (10,12) 10*45+12 等于 462 转成 00111001110 (41,4) 41*45+4 等于 1849 转成 11100111001 (2) 等于 2 转成 000010 把这些二进制连接起来：00111001110 11100111001 000010 把字符的个数转成二进制 (Version 1-H为9 bits ): 5个字符，5转成 000000101 在头上加上编码标识 0010 和第5步的个数编码: 0010 000000101 00111001110 11100111001 000010 结束符和补齐符 假如我们有个HELLO WORLD的字符串要编码，根据上面的示例二，我们可以得到下面的编码， 编码 字符数 HELLO WORLD的编码 0010 000001011 01100001011 01111000110 10001011100 10110111000 10011010100 001101 我们还要加上结束符： 编码 字符数 HELLO WORLD的编码 结束 0010 000001011 01100001011 01111000110 10001011100 10110111000 10011010100 001101 0000 按8bits重排 如果所有的编码加起来不是8个倍数我们还要在后面加上足够的0，比如上面一共有78个bits，所以，我们还要加上2个0，然后按8个bits分好组： 00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 补齐码（Padding Bytes） 最后，如果如果还没有达到我们最大的bits数的限制，我们还要加一些补齐码（Padding Bytes），Padding Bytes就是重复下面的两个bytes：11101100 00010001 （这两个二进制转成十进制是236和17，我也不知道为什么，只知道Spec上是这么写的）关于每一个Version的每一种纠错级别的最大Bits限 制，可以参看QR Code Spec的第28页到32页的Table-7一表。 假设我们需要编码的是Version 1的Q纠错级，那么，其最大需要104个bits，而我们上面只有80个bits，所以，还需要24个bits，也就是需要3个Padding Bytes，我们就添加三个，于是得到下面的编码： 00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 11101100 00010001 11101100 纠错码 上面我们说到了一些纠错级别，Error Correction Code Level，二维码中有四种级别的纠错，这就是为什么二维码有残缺还能扫出来，也就是为什么有人在二维码的中心位置加入图标。 错误修正容量 L水平 7%的字码可被修正 M水平 15%的字码可被修正 Q水平 25%的字码可被修正 H水平 30%的字码可被修正 那么，QR是怎么对数据码加上纠错码的？首先，我们需要对数据码进行分组，也就是分成不同的Block，然后对各个Block进行纠错编码，对于如何分组，我们可以查看QR Code Spec的第33页到44页的Table-13到Table-22的定义表。注意最后两列： Number of Error Code Correction Blocks ：需要分多少个块。 Error Correction Code Per Blocks：每一个块中的code个数，所谓的code的个数，也就是有多少个8bits的字节。 举个例子：上述的Version 5 + Q纠错级：需要4个Blocks（2个Blocks为一组，共两组），头一组的两个Blocks中各15个bits数据 + 各 9个bits的纠错码（注：表中的codewords就是一个8bits的byte）（再注：最后一例中的（c, k, r ）的公式为：c = k + 2 * r，因为后脚注解释了：纠错码的容量小于纠错码的一半） 对每个块的纠错码 1 1 67 85 70 134 87 38 85 194 119 50 6 18 6 103 38 213 199 11 45 115 247 241 223 229 248 154 117 154 111 86 161 111 39 2 246 246 66 7 118 134 242 7 38 86 22 198 199 146 6 87 204 96 60 202 182 124 157 200 134 27 129 209 17 163 163 120 133 2 1 182 230 247 119 50 7 118 134 87 38 82 6 134 151 50 7 148 116 177 212 76 133 75 242 238 76 195 230 189 10 108 240 192 141 2 70 247 118 86 194 6 151 50 16 236 17 236 17 236 17 236 235 159 5 173 24 147 59 33 106 40 255 172 82 2 131 32 178 236 注：二维码的纠错码主要是通过Reed-Solomon error correction（里 德-所罗门纠错算法）来实现的。对于这个算法，对于我来说是相当的复杂，里面有很多的数学计算，最终编码。 穿插放置 二维码的混乱技术还没有玩完，它还要把数据码和纠错码的各个codewords交替放在一起。如何交替呢，规则如下： 对于数据码：把每个块的第一个codewords先拿出来按顺度排列好，然后再取第一块的第二个，如此类推。如：上述示例中的Data Codewords如下： 块 1 67 85 70 134 87 38 85 194 119 50 6 18 6 103 38 块 2 246 246 66 7 118 134 242 7 38 86 22 198 199 146 6 块 3 182 230 247 119 50 7 118 134 87 38 82 6 134 151 50 7 块 4 70 247 118 86 194 6 151 50 16 236 17 236 17 236 17 236 我们先取第一列的：67， 246， 182， 70 然后再取第二列的：67， 246， 182， 70， 85，246，230 ，247 如此类推：67， 246， 182， 70， 85，246，230 ，247 ……… ……… ，38，6，50，17，7，236 对于纠错码，也是一样： 块 1 213 199 11 45 115 247 241 223 229 248 154 117 154 111 86 161 111 39 块 2 87 204 96 60 202 182 124 157 200 134 27 129 209 17 163 163 120 133 块 3 148 116 177 212 76 133 75 242 238 76 195 230 189 10 108 240 192 141 块 4 235 159 5 173 24 147 59 33 106 40 255 172 82 2 131 32 178 236 和数据码取的一样，得到：213，87，148，235，199，204，116，159，…… …… 39，133，141，236 然后，再把这两组放在一起（纠错码放在数据码之后）得到： 67, 246, 182, 70, 85, 246, 230, 247, 70, 66, 247, 118, 134, 7, 119, 86, 87, 118, 50, 194, 38, 134, 7, 6, 85, 242, 118, 151, 194, 7, 134, 50, 119, 38, 87, 16, 50, 86, 38, 236, 6, 22, 82, 17, 18, 198, 6, 236, 6, 199, 134, 17, 103, 146, 151, 236, 38, 6, 50, 17, 7, 236, 213, 87, 148, 235, 199, 204, 116, 159, 11, 96, 177, 5, 45, 60, 212, 173, 115, 202, 76, 24, 247, 182, 133, 147, 241, 124, 75, 59, 223, 157, 242, 33, 229, 200, 238, 106, 248, 134, 76, 40, 154, 27, 195, 255, 117, 129, 230, 172, 154, 209, 189, 82, 111, 17, 10, 2, 86, 163, 108, 131, 161, 163, 240, 32, 111, 120, 192, 178, 39, 133, 141, 236 Remainder Bits 最后再加上Reminder Bits，对于某些Version的QR，上面的还不够长度，还要加上Remainder Bits，比如：上述的5Q版的二维码，还要加上7个bits，Remainder Bits加零就好了。关于哪些Version需要多少个Remainder bit，可以参看QR Code Spec的第15页的Table-1的定义表。 4、画二维码图 Position Detection Pattern 首先，先把Position Detection图案画在三个角上。 Alignment Pattern 然后，再把Alignment图案画上 关于Alignment的位置，可以查看QR Code Spec的第81页的Table-E.1的定义表（下表是不完全表格） 下图是根据上述表格中的Version8的一个例子（6，24，42） Timing Pattern 接下来是Timing Pattern的线（这个不用多说了） Format Information 再接下来是Formation Information，下图中的蓝色部分。 Format Information是一个15个bits的信息，每一个bit的位置如下图所示：（注意图中的Dark Module，那是永远出现的） 这15个bits中包括： 5个数据bits：其中，2个bits用于表示使用什么样的Error Correction Level， 3个bits表示使用什么样的Mask 10个纠错bits。主要通过BCH Code来计算 然后15个bits还要与101010000010010做XOR操作。这样就保证不会因为我们选用了00的纠错级别，以及000的Mask，从重造成全部为白色，这会增加我们的扫描器的图像识别的困难。 下面是一个示例： 关于Error Correction Level如下表所示： 关于Mask图案如后面的Table 23所示。 Version Information 再接下来是Version Information（版本7以后需要这个编码），下图中的蓝色部分。 Version Information一共是18个bits，其中包括6个bits的版本号以及12个bits的纠错码，下面是一个示例： 而其填充位置如下： 数据和数据纠错码 然后是填接我们的最终编码，最终编码的填充方式如下：从左下角开始沿着红线填我们的各个bits，1是黑色，0是白色。如果遇到了上面的非数据区，则绕开或跳过。 5、掩码图案 这样下来，图就填好了，但是，也许那些点并不均衡，所以还要做Masking操作QR的Spec中说了，QR有8个 Mask可以使用，如下所示：其中，各个mask的公式在各个图下面。所谓mask，说白了，就是和上面生成的图做XOR操作。Mask只会和数据区进 行XOR，不会影响功能区。 其Mask的标识码如下所示：（其中的i,j分别对应于上图的x,y） Mask过后的二维码就成最终的图了。 （以上内容来源于网络） 二、 编码实现首先，我们需要下载Google的ZXing库。下载地址：https://github.com/zxing/zxing 根据内容创建二维码12345678910111213141516171819202122232425262728293031/** * TODO 根据给定的内容生成二维码 * * @param content 二维码内容 * @param logoImagePath logo图标的路径 * @param needCompressed 是否需要压缩logo * @return 生成的二维码 * @throws IOException * @throws WriterException */private static BufferedImage createImage(String content, String logoImagePath, boolean needCompressed) throws IOException, WriterException &#123; HashMap hints = new HashMap&lt;EncodeHintType, Object&gt;(); hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); // 纠错等级 hints.put(EncodeHintType.CHARACTER_SET, CHARSET); hints.put(EncodeHintType.MARGIN, 1); // 二维码两边空白区域大小 BitMatrix bitMatrix = new MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, QRCODE_SIZE, QRCODE_SIZE, hints); int height = bitMatrix.getHeight(); int width = bitMatrix.getWidth(); BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); for (int x = 0; x &lt; width; x++) for (int y = 0; y &lt; height; y++) image.setRGB(x, y, bitMatrix.get(x, y) ? 0xFF000000 : 0xFFFFFFFF); if (logoImagePath == null || "".equals(logoImagePath)) return image; // 如果有logo，则插入logo图片 QRCode.InsertImage(image, logoImagePath, needCompressed); return image; &#125; 如果有logo则将logo插入到二维码中1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * TODO 插入logo图片 * @param sourceImage 原图片 * @param logoImagePath logo图片所在的路径 * @param needCompressed 是否需要压缩 * @throws IOException */ private static void InsertImage(BufferedImage sourceImage, String logoImagePath, boolean needCompressed) throws IOException &#123; File file = new File(logoImagePath); if (!file.exists())&#123; System.out.println("logo文件不存在！\n"); return; &#125; Image src = ImageIO.read(file); int width = src.getWidth(null); int height = src.getHeight(null); // 压缩二维码图片 if (needCompressed) &#123; if (width &gt; LOGO_WIDTH) width = LOGO_WIDTH; if (height &gt; LOGO_HEIGHT) height = LOGO_HEIGHT; Image image = src.getScaledInstance(width, height, Image.SCALE_SMOOTH); BufferedImage tag = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = tag.getGraphics(); g.drawImage(image, 0, 0, null); g.dispose(); // 释放占有的资源 src = image; // 直观的理解：Graphics2D 就相当于画笔，而BufferedImage 就是画笔绘制的结果。 &#125; // 插入logo Graphics2D graph = sourceImage.createGraphics(); int x = (QRCODE_SIZE - width) / 2; int y = (QRCODE_SIZE - height) / 2; graph.drawImage(src, x, y, width, height, null); Shape shape = new RoundRectangle2D.Float(x, y, width, width, 6, 6); graph.setStroke(new BasicStroke(3f)); graph.draw(shape); graph.dispose(); &#125; 解码过程1234567891011121314151617181920/** * TODO 解析二维码内容 * @param file 二维码 * @return 二维码包含的信息 * @throws Exception */ public static String decode(File file) throws Exception &#123; BufferedImage image; image = ImageIO.read(file); if (image == null) &#123; return null; &#125; BufferedImageLuminanceSource source = new BufferedImageLuminanceSource(image); BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source)); HashMap hints = new HashMap&lt;DecodeHintType, Object&gt;(); hints.put(DecodeHintType.CHARACTER_SET, CHARSET); Result result = new MultiFormatReader().decode(bitmap, hints); String resultStr = result.getText(); return resultStr; &#125; 测试结果源码下载地址：https://github.com/Liyzy/ZXing-QRCode开发环境：idea 2018.2]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java学习笔记3】继承&多态篇]]></title>
    <url>%2F2018%2F%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%91%2F</url>
    <content type="text"><![CDATA[继承 关键字extends表示继承，继承是一个is-a关系，java中只有公有继承 覆盖方法（override）将父类中的方法在子类中重新定义，以Employee类和Manager类为例，Manager继承Employee类，Employee有方法getSalary(); Manager类需要重写这个方法，加上经理所特有的奖金。 123456789101112131415161718public class Employee&#123; private double salary; ... public double getSalary()&#123; return salary; &#125;&#125;public class Manager extends Employee&#123; private double bonus; ... public double getSalary()&#123; //return salary + bonus; // 错误，不能访问超类的私有域 //return getSalary() + bonus; // 错误，调用自身直至崩溃 return super.getSalary() + bonus; // 正确 &#125;&#125;//super关键字表示调用父类的方法 子类构造器必须调用父类的构造器，并且应将这一过程放在程序的第一句 1234public Manager(String name, String id, double salary)&#123; super(name, id, salary); // 置于第一句，如果没有这句，系统自动调用父类的默认构造函数；如果没有默认构造函数有没有显式调用其他构造器就会产生错误 bonus = 0;&#125; java不支持多继承，即每一个类都只能继承最多一个类。但每一个类可以实现多个接口，这也是引入接口的一个考虑。 多态java实现多态的两种方式：重载(overloading)和覆盖(override)1234567891011121314151617181920212223242526/* override */Manager boss = new Manager("lihui", 201822, 50000);boss.setBonus(20000);Empolyee[] staff = new Empolyee[2];staff[0] = boss;staff[1] = new Employee("chengle", 201833, 60000);staff[0].setBonus(20000); // 错误，staff声明为Employee类型，Employee没有setBonus方法if(staff[0] instanceof Manager) ((Manager)staff[0]).setBonus(20000); // 正确，将staff[0]强制转换为Manager类型 for(Employee aEmpolyee: staff) System.out.println(aEmpolyee.getName() + " " + aEmpolyee.getSalary());// aEmpolyee定义为Empolyee类型，但在执行的时候，aEmpolyee引用的Empolyee和Manager调用不同的getSalary函数// 一个对象变量可以指示多种实际类型的现象称为多态。// 在运行的时候自动选择调用哪个方法称为动态绑定。/* overloading */public class Manager&#123; ... public double getSalary(String name)&#123;...&#125; public float getSalary(String name)&#123;...&#125; //错误，已经存在getSalary(String name)方法,即签名相同，说明重载与返回值无关 public double getSalary(String name, String id)&#123;...&#125; //正确的重载&#125; 方法的签名：方法的名字和参数列表称为方法的签名，返回类型不是签名的一部分。 override的规则： 子类覆盖父类中具有相同签名的方法。 返回类型是被重写方法的返回类型的子类型。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static、private、final的方法不能被重写。(private的方法本身就被定义成了final的) 构造器不能被重写。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 overloading的规则：方法名相同，参数列表必须不同，返回值可同可不同，修饰符可同可不同。 方法调用的过程1）假设调用x.f(param), 编译器一一列举x所属类中的名为f的方法以及其父类中访问属性为public的名为f的方法（超类的私有方法不可访问）。2）查看调用方法提供的参数类型。如果第一步中列举出的方法中有一个方法的参数列表与提供的参数类型完全匹配，就选择这个方法。如果没有找到与参数类型匹配的方法或者经过类型转换后有多个方法与之匹配，就会产生错误。3）如果是static、private、final方法或者构造器，编译器可以准确的知道应该调用哪个方法，静态绑定。4）动态绑定时，先查看子类中是否定义了这个方法，是则调用，否则调用父类的这个方法。 final修饰符定义类的时候加上final修饰符表示类不允许被继承，其中的方法自动的成为final，但是域不会变成final。一个方法或者一个域也可以加上final表示不可被覆盖或者不可改变域的值。 抽象类关键字abstract表示抽象类，包含有一个或多个抽象函数的类需要声明为抽象类（为了代码清晰），抽象类里的抽象方法不需要实现，在子类中对其进行实现。]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java学习笔记2】数组&运算符&权限篇]]></title>
    <url>%2F2018%2F%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E3%80%91%2F</url>
    <content type="text"><![CDATA[数组 运算符 包 访问权限 修饰符 数组1. 数组的声明：int[] a; 2. 数组的创建使用new运算符数组的创建int[] a = new int[100] 数组的长度不要求是常量：new int[n]会创建一个长度为n的数组 3. 数组的初始化可以使用for循环进行赋值，或者直接int[] a = {1, 2, 3}进行赋值；数组创建时，数字数组所有元素初始化为0，Boolean数组所有元素初始化为false，对象数组则初始化为null值。 4. 数组长度每一个数组都有成员属性length，使用a.length获得数组a的长度 5. 数组的遍历输出 a. 传统for循环12for(int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); b. for each循环123for(int element : a) System.out.print(element + " ");//对于在for循环语句中需要使用元素下标的程序来说不合适 c. 利用Arrays类的toString方法12System.out.println(Arrays.toString(a));//a为数值型的数组或Boolean数组 6. 数组拷贝12int[] b = a; //b和a引用同一个数组b[1] = 7; //此时访问a[1]也是7 如果希望把一个数组的所有值拷贝到一个新的数组,使用Arrays类的copyOf方法1int[] b = Arrays.copyOf(a, a.length); 第二个参数表示新数组的长度，比原数组长，则多余的元素被赋值为0或者false或者null，比原数组短，则只复制前面的对应长度的元素。方法Arrays.copyOfRange(type[] a, int start, int end)type为int, short, byte, long, double, float, Boolean 类型 7. 数组排序1Arrays.sort(a); //使用优化的快速排序 8. 多维数组多维数组创建123int[][] a = new int[2][3]; //正确int[][] b = new int[2][]; //正确, 第二维的长度可以动态申请，可以不同int[][] c = new int[][3]; //错误 多维数组遍历12345678910111213141516int[][] b = new int[2][];for (int i = 0; i &lt; b.length; i++) &#123; b[i] = new int[i + 1]; for (int j = 0; j &lt; b[i].length; j++) b[i][j] = i + j;&#125;//第一种方式for(int i = 0; i &lt; a.length; i++) for(int j = 0; j &lt; a[i].length) System.out.print(a[i][j] + " ");//第二种方式for (int[] row : b) for (int value : row) System.out.print(value + " ");//第三种方式System.out.println(Arrays.deepToString(b)); 多维数组的每一行是可以通过引用进行交换的。 运算符除法12345float a = 12.3f;int b = 5;a = a / 0; //得到Infinity或者NaNb = b / 0; //除零异常System.out.println(a); 取模123456789int a = 5;int b = -5;a = a % 3;b = b % 3;System.out.println(a + "," + b); //2,-2a = a % -3;b = b % -3;System.out.print(a + "," + b); //2,-2/*求模运算的结果与左操作数符号相同，与右操作数符号无关*/ 算术运算的结果不低于int型12345678byte a = 3;byte b = 2;b = a + b; //错误，a+b返回int型，int不能赋值给byteb = (byte)(a + b); //正确，强制转换b += a; //正确，b += a等价于b = (byte)(b + a)int c = 7;c = c + 5.2; //错误c += 5.2; //正确 虚箭头表示可能有精度损失的转换，实箭头表示无信息丢失的转换。 基本数据类型的数组之间不能相互赋值，因为java中数组是类。 移位运算&lt;&lt;左移，低位补0，移位中可能会出现符号变换&gt;&gt;右移，高位补符号位&gt;&gt;&gt;无符号右移，高位补01234int a = 5;// a &gt;&gt; 33等价于a &gt;&gt; 1，移的位数和数值类型的位数取模byte b = 5;// b &gt;&gt; 33等价于b &gt;&gt; 1,在b &gt;&gt; 33操作中，b自动提升为int型 ~位反运算，每一位取反 位逻辑运算位逻辑运算优先级 &amp; ^ | 三目运算符？：的第二第三操作数必须是可以赋值的 包一个类可以使用所属包中所有的类，以及其他包中的公有类。访问其他包中公有类的两种方式：在每个类前添加完整的包名；使用import语句(放在源文件的顶部，package语句的后面)。package语句对整个源文件有效，即同一个源文件里的所有类都属于这个包。 访问权限1234//public//private//protected//没有指定则为同包可访问 修饰符static 静态修饰符final 常量修饰符，也可以表示一个类不允许继承1234567891011121314public class A&#123; int i; static int j; public static void main(String[] args)&#123; i = 3; //错误，i只有在new了一个对象后才会存在 j = 7; //正确，j是静态的，不需要创建对象就存在 A a = new A(); a.i = 3; //正确 A.i = 3; //错误 A.j = 4; //正确，j是所有的A类对象所共有的，所以可以通过类名来访问 a.j = 4; //正确 &#125;&#125;]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitee(码云)、Github同时配置ssh key]]></title>
    <url>%2F2018%2FGitee(%E7%A0%81%E4%BA%91)%E3%80%81Github%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEssh%20key%2F</url>
    <content type="text"><![CDATA[一、到.ssh文件夹下cd ~/.ssh 二、通过下面的命令，依次生成两个平台的key12$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;github_id_rsa&quot;$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;gitee_id_rsa&quot; 完成后，.ssh文件夹生成以下文件 三、把public key复制到gitee和github执行命令cat github_id_rsa.pub把第二行到结尾的内容复制到github的ssh中保存 同样的操作，添加gitee的ssh 四、创建config文件解决ssh冲突在.ssh文件夹下执行命令vi config文件中添加以下内容1234567891011# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/gitee_id_rsa# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github_id_rsa 五、测试执行ssh -T git@github.com成功则返回Welcome to Gitee.com ,yourname!执行ssh -T git@gitee.com成功则返回Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access.]]></content>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java学习笔记1】数据类型&函数篇]]></title>
    <url>%2F2018%2F%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%91%2F</url>
    <content type="text"><![CDATA[Java简单介绍 第一个程序Hello World 基本数据类型 对象和类 数据声明 函数声明 参数传递 Java简单介绍 Java的优点：简单、可移植性 JDK (Java Development Kit) Java开发工具包 JRE (Java Runtime Environment) Java运行环境 只要具有JRE，就可以运行Java代码，而与操作系统的类别无关 安装完JDK后，在电脑“编辑系统环境变量”—-“环境变量”选项下，系统变量新建 变量名 JAVA_HONE 变量值 D:\Program Files\java\jdk-10.0.1(这是我的JDK位置) 系统变量找到Path变量，编辑新建D:\Program Files\java\jdk-10.0.1\bin之后在cmd 中测试命令 Java 和 Javac ，有东西输出之后就可以用Javac在cmd里编译Java程序了(生成.class文件)，用Java [option] [主类名]就可以运行程序了(java HelloWorld 而不是 java HelloWorld.class)。第一个程序 Hello World12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println("Hello World!"); &#125;&#125; 注意Java区分大小写，参数中的String的S必须大写。 基本数据类型charbooleanbyte, short, int, long, float, double char(字符型) 首先补充编码的知识ASCII码(美国信息交换标准代码，7-bits ASCII码) 七位码，共128个字符，它主要用于显示现代英语和其他西欧语言。GB2312，是中国国家标准的简体中文字符集，双字节字符集。GBK，GBK字符集主要扩展了繁体中文字的支持，双字节字符集。GB18030,GB 18030标准采用单字节、双字节和四字节三种方式对字符编码。单字节部分使用0×00至0×7F码(对应于ASCII码的相应码)。双字节部分，首字节码从0×81至0×FE，尾字节码位分别是0×40至0×7E和0×80至0×FE。四字节部分采用GB/T 11383未采用的0×30到0×39作为对双字节编码扩充的后缀，这样扩充的四字节编码，其范围为0×81308130到0×FE39FE39。其中第一、三个字节编码码位均为0×81至0×FE，第二、四个字节编码码位均为0×30至0×39。按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集(DBCS)。Unicode(万国码、统一码、单一码)，16位，也就是两个字节代表一个字符。UTF-8是一种8位的unicode字符集，编码长度是可变的，并且是ASCII字符集的严格超集，也就是说ASCII中每个字符的编码在UTF-8中是完全一样的。UTF-8字符集中，一个字符可能是1个字节，2个字节，3个字节或者4个字节长。一般来说，欧洲的字母字符长度为1到2个字节，而亚洲的大部分字符则是3个字节，附加字符为4个字节长。更多关于编码参考文章http://blog.sina.com.cn/s/blog_4b4409c30100vw9t.html 在Java中采用Unicode编码，所以char a = &#39;a&#39;; 和 char b = &#39;中&#39;一样都占两个字节(区别于C和C++)char c = &#39;\u21fa&#39;表示转义字符，格式为\u加上4位16进制数 boolean(布尔型)只有true 和 false 两个值，区别于C和C++。在C和C++中，bool类型可以用数字赋值，非零即为真，零为假。但在Java中只有boolean flag = true; 和 boolean flag = false; byte, short, int, long, float, double(数值型) 类型 存储要求 取值范围 备注 byte 1字节 -128~127 short 2字节 -32768~32767 int 4字节 超过21亿 long 8字节 很大很大 需要在数值后加后缀L float 4字节 大约为±3.402E+38 需要在数值后加后缀F，有效位6~7位 double 8字节 大约为±1.797E+308 需要在数值后加后缀D，有效位15位 float和double类型表示的的数值是离散的，可能有一些小数就是无法表示，只能为近似值。不加F后缀的浮点数值默认为double类型。float和double不能做移位运算。整形移位运算相当于除或乘2的移的位数的次幂。-1在计算机中存储形式为全一，无论移多少位都不变。 对象和类对象(哎)是现实世界中的一个实体。类是具有相同特征的对象的属性的集合。 类的声明1234567891011121314151617[修饰符1][修饰符2][修饰符...]class Student&#123; int i; //类内的变量可以不用定义时赋值，数值变量系统默认赋值为零；逻辑变量boolean默认为false static int j = 1; ... public void Func(float[] f) &#123; ... int i = 0; //函数内的变量随手赋值是个好习惯，不赋值的话，在内存中是暂时没有这个变量的 ... &#125; public static void main(String[] args) &#123; ... &#125; ...&#125; 类实例化为对象123456789Student s1 = new Student();Student s2;s2 = s1;//一个对象变量没有实际包含一个对象，而仅仅是引用一个对象。//new操作符返回的也是一个引用，即这个对象的存储地址。//上面代码中的s2 = s1;仅仅是把s1保存的引用复制一份给s2，并没有复制这个对象//可以将一个对象变量赋值为null，表明这个对象变量目前没有引用任何的对象//如果一个对象没有任何的对象变量引用它，那么这个对象就成为垃圾对象，会被系统自动清理//例如上面代码，如果添加s1 = null;那么这个对象不是垃圾对象，因为还有s2引用(指向)它。 数据声明没什么好说的。[变量类型] [变量名] = [初始值];说一些命名的规则和习惯吧(提高代码可读性)。 a. 必须是字母开头的由字母、数字、下划线组成的序列，区分大小写。虽然在命名可以使用$，但是不要使用。 b. 类名使用 UpperCamelCase(大驼峰) 风格，即每个单词首字母都要大写。 c. 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase(小驼峰) 风格，即从第二个单词开始首字母大写。如：studentName d. 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 e. 杜绝完全不规范的缩写， 避免望文不知义。 … 函数声明1[修饰符1][修饰符2][修饰符..] [函数返回值] [函数名](参数1，参数2，参数..) &#123;函数体&#125; 参数传递Java的函数参数传递只有一种方法：传值(call by value)java 成员变量(成员变量就是方法外部，类的内部定义的变量)存储在堆中的对象里面;局部变量就是方法或语句块内部定义的变量,局部变量必须初始化,局部变量的数据存在于栈内存中,栈内存中的局部变量随着方法的结束而出栈。 例子：12345678910111213141516171819202122232425public class Card&#123; int rank; public static void swap1(Card c1,Card c2) &#123; Card temp = c1; c1 = c2; c2 = temp; &#125; public static void swap2(Card c1,Card c2) &#123; int temp = c1.rank; c1.rank = c2.rank; c2.rank = temp; &#125; public static void main(String[] args) &#123; Card c1 = new Card(); c1.rank = 5; Card c2 = new Card(); c2.rank = 6; swap1(c1,c2); swap2(c1,c2); &#125;&#125; 结果是swap1并没有实现数值交换；swap2实现了数值的变换。分析：在main函数中，首先生成两个对象存储在堆中，并有引用变量c1,c2分别指向两个对象。在调用swap1，main函数的栈空间里复制c1,c2传递给函数，在函数中一波操作猛如虎，两个复制品的指向对象互换，然后函数结束，两个复制品出栈，然而原c1和c2的指向并没有改变。在swap2里，改的直接是存储在堆里的对象的变量，指向没有变化，但是内部的数值已经交换了。]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计范式]]></title>
    <url>%2F2018%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.第一范式(1NF) 定义：如果关系模式R的所有属性的域都是原子的，那么称关系模式R属于第一范式。 通俗的讲，第一范式就是属性不可再分。比如地址属性，可以再分为省、市、县等属性，所以在这种情况下，地址属性所在的关系模式就不符合第一范式。 2.第二范式(2NF) 定义：若R满足第一范式，且每一个非主属性完全函数依赖于主码，则R满足第二范式。 这里首先补充函数依赖的知识 平凡依赖和非平凡依赖如果A-&gt;B，A是B的超集，则称此函数依赖为平凡的。举个例子：A-&gt;A AB-&gt;A ABC-&gt;AB都是平凡依赖（此处的A、B、C为原子属性）非平凡依赖就是不包含自己或包含自己的集决定自己的函数依赖。 完全依赖和部分依赖函数依赖A-&gt;B称为部分依赖的条件是存在A的真子集C使得C-&gt;B。即A中的一部分就可以决定B，不需要所有的属性来决定B。反之，需要A中所有的属性才能来决定B，缺一不可，那么A-&gt;B就是一个完全依赖。 传递依赖如果A、B是两个属性集，存在A-&gt;B，如果c是一个属性，并且c不属于A或B，并且存在B-&gt;c，那么c就传递依赖于A。 根据2NF的定义，我们可以知道，单属性主键的关系模式一定符合第二范式。 3.第三范式(3NF) 定义：对于F*(F的闭包)中所有形如A-&gt;B的函数依赖（其中A、B都包含于R），以下至少一项成立： · A-&gt;B是一个平凡的函数依赖 · A是R的一个超码 · B-A中的每个属性c都包含于R的一个候选码中 简单的说，若R满足第二范式，且每一个非主属性都不传递函数依赖于主码，则R满足第三范式。即不存在如下依赖关系： 关键字段 → 非关键字段x → 非关键字段y举个例子：假定学生关系表为Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)，关键字为单一关键字”学号”，因为存在如下决定关系： (学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话) 这个数据库是符合2NF的，但是不符合3NF，因为存在如下决定关系： (学号) → (所在学院) → (学院地点, 学院电话) 即存在非关键字段”学院地点”、”学院电话”对关键字段”学号”的传递函数依赖。 4.BC范式(BCNF) 定义：若R满足第三范式，且每一个主属性都不部分函数依赖或传递函数依赖于主码，则R满足第三范式。· 每一个决定属性集（因素）都包含（候选）码· R中的所有属性（主，非主属性）都完全函数依赖于码 举个例子：假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系： (仓库ID, 存储物品ID) →(管理员ID, 数量) (管理员ID, 存储物品ID) → (仓库ID, 数量) 所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系： (仓库ID) → (管理员ID) (管理员ID) → (仓库ID) 即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。 BCNF分解算法1234567while(有违反BCNF的函数依赖)&#123; 找出违反BCNF的函数依赖A-&gt;B； 先计算A的闭包，且用A的闭包(除去A)替换B，并将其分解为&#123;A+&#125;和&#123;AU(R-(A+)&#125;; //比如A-&gt;B ，而&#123;A&#125;+=&#123;A,B,C&#125;，则用A-&gt;BC替换A-&gt;B; 求出分解后的关系满足的投影FD集合； 再看分解后的关系的FD集合是否满足BCNF，如果不满足，则继续分解&#125; 举个例子： 3NF分解算法 致谢：分解算法参考博客：https://blog.csdn.net/xiazdong/article/details/7517438]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库练习题(基础)]]></title>
    <url>%2F2018%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%E9%A2%98(%E6%AF%94%E8%BE%83%E5%9F%BA%E7%A1%80)%2F</url>
    <content type="text"><![CDATA[一、基本表的定义与删除T1.用SQL语句创建如下三张表：学生（Student）,课程表（Course）,和学生选课表（SC）,这三张表的结构如表1-1到表1-3所示。表1-1 Student表结构 列名 说明 数据类型 约束 Sno 学号 字符串 长度为7，主码 Sname 姓名 字符串 长度为10，非空 Ssex 性别 字符串 长度为2，取‘男’或‘女’ Sage 年龄 整数 取值15~45 Sdept 所在系 字符串 长度为20 默认为‘计算机系’ 123456create table Student(Sno varchar(7) primary key,Sname varchar(10) not null,Ssex varchar(2) check(Ssex='男' or Ssex='女'),Sage int check(Sage&gt;=15 and Sage &lt;=45),Sdept varchar(20) default('计算机系')); 表1-2Course表结构 列名 说明 数据类型 约束 Cno 课程号 字符串 长度为10，主码 Cname 课程名 字符串 长度为20，非空 Ccredit 学分 整数 取值大于0 Semster 学期 整数 取值大于0 Cperiod 学时 整数 取值大于0 1234567create table Course(Cno varchar(10) primary key,Cname varchar(20) not null,Ccredit int check(Ccredit&gt;0),Semster int check(Semster &gt;0),Cperiodint check(Cperiod&gt;0)); 表1-3 SC表结构表1-2Course表结构 列名 说明 数据类型 约束 Sno 学号 字符串 长度为7，主码，参照Student的外码 Cno 课程名 字符串 长度为10，主码，参照Course Grade 成绩 整数 取值0~100 1234567create table SC(Sno varchar(7),Cno varchar(10),Grade int check(Grade &gt;=0 and Grade &lt;=100),primary key(Sno,Cno),foreign key (Sno) references Student(Sno),foreign key (Cno) references Course(Cno)); PS:外码(键): 一个关系模式(r1)可能在它的属性中包含另一个关系模式(r2)的主码,这个属性在r1上称作参照r2的外码。关系r1称为外码依赖的参照关系，关系r2称为外码的被参照关系。FK一定来自另一个表的PK，FK是PK的子集。 如果外键或者主键要求命名，请使用以下语法12constraint pk_Student_Sno primary key (Sno)constraint fk_Student_Sno foreign key (Sno) references Student(Sno)//SC表，参照表后边的属性可以省略 已有表，添加外键1234alter table SCadd constraint fk_Student_Sno foreign key (Sno) references Student(Sno); 二、修改表结构T2.为SC表添加“选课类别”列，此列的定义为XKLB char(4) 1alter table SC add XKLB char(4); T3.将新添加的XKLB的类型修改为char(6)1alter table SC alter column XKLB char(6); T4.删除Course表的Cperiod列1alter table Course drop column Cperiod; T5.重命名Student表的Ssex列为sex1EXEC sp_rename 'Student.Ssex','sex'; 三、数据查询功能表3-1 Student表数据 Sno Sname Ssex Sage Sdept 9512101 李勇 男 19 计算机系 9512102 刘晨 男 20 计算机系 9512103 王敏 女 20 计算机系 9521101 张立 男 22 信息系 9521102 吴宾 女 21 信息系 9521103 张海 男 20 信息系 9531101 钱小平 女 18 数学系 9531102 王大力 男 19 数学系 12345678910insert into Studentvalues('9512101','李勇','男',19,'计算机系'),('9512102','刘晨','男',20,'计算机系'),('9512103','王敏','女',20,'计算机系'),('9521101','张立','男',22,'信息系'),('9521102','吴宾','女',21,'信息系'),('9521103','张海','男',20,'信息系'),('9531101','钱小平','女',18,'数学系'),('9531102','王大力','男',19,'数学系'); 表3-2 Course表数据 Cno Cname Ccredit Semster C01 计算机文化学 3 1 C02 VB 2 3 C03 计算机网络 4 7 C04 数据库基础 6 6 C05 高等数学 8 2 C06 数据结构 5 4 12345678insert into Course(Cno,Cname,Ccredit,Semster)values('C01','计算机文化学',3,1),('C02','VB',2,3),('C03','计算机网络',4,7),('C04','数据库基础',6,6),('C05','高等数学',8,2),('C06','数据结构',5,4); 表 3-3 SC表数据 Sno Cno Grade XKLB 9512101 c01 90 必修 9512101 c02 86 选修 9512101 c06 必修 9512102 c02 78 选修 9512102 c04 66 必修 9521102 c01 82 选修 9521102 c02 75 选修 9521102 c04 92 必修 9521102 c05 50 必修 9521103 c02 68 选修 9521103 c06 必修 9531101 c01 80 选修 9531101 c05 95 必修 9531102 c05 85 必修 12345678910111213141516insert into SC values('9512101','c01',90,'必修'),('9512101','c02',86,'选修'),('9512101','c06',NULL,'必修'),('9512102','c02',78,'选修'),('9512102','c04',66,'必修'),('9521102','c01',82,'选修'),('9521102','c02',75,'选修'),('9521102','c04',92,'必修'),('9521102','c05',50,'必修'),('9521103','c02',68,'选修'),('9521103','c06',NULL,'必修'),('9531101','c01',80,'选修'),('9531101','c05',95,'必修'),('9531102','c05',85,'必修'); T6.查询全体学生的学号与姓名12select Sno,Sname from Student; T7.查询全体学生的姓名，学号和所在系12select Sno,Sname,Sdept from Student; T8.查询全体学生的所有信息（三张表以上的关联查询）12select *from Student left join SC on Student.Sno=SC.Sno left join Course on SC.Cno=Course.Cno T9.查询全体学生的姓名及其出生年份12select Sname,2018-Sage as '出生年份'from Student T10.查询全体学生的姓名和出生年份，并在出生年份列前加入一个列，此列的每行数据均为“Year of Birth”常量值12select Sname,'Year of Birth',2018-Sage as '出生年份'from Student T11.在选课表（SC）中查询有哪些学生选修了课程，并列出学生的学号12select distinct Snofrom SC T12.查询计算机系全体学生的姓名123select Snamefrom Studentwhere Sdept='计算机系' T13.查询所有年龄在20岁以下的学生的姓名及年龄123select Sname,Sagefrom Student where Sage&lt;20 T14.查询考试成绩不及格的学生的姓名123select Snamefrom Student,SC where Student.Sno=SC.Sno and SC.Grade&lt;60 T15.查询年龄在20~23岁之间的学生的姓名，所在系和年龄123select Sname,Sdept,Sagefrom Student where Sage between 20 and 23 T16.查询年龄不在20~23之间的学生的姓名，所在系和年龄123select Sname,Sdept,Sagefrom Student where Sage not between 20 and 23 T17.查询信息系，数学系和计算机系学生的姓名和性别123select Sname,Ssexfrom Student where Sdept in ('信息系','数学系','计算机系') T18.查询既不属于信息系，数学系，也不属于计算机系的学生的姓名和性别123select Sname,Ssexfrom Student where Sdept not in ('信息系','数学系','计算机系') T19.查询学生表中姓“张”的学生的详细信息123select *from Student where Sname like '张%' T20.查询学生表中姓“张”，姓“李”和姓“刘”的学生的情况123select *from Student where Sname like '张%' or Sname like '李%' or Sname like '刘%' 使用下边的这种写法更加简便123select *from Student where Sname like '[张李刘]%' T21.查询名字中第2个字为“小”或“大”字的学生的姓名和学号123select Sname,Snofrom Student where Sname like '_[小大]%' T22.查询所有不姓“刘”的学生的姓名123select Snamefrom Student where Sname not like '刘%' T23.从学生表中查询学号的最后一位不是2，3，5的学生的情况123select *from Student where Sno not like '%[235]' T24.查询无考试成绩的学生的学号和相应的课程号123select Sno,Cnofrom SC where Grade is null T25.查询所有有考试成绩的学生的学号和课程号123select Sno,Cnofrom SC where Grade is not null T26.查询计算机系年龄在20岁以下的学生的姓名123select Snamefrom Student where Sdept='计算机系' and Sage&lt;20 T27.将学生按年龄升序排序123select *from Student order by Sage asc T28.查询选修了课程“c02”的学生的学号及其成绩，查询结果按成绩降序排列1234select Sno,Gradefrom SCwhere Cno='C02'order by Grade desc T29.查询全体学生的信息，查询结果按所在系的系名升序排列，同一系的学生按年龄降序排列123select *from Studentorder by Sdept,Sage desc T30.统计学生总人数12select count(*)from Student T31.统计选修了选修课程的学生的人数123select count(distinct Sno)from SCwhere XKLB='选修' T32.计算学号为9512101的学生的考试总成绩之和123select sum(Grade)from SCwhere Sno='9512101' T33.计算课程“c01”的学生的考试平均成绩123select avg(Grade)from SCwhere Cno='C01' T34.查询选修了课程“c01”的学生的最高分和最低分123select max(Grade),min(Grade)from SCwhere Cno='C01' T35.统计每门课程的选课人数，列出课程号和人数123select Cno,count(Sno) as '选课人数'from SCgroup by Cno T36.查询每名学生的选课门数和平均成绩123select Sno,count(Cno) as '选课门数',avg(Grade) as '平均成绩'from SCgroup by Sno T37.查询选修了3门以上课程的学生的学号1234select Snofrom SCgroup by Snohaving count(Cno)&gt;3 T38.查询选课门数等于或大于4门的学生的平均成绩和选课门数1234select Sno,avg(Grade) as '平均成绩',count(*) as '选课门数'from SCgroup by Snohaving count(*)&gt;=4 四、多表查询T39.查询每个学生的情况及其选课的情况12select *from Student left outer join SC on Student.Sno=SC.Sno T40.查询计算机系学生的选课情况，要求列出学生的名字，所修课的课程号和成绩123select Sname,Cno,Gradefrom Student,SCwhere Student.Sno=Sc.Sno and Sdept='计算机系' T41.查询信息系选修VB课程的学生的成绩，要求列出学生姓名，课程名和成绩123select Sname,Cname,Gradefrom Student,SC,Coursewhere Student.Sno=SC.Sno and SC.Cno=Course.Cno and sdept='信息系' and Cname='VB' 123select Sname,Cname,Grade from Student join SC on Student.Sno=SC.Sno join Course on Course.Cno=SC.Cno where Sdept = '信息系' and Cname = 'VB'; T42.查询所有选修了VB课程的学生的情况，要求列出学生姓名和所在的系123select Sname,Sdeptfrom Student join SC on Student.Sno=SC.Sno join Course on Course.Cno=SC.Cno where Cname='VB' T43.查询与刘晨在同一个系学习的学生的姓名和所在系12345select Sname,Sdeptfrom Studentwhere Sdept=(select Sdept from Student where Sname='刘晨') 123select s2.Sname,s2.Sdeptfrom Student as s1,Student as s2where s1.Sname='刘晨' and s2.Sname !='刘晨' and s1.Sdept=s2.Sdept T44.查询学生的选课情况，包括选修课程的学生和没有修课的学生12select *from Student left join SC on Student.Sno=SC.Sno T45.查询数学系成绩在80分以上的学生的学号，姓名123select Student.Sno,Snamefrom Student join SC on Student.Sno=SC.Snowhere Sdept='数学系' and Grade&gt;80 T46.查询计算机系考试成绩最高的学生的姓名123456select Snamefrom Student join SC on Student.Sno=SC.Snowhere Sdept='计算机系' and Grade=(select max(Grade) from Student join SC on Student.Sno=SC.Sno Group by Sdept having Sdept='计算机系') 五、嵌套子查询(T43) T47.查询成绩大于90分的学生的学号和姓名12345select Sno,Snamefrom Studentwhere Sno in (select Sno from SC where Grade&gt;90) T48.查询选修了“数据库基础”课程的学生的学号和姓名1234567select Sno,Snamefrom Studentwhere Sno in (select Sno from SC where Cno in (select Cno from Course where Cname='数据库基础')) T49.查询选修了刘晨没有选修的课程的学生的学号和所在系123456789select Sno,Sdeptfrom Studentwhere Sno in (select Sno from SC where Cno not in (select Cno from SC where Sno=(select Sno from Student where Sname='刘晨'))) T50.查询选修了课程“c02”且成绩高于此课程的平均成绩的学生的学号和成绩12345select Sno,Gradefrom SCwhere Cno='C02' and Grade&gt;(select avg(Grade) from SC where Cno='C02') T51.查询选修了课程“c01”的学生姓名12345select Snamefrom Studentwhere Sno in (select Sno from SC where Cno='C01') 12345select Snamefrom Studentwhere exists (select * from SC where Sno=Student.Sno and Cno='C01') PS.一般来说，在SQL中in子查询都可以用exists代替。EXISTS子查询可以看成是一个独立的查询系统，只为了获取真假逻辑值，EXISTS子查询与外查询查询的表是两个完全独立的毫无关系的表，当我们在子查询中添加了Sno关联之后，EXISTS子查询与外查询查询的表就统一了，是二者组合组建的虚表，是同一个表（这样当子查询查询到虚表中当前行的Cno为C01时，则将虚表当前行中对应的Sname查询到了）. 重点在于Sno关联之上，添加Sno关联，数据库会先将两张表通过Sno关联组合成一张虚表，所有的查询操作都在这张虚表上完成。 六、自查询T52.查询所有成绩大于C01课程最高成绩的学生的学号12345select SC2.Snofrom SC as SC1,SC as SC2where SC1.Sno=SC2.Sno and SC1.Cno=SC2.Cno and SC2.Grade&gt;all(select Grade from SC where SC.Cno='C01') 七、更新数据T53.将所有学生的年龄加112update Studentset Sage=Sage+1 T54.将“9512101”学生的年龄改为21岁123update Studentset Sage=21where Sno='9512101' T55.将计算机系学生的成绩加5分12345update SCset Grade=Grade+5where Sno in (select Sno from Student where Sdept='计算机系') 八、删除数据T56.删除所有学生的选课记录1DELETE FROM SC T57.删除所有不及格学生的选课记录12delete from SCwhere Grade&lt;60 T58.删除计算机系不及格学生的选课记录1234delete from SCwhere Grade&lt;60 and Sno in (select Sno from Student where Sdept='计算机系') 数据来源于网络，整理@lihui测试代码：建表代码题目代码测试环境：SQL Server 2017 考试结束了，烤糊了😭…附上题目留与后人吧2017-2018学年大连理工大学软件学院数据库考试题目说明 20分 10个选择（比较简单，复习注意概念，比如DBS，DB，DBMS都是什么。其中有两个有关事务的题，即第十二章内容，分别是ACID的四个性质内容和结束事务并回滚的语句是什么问题） 50分 4个关系代数，6个SQL，一个5分。考了not exists和not in 相互转换, not exists…except结构, 标量子查询，分组聚集的内容（懵的一匹@_@） 10分 范式分解 属性闭包和候选码（6分），判断第几范式（2分），BCNF分解（2分） 20分 ER图 画ER图（10分），转换成关系模式（10分）。（回忆版）商店记录商品信息和客户信息，商品信息包括商品编号、名称、单价等，客户信息包括客户编号、客户姓名、电话等。一个顾客可以购买多个商品，一件商品可以购买不同数量，一次性的购物记录在一个购物单里，商品销售时价格可以调整。要求商店可以查询一个客户的消费记录和消费总额。根据题意设计ER图，可以自己添加必要属性。]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【python learning 1】从Hello world!开始（print()函数解析）]]></title>
    <url>%2F2018%2F%E3%80%90python%20learning%E3%80%91hello%20world%2F</url>
    <content type="text"><![CDATA[老规矩，学习一门语言，肯定要从Hello world开始啦 python2print &quot;Hello world!&quot; python3print(&quot;Hello world!&quot;)不同的原因是，在python3中，print只作为一个函数调用，括号中的内容作为函数的参数。 但是，在python2中使用括号也没有问题。 print()函数: print（*objects,sep=&#39; &#39;,end=&#39;\n&#39;,file=sys.stdout,flush=False） 参数意义 *objects 表示要输出的值，可以是多个，用逗号分隔 sep 表示多个输出值之间的间隔，可以自己赋值，默认为一个空格 end 表示输出语句最末尾附加的字符串，默认为’\n’，即换行 #ps: 在Python2中，如果不想换行则在输出语句的末尾加一个逗号，Python3中写成print(“hhh”,end=’’)就好了。 file 表示输出的对象，可以是文件也可以是数据流，默认是sys.stdout flush 表示是否立刻将输出语句输出的目标对象，默认为False]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2Fhello-world%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
