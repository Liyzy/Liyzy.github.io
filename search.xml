<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[僕が死のうと思ったのは]]></title>
    <url>%2F2018%2F10%2F12%2F%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"http://liyzy.oss-cn-qingdao.aliyuncs.com/video/%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.mp4?Expires=1539357355&OSSAccessKeyId=TMP.AQFnxKEZEn4UwzDvB0B7-yyrLmXnOgz7X1aV1zLp1l-1pZTy-sYpz4RTC1GsMC4CFQCp-oxF5K7NzaLMj9t8pOyULNyCDwIVAIBZovFnWHU_wXRn0n4q5Z_z2naj&Signature=QW8ul2bz4ciM1C5Jjl5rek%2FNOFc%3D","pic":"http://pg60us30v.bkt.clouddn.com//image/image-video/%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <tags>
        <tag>music</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java学习笔记】全系列内容提要篇]]></title>
    <url>%2F2018%2F10%2F06%2F%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%85%A8%E7%B3%BB%E5%88%97%E5%86%85%E5%AE%B9%E6%8F%90%E8%A6%81%E7%AF%87%2F</url>
    <content type="text"><![CDATA[【java学习笔记1】基本数据类型对象和类数据声明函数声明参数传递 【java学习笔记2】数组运算符包访问权限修饰符 【java学习笔记3】继承多态 【java学习笔记4】异常处理 【java学习笔记5】抽象类、抽象函数接口 【java学习笔记6】Object类Class类String类System类包装类 【java学习笔记7】泛型 【java学习笔记8】集合类，集合接口Collection类List LinkedList ArrayListMap HashMap TreeMapSet HashSet TreeSet 【java学习笔记9】FileRandomAccessFile文本流Preoperties // 配置文件的使用多线程 【java学习笔记10】线程同步、锁 【java学习笔记11】网络编程 【java学习笔记12】数据库编程 我比较懒，另一方面由于还在上学，时间比较少，慢慢更新~]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双系统安装Ubuntu18.04]]></title>
    <url>%2F2018%2F10%2F01%2F%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[制作启动盘以Ubuntu18.04为例 方式一工具为软碟通UltraISO。 准备一个U盘，格式化。 以管理员身份运行软碟通，菜单栏里选择“启动-&gt;写入硬盘映像”，写入方式选择“usb-HDD+”，“便捷启动-&gt;写入新的驱动程序引导扇区-&gt;Syslinux”。方式二工具为rufus。 这是一个Ubuntu官方推荐的工具，用起来还是很方便的。唯一需要注意的就是选择Partition schema为MBR还是GPT。 查看硬盘分区表类型可以使用windows下的磁盘管理。点击要查看的硬盘，右键，“属性-&gt;卷”就能看到了。还有很多其他的工具可用，不一一赘述了。安装系统 首先，重启电脑进入BIOS，关闭安全启动(如果之前装过双系统的话应该关掉了)，设置第一启动项为U盘启动，设置完成后保存退出。 这时候电脑应该会自动重启，重启之后应该就是Ubuntu的安装引导了，选择Install Ubuntu。 选择语言和键盘布局。 在联网这一项上，选择暂不连接网络，这样可以加快安装的进度，一些东西可以安好系统后自己选择安装。 选择最小安装，其他的不用选。 如果要装双系统，选择与Windows共存就好了，Ubuntu可以自己选择你未分配的空间作为安装空间(前提是你有未分配的空间)。网上的一些教程都交了如何自己分区，非老手且没有什么特殊需求建议不要尝试了，没什么用。如果只保留Ubuntu，选择只保留Ubuntu就好了。 接下来就是一些时区，用户名的设置了。 设置完后，安装就开始了，大约需要30分钟左右吧(当然这要视电脑情况而定qwq)。系统升级如果之前你是16.04或者17.10等其他的版本，也可以升级到18.04版本。(注意提前做好备份，万一装崩了呢/doge) 首先，更新升级已安装的软件包。 1234sudo apt upgradesudo apt updatesudo apt dist-upgradesudo apt autoremove 在软件更新器里选择更新版本为长期支持版本。 安装update-manager-core sudo apt-get install update-manager-core 执行sudo do-release-upgrade -d等待完成就ok了，我大概用了100分钟的时间。安装Gnome插件Ubuntu18.04回归了gnome桌面，意味着我们可以使用很多有用的插件来使它更加的高效和炫酷。如何安装gnome插件呢？网上说了很多方法，有用Tweaks的，有在官网下载后解压的。这些方法首先肯定都没错。但是我一开始也是用的这两种方法进行尝试，然鹅并没有成功。万念俱灰之际，我发现在Ubuntu的软件中心有一个附加组件项，点进去，卧槽，这不就是现成的嘛…推荐几个插件吧：Simple net speed 顶栏实时网速显示Openweather 顶栏显示天气EasyScreenCast 录屏Coverflow alt-tab 效果超赞的 alt-tab 切换效果……更多有趣的插件自己探索吧~]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[词法分析器]]></title>
    <url>%2F2018%2F10%2F01%2F%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[词法分析 In computer science, lexical analysis, lexing or tokenization is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of tokens (strings with an assigned and thus identified meaning).在计算机科学中，词法分析，lexing或标记化是将一系列字符（例如在计算机程序或网页中）转换成一系列标记（具有指定且因此标识的含义的字符串）的过程。 编码目标给定一个源代码文件，能够将其转化为词法记号流。比如规定int的词法记号为30，输出就是&lt;30, int&gt;；数字的词法记号为11，则输入123，输出为&lt;11, 123&gt;。 约定把程序中的词法单元分为四类：标识符（分为关键字和一般标识符）、数字、特殊字符、空白（空格、Tab、回车换行等） 程序流程图对于运算符等符号，这里只考虑两个字符的组合情况，不考虑三个字符组成的运算符。之所以要在读到特殊字符之后在往后读一个字符是因为有可能在表中存在类似&gt;=和&gt;的运算符，要保证最长字符匹配。 关键代码首字符类型判断1234567891011121314151617181920212223public static String getCharType(String str) &#123; String regex_Letter = "[a-zA-Z]"; String regex_Number = "[0-9]"; String regex_Blank = "\\s"; Pattern pattern; pattern = Pattern.compile(regex_Letter); Matcher matcher = pattern.matcher(str); if (matcher.find()) return "LETTER"; pattern = Pattern.compile(regex_Number); matcher = pattern.matcher(str); if (matcher.find()) return "NUMBER"; pattern = Pattern.compile(regex_Blank); matcher = pattern.matcher(str); if (matcher.find()) return "BLANK"; return "SPECIAL"; &#125; 如果首字符为字母123456789101112131415case "LETTER": pattern = Pattern.compile(regex_ID); matcher = pattern.matcher(srcCode); if (matcher.lookingAt()) &#123; String result = matcher.group(); if (LexicalToken.isKeyWord(result)) &#123; int token = lextok.getToken(result); System.out.printf("&lt;%d,%s&gt; ", token, result); &#125; else &#123; int token = lextok.getToken("ID"); System.out.printf("&lt;%d,%s&gt; ", token, result); &#125; &#125; srcCode = srcCode.substring(matcher.end()); break; 如果首字符是数字12345678910case "NUMBER": pattern = Pattern.compile(regex_NUM); matcher = pattern.matcher(srcCode); if (matcher.lookingAt()) &#123; String result = matcher.group(); int token = lextok.getToken("NUM"); System.out.printf("&lt;%d,%s&gt; ", token, result); &#125; srcCode = srcCode.substring(matcher.end()); break; 如果首字符是空格123case "BLANK": srcCode = srcCode.substring(1); break; 如果首字符是特殊符号1234567891011121314151617181920212223case "SPECIAL": if (srcCode.length() &gt; 1) &#123; String secondChar = srcCode.substring(1, 2); String result; LinkedHashMap tokenMap = lextok.getLexicalTokenMap(); Set set = tokenMap.keySet(); result = firstChar + secondChar; if (getCharType(secondChar).equals("SPECIAL") &amp;&amp; set.contains(result)) &#123; int token = lextok.getToken(result); System.out.printf("&lt;%d,%s&gt; ", token, result); srcCode = srcCode.substring(2); &#125;else &#123; result = firstChar; int token = lextok.getToken(result); System.out.printf("&lt;%d,%s&gt; ", token, result); srcCode = srcCode.substring(1); &#125; &#125; else &#123; // 字符串中只有一个字符时 int token = lextok.getToken(srcCode); System.out.printf("&lt;%d,%s&gt; ", token, srcCode); srcCode = srcCode.substring(1); &#125; break; 源码地址：https://github.com/Liyzy/Lexer开发环境：IJ idea 2018.2]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双系统卸载]]></title>
    <url>%2F2018%2F09%2F23%2F%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%8D%B8%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[本文主要针对windows+Linux双系统卸载Linux/Unix系统(Ubuntu\Deepin...)。 删除系统在windows上，右键开始打开磁盘管理(或者直接搜索“磁盘管理”)，看到装有Linux系统的硬盘分区，右键删除卷，删除后分区变为“未分配”。如果不安装新的系统，可以“新建简单卷”；如果还要安装别的系统，就暂不处理。 如果之前Linux/Unix系统是第一启动项，那么这时候你重启计算机的话是会出现错误的，因为引导找不到这个系统了。而且，在BIOS的启动项里还存在着这个系统。这时我们就要修复引导。 修复引导我们用到一个工具：EasyUEFI 下个试用版就OK。运行EasyUEFI，选择“管理EFI启动项”，可以看到你要卸载的系统的启动项，选中，选择“删除选中项”。之后在进入BIOS查看启动项，发现只剩下一个windows的启动项了，成功！]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【python学习笔记1】数据类型篇]]></title>
    <url>%2F2018%2F09%2F22%2F%E3%80%90python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%91%2F</url>
    <content type="text"><![CDATA[python简单介绍 作为一种解释型语言，Python的设计哲学强调代码的可读性和简洁的语法（尤其是使用空格缩进划分代码块，而非使用大括号或者关键词）。与Scheme、Ruby、Perl、Tcl等动态类型编程语言一样，Python拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。其本身拥有一个巨大而广泛的标准库。Python是完全物件导向的语言。函数、模组、数字、字串都是物件。并且完全支持继承、重载、派生、多重继承，有益于增强原始码的复用性。Python支持重载运算符，因此Python也支持泛型设计。Python编译器本身也可以被集成到其它需要脚本语言的程式内。因此，有很多人把Python作为一种“胶水语言”使用。使用Python将其他语言编写的程式进行集成和封装。Python属于动态类型语言，动态类型语言是在运行期间检查数据的类型，不得不保持描述变量值的实际类型标记，程序在每次操作变量时，需要执行数据依赖分支，而静态类型语言相对于动态类型语言，在声明变量时已经指定了数据类型和表示方法，根据这一原理导致Python相对于C、Visual Basic等静态类型语言来说运行速度较慢。 摘录自Wikipedia python数据类型常量python中没有关键字表示常量，用大写来代表这是一个常量。例如NUM=5，NUM就是一个常量。因此，在编写python代码时，要严格区分大小写。 变量python中变量声明不需要声明变量类型。但是，python是一种强类型语言，不能因此而判断python是弱类型的。python是动态的、强类型的语言。Why is Python a dynamic language and also a strongly typed language？ 数据类型分为两大类：内置数据类型、自定义数据类型内置数据类型分为：数值、序列、集合、字典、特殊、其他数值数据类型：整数、浮点数、布尔、复数序列数据类型：字符串、元组、字节序列、列表、字节数组集合数据类型：集、不可变集 内置的type()函数可以用来查询变量所指的对象类型123&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))&lt;type 'int'&gt; &lt;type 'float'&gt; &lt;type 'bool'&gt; &lt;type 'complex'&gt; int类型12345myInt = 5 myInt = int(5) #int对象方式int(5.4) #自动类型转换int("123") #自动类型转换#二进制以0b开头，八进制以0开头，十六进制以0x开头 float类型12myFloat = float(3.14)myFloat = float(4) #自动类型转换，输出结果4.0 复数数据类型 虚部必须用j1234561+1j #不可写成1+j0+0j #0不能省略complex(1,2) #其中1为实部，2为虚部c1=complex(6) #输出c1为6+0j,等同于complex(6,0) complex(6,)c2=complex(2.1,3.2) #实部与虚部可以为浮点数#real:复数的实部 imag:复数的虚部 c2.real输出结果2.1,c2.imag输出结果3.2 bool类型12345"""True False开头首字母必须大写bool对象 bool(False)bool(0),bool(0.0) 结果为False,任何非零均为True例如 bool('0'),bool(5),bool(2.3),bool("abc")""" String类型表现形式&quot;abc&quot; &#39;abc&#39; &#39;&#39;&#39;abc&#39;&#39;&#39; &quot;&quot;&quot;abc&quot;&quot;&quot; 前两个表示一行，后两个表示可以跨行 字符串拼接与重复123456&gt;&gt;&gt; "abc"+'def' #使用+进行字符串连接'abcdef'&gt;&gt;&gt; "abc" 'def' #默认自动连接'abcdef'&gt;&gt;&gt; "abc"*2 # *表示重复，*后的整数表示重复次数'abcabc' 转义字符 转义字符 含义 \n 换行 \r 回车 \t 水平制表符 \v 垂直制表符 \b 退格 \f 换页 使用r或R为开头的字符串成为原始字符串，其中包含的任何字符都不可进行转义。123&gt;&gt;&gt; myStr = r"abc\n"&gt;&gt;&gt; print(myStr)'abc\n' str对象str()str(.14) 输出结果为 ‘0.14’ ，浮点数前导0可省略,隐式类型转换。 字符串索引Python中的字符串有两种索引方式，第一种是从左往右，从0开始依次增加；第二种是从右往左，从-1开始依次减少。注意，没有单独的字符类型，一个字符就是长度为1的字符串。12345&gt;&gt;&gt; word = 'Python'&gt;&gt;&gt; print(word[0], word[5])P n&gt;&gt;&gt; print(word[-1], word[-6])n P 字符串截取子串用冒号分隔两个索引，形式为变量[头下标:尾下标]。截取的范围是前闭后开的，并且两个索引都可以省略：123456789&gt;&gt;&gt; word = 'ilovepython'&gt;&gt;&gt; word[1:5]'love'&gt;&gt;&gt; word[:]'ilovepython'&gt;&gt;&gt; word[5:]'python'&gt;&gt;&gt; word[-10:-6]'love' Python字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。 列表列表的创建方式字面量[x1,x2,x3,x4,…,xn]列表中元素类型可以不同，如[1, 2, 3, ‘q’, True]列表中的元素可以是表达式，如123x = 1temp = [x + x, x * x, 11]list = [[1,2,3,4],[5,6,7],8] 对象123list1 = list() #空列表list2 = list("abcd") #结果['a', 'b', 'c', 'd']list3 = list(range(3)) #结果[0, 1, 2] 推导式使用非常简单的表达式满足特定的列表表达式 for 变量 in 序列123list4 = [x*x for x in range(1,10)]print(list4) #结果[1, 4, 9, 16, 25, 36, 49, 64, 81]list5 = [i for i in list4 if i%2==0] #结果[4, 16, 36, 64] 列表的操作列表的操作包括：索引、切片、连接、重复、成员关系、比较、求长度、最大值、最小值等 索引访问123list6 = [1, 2, 3]print(list6[0], list6[-1]) #结果１ ３list6[0] = 10 #list中的值可以改变，此时list6为[10, 2, 3] 删除列表中的元素12list7 = [1,2,3,4,5] #[1,2,3,4,5]del list7[1] #[1,3,4,5] 求长度、最大值、最小值、和1234567891011121314151617181920list８ = [1,2,3,4,5,6] #[1,2,3,4,5,6]len(list8) #6min(list8) #1max(list8) #6sum(list8) #21list9 = [1,2,3,4,'a',5]len(list9) #6max(list9) #TypeError: unorderable types: str() &gt; int(), min和sum同样错误。list10 = ['a', 'b', 'c'] #可以算len,max,min，但不能求和# python 2.7.15中测试结果如下&gt;&gt;&gt; list1 = [1,2,3,4,5,'a', 6]&gt;&gt;&gt; max(list1)'a'&gt;&gt;&gt; min(list1)1&gt;&gt;&gt; sum(list1)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: unsupported operand type(s) for +: 'int' and 'str' 切片s[i:j] 从索引i开始，到j结束，左闭右开。省略i从0开始，省略j到结尾结束s[i:j:k] k表示步长1234list1 = [1, 2, 3, 4, 5, 6, 7]temp = list1[1:6:2]print(temp) # 结果[2, 4, 6]list1[:1] = [] # list1变为[2,3,4,5,6,7] 连接与重复连接+ 重复*12345list2 = [1,2,3]list3 = [3,4,5]print(list2+list3) # 结果[1, 2, 3, 3, 4, 5],只连接不去重print(2*list2) # 结果[1, 2, 3, 1, 2, 3]list2 += list3 # 结果[1, 2, 3, 3, 4, 5],等价于list2 = list2 + list3 成员关系操作判断一个元素是否在列表中in 和not in12345list1 = [1, 4, 3, 3, 2, 2, 3]print(7 in list1) # Falseprint(3 in list1) # Trueprint(list1.count(3)) # 3 计算某一个元素在列表中出现的次数print(list1.index(3, 2, 6)) # 2 查找某个元素在给定范围内第一次出现的索引,例子中范围为[2,6) 比较运算12345678list1 = ['a', 'b']list2 = ['a', 'b']list3 = ['a', 'b', 'c']list4 = ['c', 'b', 'a']print(list1 == list2) # Trueprint(list3 &gt; list2) # Trueprint(list3 &gt; list4) # False# 从第一个元素开始比较 列表的排序sorted(list1)) any()和all()any() 列表中是否有元素为Trueall() 列表中的元素是否都为True 列表的拆分1234list1 = [1,2,3,4]a,b,c,d = list1print(a,b,c,d) # 结果１ ２ ３ ４# 应保证前面的变量数与列表的长度相同 元组定义与声明定值表，用来存储不变值表123456789t = 1,2,3,4 # 表示元组t = (1,2,3,4) # 表示元组t = () # 表示空元组t = 1, # 表示只有一个元素的元组，必须有逗号t = tuple(1,2,3,4) # 错误写法，只能有一个参数t = tuple([1,2,3,4])# 正确写法t = tuple("abcd") # 结果为（'a','b','c','d'）t = tuple(range(8)) t = tuple(2*x for x in range(1,5)) # 结果为(2,4,6,8) 元组的操作索引访问、切片、连接、重复、成员关系、最大值、最小值、和、长度、排序等与列表的操作类似，可以进行对比。一些内容不作赘述。 元组的排序123456789tuple1 = tuple([2,1,9,5,4,6])print(tuple1)print(sorted(tuple1))print(tuple1)# 结果为(2, 1, 9, 5, 4, 6)[1, 2, 4, 5, 6, 9] # 输出的是列表(2, 1, 9, 5, 4, 6) # 原元组没有变化 元组的拆分123456789a, *s, d, f = tuple1 print(a, d, f) # 结果为 2 4 6a, s, d, *f = tuple1print(a, s, d) # 结果为 2 1 9# 元组的拆分前面变量的个数必须与元组元素个数相等。如果元组元素个数过多，可以使用*代表多个变量_, a, b, _, *_ = tuple1print(a, b, _) # 结果为 1 9 [4, 6]# 没有意义的命名可以使用临时变量下划线(_)表示。输出临时变量，只会保留最后一个。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用ZXing工具生成二维码以及解析二维码]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%88%A9%E7%94%A8ZXing%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%BB%A5%E5%8F%8A%E8%A7%A3%E6%9E%90%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一、 二维码生成原理（即工作原理）二维码官方叫版本Version。Version 1是21 x 21的矩阵，Version 2是 25 x 25的矩阵，Version 3是29的尺寸，每增加一个version，就会增加4的尺寸，公式是：(V-1)4 + 21（V是版本号） 最高Version 40，(40-1)4+21 = 177，所以最高是177 x 177 的正方形。 下面是一个二维码的样例： 1、定位图案 Position Detection Pattern是定位图案，用于标记二维码的矩形大小。这三个定位图案有白边叫Separators for Postion Detection Patterns。之所以三个而不是四个意思就是三个就可以标识一个矩形了。 Timing Patterns也是用于定位的。原因是二维码有40种尺寸，尺寸过大了后需要有根标准线，不然扫描的时候可能会扫歪了。 Alignment Patterns 只有Version 2以上（包括Version2）的二维码需要这个东东，同样是为了定位用的。 2、功能性数据 Format Information 存在于所有的尺寸中，用于存放一些格式化数据的。 Version Information 在 &gt;= Version 7以上，需要预留两块3 x 6的区域存放一些版本信息。 数据码和纠错码 除了上述的那些地方，剩下的地方存放 Data Code 数据码 和 Error Correction Code 纠错码。 3、数据编码 QR码支持如下的编码： Numeric mode 数字编码，从0到9。如果需要编码的数字的个数不是3的倍数，那么，最后剩下的1或2位数会被转成4或7bits，则其它的每3位数字会被编成 10，12，14bits，编成多长还要看二维码的尺寸（下面有一个表Table 3说明了这点） Alphanumeric mode 字符编码。包括 0-9，大写的A到Z（没有小写），以及符号$ % * + – . / : 包括空格。这些字符会映射成一个字符索引表。如下所示：（其中的SP是空格，Char是字符，Value是其索引值） 编码的过程是把字符两两分组，然后转成下表的45进制，然后转成11bits的二进制，如果最后有一个落单的，那就转成6bits的二进制。而编码模式和 字符的个数需要根据不同的Version尺寸编成9, 11或13个二进制（如下表中Table 3） Byte mode, 字节编码，可以是0-255的ISO-8859-1字符。有些二维码的扫描器可以自动检测是否是UTF-8的编码。 Kanji mode 这是日文编码，也是双字节编码。同样，也可以用于中文编码。日文和汉字的编码会减去一个 值。如：在0X8140 to 0X9FFC中的字符会减去8140，在0XE040到0XEBBF中的字符要减去0XC140，然后把前两位拿出来乘以0XC0，然后再加上后两位，最 后转成13bit的编码。如下图示例： Extended Channel Interpretation (ECI) mode 主要用于特殊的字符集。并不是所有的扫描器都支持这种编码。 Structured Append mode 用于混合编码，也就是说，这个二维码中包含了多种编码格式。 FNC1 mode 这种编码方式主要是给一些特殊的工业或行业用的。比如GS1条形码之类的。 简单起见，后面三种不会在本文 中讨论。 下面两张表中， Table 2 是各个编码格式的“编号”，这个东西要写在Format Information中。注：中文是1101 Table 3 表示了，不同版本（尺寸）的二维码，对于，数字，字符，字节和Kanji模式下，对于单个编码的2进制的位数。（在二维码的规格说明书中，有各种各样的编码规范表，后面还会提到） 示例一：数字编码 在Version 1的尺寸下，纠错级别为H的情况下，编码： 01234567 把上述数字分成三组: 012 345 67 把他们转成二进制: 012 转成 0000001100； 345 转成 0101011001； 67 转成 1000011。 把这三个二进制串起来: 0000001100 0101011001 1000011 把数字的个数转成二进制 (version 1-H是10 bits ): 8个数字的二进制是 0000001000 把数字编码的标志0001和第4步的编码加到前面: 0001 0000001000 0000001100 0101011001 1000011 示例二：字符编码 在Version 1的尺寸下，纠错级别为H的情况下，编码: AC-42 从字符索引表中找到 AC-42 这五个字条的索引 (10,12,41,4,2) 两两分组: (10,12) (41,4) (2) 3.把每一组转成11bits的二进制: (10,12) 10*45+12 等于 462 转成 00111001110 (41,4) 41*45+4 等于 1849 转成 11100111001 (2) 等于 2 转成 000010 把这些二进制连接起来：00111001110 11100111001 000010 把字符的个数转成二进制 (Version 1-H为9 bits ): 5个字符，5转成 000000101 在头上加上编码标识 0010 和第5步的个数编码: 0010 000000101 00111001110 11100111001 000010 结束符和补齐符 假如我们有个HELLO WORLD的字符串要编码，根据上面的示例二，我们可以得到下面的编码， 编码 字符数 HELLO WORLD的编码 0010 000001011 01100001011 01111000110 10001011100 10110111000 10011010100 001101 我们还要加上结束符： 编码 字符数 HELLO WORLD的编码 结束 0010 000001011 01100001011 01111000110 10001011100 10110111000 10011010100 001101 0000 按8bits重排 如果所有的编码加起来不是8个倍数我们还要在后面加上足够的0，比如上面一共有78个bits，所以，我们还要加上2个0，然后按8个bits分好组： 00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 补齐码（Padding Bytes） 最后，如果如果还没有达到我们最大的bits数的限制，我们还要加一些补齐码（Padding Bytes），Padding Bytes就是重复下面的两个bytes：11101100 00010001 （这两个二进制转成十进制是236和17，我也不知道为什么，只知道Spec上是这么写的）关于每一个Version的每一种纠错级别的最大Bits限 制，可以参看QR Code Spec的第28页到32页的Table-7一表。 假设我们需要编码的是Version 1的Q纠错级，那么，其最大需要104个bits，而我们上面只有80个bits，所以，还需要24个bits，也就是需要3个Padding Bytes，我们就添加三个，于是得到下面的编码： 00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 11101100 00010001 11101100 纠错码 上面我们说到了一些纠错级别，Error Correction Code Level，二维码中有四种级别的纠错，这就是为什么二维码有残缺还能扫出来，也就是为什么有人在二维码的中心位置加入图标。 错误修正容量 L水平 7%的字码可被修正 M水平 15%的字码可被修正 Q水平 25%的字码可被修正 H水平 30%的字码可被修正 那么，QR是怎么对数据码加上纠错码的？首先，我们需要对数据码进行分组，也就是分成不同的Block，然后对各个Block进行纠错编码，对于如何分组，我们可以查看QR Code Spec的第33页到44页的Table-13到Table-22的定义表。注意最后两列： Number of Error Code Correction Blocks ：需要分多少个块。 Error Correction Code Per Blocks：每一个块中的code个数，所谓的code的个数，也就是有多少个8bits的字节。 举个例子：上述的Version 5 + Q纠错级：需要4个Blocks（2个Blocks为一组，共两组），头一组的两个Blocks中各15个bits数据 + 各 9个bits的纠错码（注：表中的codewords就是一个8bits的byte）（再注：最后一例中的（c, k, r ）的公式为：c = k + 2 * r，因为后脚注解释了：纠错码的容量小于纠错码的一半） 对每个块的纠错码 1 1 67 85 70 134 87 38 85 194 119 50 6 18 6 103 38 213 199 11 45 115 247 241 223 229 248 154 117 154 111 86 161 111 39 2 246 246 66 7 118 134 242 7 38 86 22 198 199 146 6 87 204 96 60 202 182 124 157 200 134 27 129 209 17 163 163 120 133 2 1 182 230 247 119 50 7 118 134 87 38 82 6 134 151 50 7 148 116 177 212 76 133 75 242 238 76 195 230 189 10 108 240 192 141 2 70 247 118 86 194 6 151 50 16 236 17 236 17 236 17 236 235 159 5 173 24 147 59 33 106 40 255 172 82 2 131 32 178 236 注：二维码的纠错码主要是通过Reed-Solomon error correction（里 德-所罗门纠错算法）来实现的。对于这个算法，对于我来说是相当的复杂，里面有很多的数学计算，最终编码。 穿插放置 二维码的混乱技术还没有玩完，它还要把数据码和纠错码的各个codewords交替放在一起。如何交替呢，规则如下： 对于数据码：把每个块的第一个codewords先拿出来按顺度排列好，然后再取第一块的第二个，如此类推。如：上述示例中的Data Codewords如下： 块 1 67 85 70 134 87 38 85 194 119 50 6 18 6 103 38 块 2 246 246 66 7 118 134 242 7 38 86 22 198 199 146 6 块 3 182 230 247 119 50 7 118 134 87 38 82 6 134 151 50 7 块 4 70 247 118 86 194 6 151 50 16 236 17 236 17 236 17 236 我们先取第一列的：67， 246， 182， 70 然后再取第二列的：67， 246， 182， 70， 85，246，230 ，247 如此类推：67， 246， 182， 70， 85，246，230 ，247 ……… ……… ，38，6，50，17，7，236 对于纠错码，也是一样： 块 1 213 199 11 45 115 247 241 223 229 248 154 117 154 111 86 161 111 39 块 2 87 204 96 60 202 182 124 157 200 134 27 129 209 17 163 163 120 133 块 3 148 116 177 212 76 133 75 242 238 76 195 230 189 10 108 240 192 141 块 4 235 159 5 173 24 147 59 33 106 40 255 172 82 2 131 32 178 236 和数据码取的一样，得到：213，87，148，235，199，204，116，159，…… …… 39，133，141，236 然后，再把这两组放在一起（纠错码放在数据码之后）得到： 67, 246, 182, 70, 85, 246, 230, 247, 70, 66, 247, 118, 134, 7, 119, 86, 87, 118, 50, 194, 38, 134, 7, 6, 85, 242, 118, 151, 194, 7, 134, 50, 119, 38, 87, 16, 50, 86, 38, 236, 6, 22, 82, 17, 18, 198, 6, 236, 6, 199, 134, 17, 103, 146, 151, 236, 38, 6, 50, 17, 7, 236, 213, 87, 148, 235, 199, 204, 116, 159, 11, 96, 177, 5, 45, 60, 212, 173, 115, 202, 76, 24, 247, 182, 133, 147, 241, 124, 75, 59, 223, 157, 242, 33, 229, 200, 238, 106, 248, 134, 76, 40, 154, 27, 195, 255, 117, 129, 230, 172, 154, 209, 189, 82, 111, 17, 10, 2, 86, 163, 108, 131, 161, 163, 240, 32, 111, 120, 192, 178, 39, 133, 141, 236 Remainder Bits 最后再加上Reminder Bits，对于某些Version的QR，上面的还不够长度，还要加上Remainder Bits，比如：上述的5Q版的二维码，还要加上7个bits，Remainder Bits加零就好了。关于哪些Version需要多少个Remainder bit，可以参看QR Code Spec的第15页的Table-1的定义表。 4、画二维码图 Position Detection Pattern 首先，先把Position Detection图案画在三个角上。 Alignment Pattern 然后，再把Alignment图案画上 关于Alignment的位置，可以查看QR Code Spec的第81页的Table-E.1的定义表（下表是不完全表格） 下图是根据上述表格中的Version8的一个例子（6，24，42） Timing Pattern 接下来是Timing Pattern的线（这个不用多说了） Format Information 再接下来是Formation Information，下图中的蓝色部分。 Format Information是一个15个bits的信息，每一个bit的位置如下图所示：（注意图中的Dark Module，那是永远出现的） 这15个bits中包括： 5个数据bits：其中，2个bits用于表示使用什么样的Error Correction Level， 3个bits表示使用什么样的Mask 10个纠错bits。主要通过BCH Code来计算 然后15个bits还要与101010000010010做XOR操作。这样就保证不会因为我们选用了00的纠错级别，以及000的Mask，从重造成全部为白色，这会增加我们的扫描器的图像识别的困难。 下面是一个示例： 关于Error Correction Level如下表所示： 关于Mask图案如后面的Table 23所示。 Version Information 再接下来是Version Information（版本7以后需要这个编码），下图中的蓝色部分。 Version Information一共是18个bits，其中包括6个bits的版本号以及12个bits的纠错码，下面是一个示例： 而其填充位置如下： 数据和数据纠错码 然后是填接我们的最终编码，最终编码的填充方式如下：从左下角开始沿着红线填我们的各个bits，1是黑色，0是白色。如果遇到了上面的非数据区，则绕开或跳过。 5、掩码图案 这样下来，图就填好了，但是，也许那些点并不均衡，所以还要做Masking操作QR的Spec中说了，QR有8个 Mask可以使用，如下所示：其中，各个mask的公式在各个图下面。所谓mask，说白了，就是和上面生成的图做XOR操作。Mask只会和数据区进 行XOR，不会影响功能区。 其Mask的标识码如下所示：（其中的i,j分别对应于上图的x,y） Mask过后的二维码就成最终的图了。 （以上内容来源于网络） 二、 编码实现首先，我们需要下载Google的ZXing库。下载地址：https://github.com/zxing/zxing 根据内容创建二维码12345678910111213141516171819202122232425262728293031/** * TODO 根据给定的内容生成二维码 * * @param content 二维码内容 * @param logoImagePath logo图标的路径 * @param needCompressed 是否需要压缩logo * @return 生成的二维码 * @throws IOException * @throws WriterException */private static BufferedImage createImage(String content, String logoImagePath, boolean needCompressed) throws IOException, WriterException &#123; HashMap hints = new HashMap&lt;EncodeHintType, Object&gt;(); hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); // 纠错等级 hints.put(EncodeHintType.CHARACTER_SET, CHARSET); hints.put(EncodeHintType.MARGIN, 1); // 二维码两边空白区域大小 BitMatrix bitMatrix = new MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, QRCODE_SIZE, QRCODE_SIZE, hints); int height = bitMatrix.getHeight(); int width = bitMatrix.getWidth(); BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); for (int x = 0; x &lt; width; x++) for (int y = 0; y &lt; height; y++) image.setRGB(x, y, bitMatrix.get(x, y) ? 0xFF000000 : 0xFFFFFFFF); if (logoImagePath == null || "".equals(logoImagePath)) return image; // 如果有logo，则插入logo图片 QRCode.InsertImage(image, logoImagePath, needCompressed); return image; &#125; 如果有logo则将logo插入到二维码中1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * TODO 插入logo图片 * @param sourceImage 原图片 * @param logoImagePath logo图片所在的路径 * @param needCompressed 是否需要压缩 * @throws IOException */ private static void InsertImage(BufferedImage sourceImage, String logoImagePath, boolean needCompressed) throws IOException &#123; File file = new File(logoImagePath); if (!file.exists())&#123; System.out.println("logo文件不存在！\n"); return; &#125; Image src = ImageIO.read(file); int width = src.getWidth(null); int height = src.getHeight(null); // 压缩二维码图片 if (needCompressed) &#123; if (width &gt; LOGO_WIDTH) width = LOGO_WIDTH; if (height &gt; LOGO_HEIGHT) height = LOGO_HEIGHT; Image image = src.getScaledInstance(width, height, Image.SCALE_SMOOTH); BufferedImage tag = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = tag.getGraphics(); g.drawImage(image, 0, 0, null); g.dispose(); // 释放占有的资源 src = image; // 直观的理解：Graphics2D 就相当于画笔，而BufferedImage 就是画笔绘制的结果。 &#125; // 插入logo Graphics2D graph = sourceImage.createGraphics(); int x = (QRCODE_SIZE - width) / 2; int y = (QRCODE_SIZE - height) / 2; graph.drawImage(src, x, y, width, height, null); Shape shape = new RoundRectangle2D.Float(x, y, width, width, 6, 6); graph.setStroke(new BasicStroke(3f)); graph.draw(shape); graph.dispose(); &#125; 解码过程1234567891011121314151617181920/** * TODO 解析二维码内容 * @param file 二维码 * @return 二维码包含的信息 * @throws Exception */ public static String decode(File file) throws Exception &#123; BufferedImage image; image = ImageIO.read(file); if (image == null) &#123; return null; &#125; BufferedImageLuminanceSource source = new BufferedImageLuminanceSource(image); BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source)); HashMap hints = new HashMap&lt;DecodeHintType, Object&gt;(); hints.put(DecodeHintType.CHARACTER_SET, CHARSET); Result result = new MultiFormatReader().decode(bitmap, hints); String resultStr = result.getText(); return resultStr; &#125; 测试结果源码下载地址：https://github.com/Liyzy/ZXing-QRCode开发环境：idea 2018.2]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java学习笔记3】继承&多态篇]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%91%2F</url>
    <content type="text"><![CDATA[继承 关键字extends表示继承，继承是一个is-a关系，java中只有公有继承 覆盖方法（override）将父类中的方法在子类中重新定义，以Employee类和Manager类为例，Manager继承Employee类，Employee有方法getSalary(); Manager类需要重写这个方法，加上经理所特有的奖金。 123456789101112131415161718public class Employee&#123; private double salary; ... public double getSalary()&#123; return salary; &#125;&#125;public class Manager extends Employee&#123; private double bonus; ... public double getSalary()&#123; //return salary + bonus; // 错误，不能访问超类的私有域 //return getSalary() + bonus; // 错误，调用自身直至崩溃 return super.getSalary() + bonus; // 正确 &#125;&#125;//super关键字表示调用父类的方法 子类构造器必须调用父类的构造器，并且应将这一过程放在程序的第一句 1234public Manager(String name, String id, double salary)&#123; super(name, id, salary); // 置于第一句，如果没有这句，系统自动调用父类的默认构造函数；如果没有默认构造函数有没有显式调用其他构造器就会产生错误 bonus = 0;&#125; java不支持多继承，即每一个类都只能继承最多一个类。但每一个类可以实现多个接口，这也是引入接口的一个考虑。 多态java实现多态的两种方式：重载(overloading)和覆盖(override)1234567891011121314151617181920212223242526/* override */Manager boss = new Manager("lihui", 201822, 50000);boss.setBonus(20000);Empolyee[] staff = new Empolyee[2];staff[0] = boss;staff[1] = new Employee("chengle", 201833, 60000);staff[0].setBonus(20000); // 错误，staff声明为Employee类型，Employee没有setBonus方法if(staff[0] instanceof Manager) ((Manager)staff[0]).setBonus(20000); // 正确，将staff[0]强制转换为Manager类型 for(Employee aEmpolyee: staff) System.out.println(aEmpolyee.getName() + " " + aEmpolyee.getSalary());// aEmpolyee定义为Empolyee类型，但在执行的时候，aEmpolyee引用的Empolyee和Manager调用不同的getSalary函数// 一个对象变量可以指示多种实际类型的现象称为多态。// 在运行的时候自动选择调用哪个方法称为动态绑定。/* overloading */public class Manager&#123; ... public double getSalary(String name)&#123;...&#125; public float getSalary(String name)&#123;...&#125; //错误，已经存在getSalary(String name)方法,即签名相同，说明重载与返回值无关 public double getSalary(String name, String id)&#123;...&#125; //正确的重载&#125; 方法的签名：方法的名字和参数列表称为方法的签名，返回类型不是签名的一部分。 override的规则： 子类覆盖父类中具有相同签名的方法。 返回类型是被重写方法的返回类型的子类型。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static、private、final的方法不能被重写。(private的方法本身就被定义成了final的) 构造器不能被重写。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 overloading的规则：方法名相同，参数列表必须不同，返回值可同可不同，修饰符可同可不同。 方法调用的过程1）假设调用x.f(param), 编译器一一列举x所属类中的名为f的方法以及其父类中访问属性为public的名为f的方法（超类的私有方法不可访问）。2）查看调用方法提供的参数类型。如果第一步中列举出的方法中有一个方法的参数列表与提供的参数类型完全匹配，就选择这个方法。如果没有找到与参数类型匹配的方法或者经过类型转换后有多个方法与之匹配，就会产生错误。3）如果是static、private、final方法或者构造器，编译器可以准确的知道应该调用哪个方法，静态绑定。4）动态绑定时，先查看子类中是否定义了这个方法，是则调用，否则调用父类的这个方法。 final修饰符定义类的时候加上final修饰符表示类不允许被继承，其中的方法自动的成为final，但是域不会变成final。一个方法或者一个域也可以加上final表示不可被覆盖或者不可改变域的值。 抽象类关键字abstract表示抽象类，包含有一个或多个抽象函数的类需要声明为抽象类（为了代码清晰），抽象类里的抽象方法不需要实现，在子类中对其进行实现。]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java学习笔记2】数组&运算符&权限篇]]></title>
    <url>%2F2018%2F07%2F08%2F%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E3%80%91%2F</url>
    <content type="text"><![CDATA[数组 运算符 包 访问权限 修饰符 数组1. 数组的声明：int[] a; 2. 数组的创建使用new运算符数组的创建int[] a = new int[100] 数组的长度不要求是常量：new int[n]会创建一个长度为n的数组 3. 数组的初始化可以使用for循环进行赋值，或者直接int[] a = {1, 2, 3}进行赋值；数组创建时，数字数组所有元素初始化为0，Boolean数组所有元素初始化为false，对象数组则初始化为null值。 4. 数组长度每一个数组都有成员属性length，使用a.length获得数组a的长度 5. 数组的遍历输出 a. 传统for循环12for(int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); b. for each循环123for(int element : a) System.out.print(element + " ");//对于在for循环语句中需要使用元素下标的程序来说不合适 c. 利用Arrays类的toString方法12System.out.println(Arrays.toString(a));//a为数值型的数组或Boolean数组 6. 数组拷贝12int[] b = a; //b和a引用同一个数组b[1] = 7; //此时访问a[1]也是7 如果希望把一个数组的所有值拷贝到一个新的数组,使用Arrays类的copyOf方法1int[] b = Arrays.copyOf(a, a.length); 第二个参数表示新数组的长度，比原数组长，则多余的元素被赋值为0或者false或者null，比原数组短，则只复制前面的对应长度的元素。方法Arrays.copyOfRange(type[] a, int start, int end)type为int, short, byte, long, double, float, Boolean 类型 7. 数组排序1Arrays.sort(a); //使用优化的快速排序 8. 多维数组多维数组创建123int[][] a = new int[2][3]; //正确int[][] b = new int[2][]; //正确, 第二维的长度可以动态申请，可以不同int[][] c = new int[][3]; //错误 多维数组遍历12345678910111213141516int[][] b = new int[2][];for (int i = 0; i &lt; b.length; i++) &#123; b[i] = new int[i + 1]; for (int j = 0; j &lt; b[i].length; j++) b[i][j] = i + j;&#125;//第一种方式for(int i = 0; i &lt; a.length; i++) for(int j = 0; j &lt; a[i].length) System.out.print(a[i][j] + " ");//第二种方式for (int[] row : b) for (int value : row) System.out.print(value + " ");//第三种方式System.out.println(Arrays.deepToString(b)); 多维数组的每一行是可以通过引用进行交换的。 运算符除法12345float a = 12.3f;int b = 5;a = a / 0; //得到Infinity或者NaNb = b / 0; //除零异常System.out.println(a); 取模123456789int a = 5;int b = -5;a = a % 3;b = b % 3;System.out.println(a + "," + b); //2,-2a = a % -3;b = b % -3;System.out.print(a + "," + b); //2,-2/*求模运算的结果与左操作数符号相同，与右操作数符号无关*/ 算术运算的结果不低于int型12345678byte a = 3;byte b = 2;b = a + b; //错误，a+b返回int型，int不能赋值给byteb = (byte)(a + b); //正确，强制转换b += a; //正确，b += a等价于b = (byte)(b + a)int c = 7;c = c + 5.2; //错误c += 5.2; //正确 虚箭头表示可能有精度损失的转换，实箭头表示无信息丢失的转换。 基本数据类型的数组之间不能相互赋值，因为java中数组是类。 移位运算&lt;&lt;左移，低位补0，移位中可能会出现符号变换&gt;&gt;右移，高位补符号位&gt;&gt;&gt;无符号右移，高位补01234int a = 5;// a &gt;&gt; 33等价于a &gt;&gt; 1，移的位数和数值类型的位数取模byte b = 5;// b &gt;&gt; 33等价于b &gt;&gt; 1,在b &gt;&gt; 33操作中，b自动提升为int型 ~位反运算，每一位取反 位逻辑运算位逻辑运算优先级 &amp; ^ | 三目运算符？：的第二第三操作数必须是可以赋值的 包一个类可以使用所属包中所有的类，以及其他包中的公有类。访问其他包中公有类的两种方式：在每个类前添加完整的包名；使用import语句(放在源文件的顶部，package语句的后面)。package语句对整个源文件有效，即同一个源文件里的所有类都属于这个包。 访问权限1234//public//private//protected//没有指定则为同包可访问 修饰符static 静态修饰符final 常量修饰符，也可以表示一个类不允许继承1234567891011121314public class A&#123; int i; static int j; public static void main(String[] args)&#123; i = 3; //错误，i只有在new了一个对象后才会存在 j = 7; //正确，j是静态的，不需要创建对象就存在 A a = new A(); a.i = 3; //正确 A.i = 3; //错误 A.j = 4; //正确，j是所有的A类对象所共有的，所以可以通过类名来访问 a.j = 4; //正确 &#125;&#125;]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitee(码云)、Github同时配置ssh key]]></title>
    <url>%2F2018%2F07%2F06%2FGitee(%E7%A0%81%E4%BA%91)%E3%80%81Github%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEssh%20key%2F</url>
    <content type="text"><![CDATA[一、到.ssh文件夹下cd ~/.ssh 二、通过下面的命令，依次生成两个平台的key12$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;github_id_rsa&quot;$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;gitee_id_rsa&quot; 完成后，.ssh文件夹生成以下文件 三、把public key复制到gitee和github执行命令cat github_id_rsa.pub把第二行到结尾的内容复制到github的ssh中保存 同样的操作，添加gitee的ssh 四、创建config文件解决ssh冲突在.ssh文件夹下执行命令vi config文件中添加以下内容1234567891011# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/gitee_id_rsa# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github_id_rsa 五、测试执行ssh -T git@github.com成功则返回Welcome to Gitee.com ,yourname!执行ssh -T git@gitee.com成功则返回Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access.]]></content>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java学习笔记1】数据类型&函数篇]]></title>
    <url>%2F2018%2F07%2F03%2F%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%91%2F</url>
    <content type="text"><![CDATA[Java简单介绍 第一个程序Hello World 基本数据类型 对象和类 数据声明 函数声明 参数传递 Java简单介绍 Java的优点：简单、可移植性 JDK (Java Development Kit) Java开发工具包 JRE (Java Runtime Environment) Java运行环境 只要具有JRE，就可以运行Java代码，而与操作系统的类别无关 安装完JDK后，在电脑“编辑系统环境变量”—“环境变量”选项下，系统变量新建 变量名 JAVA_HONE 变量值 D:\Program Files\java\jdk-10.0.1(这是我的JDK位置) 系统变量找到Path变量，编辑新建D:\Program Files\java\jdk-10.0.1\bin之后在cmd 中测试命令 Java 和 Javac ，有东西输出之后就可以用Javac在cmd里编译Java程序了(生成.class文件)，用Java [option] [主类名]就可以运行程序了(java HelloWorld 而不是 java HelloWorld.class)。第一个程序 Hello World12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println("Hello World!"); &#125;&#125; 注意Java区分大小写，参数中的String的S必须大写。 基本数据类型charbooleanbyte, short, int, long, float, double char(字符型) 首先补充编码的知识ASCII码(美国信息交换标准代码，7-bits ASCII码) 七位码，共128个字符，它主要用于显示现代英语和其他西欧语言。GB2312，是中国国家标准的简体中文字符集，双字节字符集。GBK，GBK字符集主要扩展了繁体中文字的支持，双字节字符集。GB18030,GB 18030标准采用单字节、双字节和四字节三种方式对字符编码。单字节部分使用0×00至0×7F码(对应于ASCII码的相应码)。双字节部分，首字节码从0×81至0×FE，尾字节码位分别是0×40至0×7E和0×80至0×FE。四字节部分采用GB/T 11383未采用的0×30到0×39作为对双字节编码扩充的后缀，这样扩充的四字节编码，其范围为0×81308130到0×FE39FE39。其中第一、三个字节编码码位均为0×81至0×FE，第二、四个字节编码码位均为0×30至0×39。按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集(DBCS)。Unicode(万国码、统一码、单一码)，16位，也就是两个字节代表一个字符。UTF-8是一种8位的unicode字符集，编码长度是可变的，并且是ASCII字符集的严格超集，也就是说ASCII中每个字符的编码在UTF-8中是完全一样的。UTF-8字符集中，一个字符可能是1个字节，2个字节，3个字节或者4个字节长。一般来说，欧洲的字母字符长度为1到2个字节，而亚洲的大部分字符则是3个字节，附加字符为4个字节长。更多关于编码参考文章http://blog.sina.com.cn/s/blog_4b4409c30100vw9t.html 在Java中采用Unicode编码，所以char a = &#39;a&#39;; 和 char b = &#39;中&#39;一样都占两个字节(区别于C和C++)char c = &#39;\u21fa&#39;表示转义字符，格式为\u加上4位16进制数 boolean(布尔型)只有true 和 false 两个值，区别于C和C++。在C和C++中，bool类型可以用数字赋值，非零即为真，零为假。但在Java中只有boolean flag = true; 和 boolean flag = false; byte, short, int, long, float, double(数值型) 类型 存储要求 取值范围 备注 byte 1字节 -128~127 short 2字节 -32768~32767 int 4字节 超过21亿 long 8字节 很大很大 需要在数值后加后缀L float 4字节 大约为±3.402E+38 需要在数值后加后缀F，有效位6~7位 double 8字节 大约为±1.797E+308 需要在数值后加后缀D，有效位15位 float和double类型表示的的数值是离散的，可能有一些小数就是无法表示，只能为近似值。不加F后缀的浮点数值默认为double类型。float和double不能做移位运算。整形移位运算相当于除或乘2的移的位数的次幂。-1在计算机中存储形式为全一，无论移多少位都不变。 对象和类对象(哎)是现实世界中的一个实体。类是具有相同特征的对象的属性的集合。 类的声明1234567891011121314151617[修饰符1][修饰符2][修饰符...]class Student&#123; int i; //类内的变量可以不用定义时赋值，数值变量系统默认赋值为零；逻辑变量boolean默认为false static int j = 1; ... public void Func(float[] f) &#123; ... int i = 0; //函数内的变量随手赋值是个好习惯，不赋值的话，在内存中是暂时没有这个变量的 ... &#125; public static void main(String[] args) &#123; ... &#125; ...&#125; 类实例化为对象123456789Student s1 = new Student();Student s2;s2 = s1;//一个对象变量没有实际包含一个对象，而仅仅是引用一个对象。//new操作符返回的也是一个引用，即这个对象的存储地址。//上面代码中的s2 = s1;仅仅是把s1保存的引用复制一份给s2，并没有复制这个对象//可以将一个对象变量赋值为null，表明这个对象变量目前没有引用任何的对象//如果一个对象没有任何的对象变量引用它，那么这个对象就成为垃圾对象，会被系统自动清理//例如上面代码，如果添加s1 = null;那么这个对象不是垃圾对象，因为还有s2引用(指向)它。 数据声明没什么好说的。[变量类型] [变量名] = [初始值];说一些命名的规则和习惯吧(提高代码可读性)。 a. 必须是字母开头的由字母、数字、下划线组成的序列，区分大小写。虽然在命名可以使用$，但是不要使用。 b. 类名使用 UpperCamelCase(大驼峰) 风格，即每个单词首字母都要大写。 c. 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase(小驼峰) 风格，即从第二个单词开始首字母大写。如：studentName d. 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 e. 杜绝完全不规范的缩写， 避免望文不知义。 … 函数声明1[修饰符1][修饰符2][修饰符..] [函数返回值] [函数名](参数1，参数2，参数..) &#123;函数体&#125; 参数传递Java的函数参数传递只有一种方法：传值(call by value)java 成员变量(成员变量就是方法外部，类的内部定义的变量)存储在堆中的对象里面;局部变量就是方法或语句块内部定义的变量,局部变量必须初始化,局部变量的数据存在于栈内存中,栈内存中的局部变量随着方法的结束而出栈。 例子：12345678910111213141516171819202122232425public class Card&#123; int rank; public static void swap1(Card c1,Card c2) &#123; Card temp = c1; c1 = c2; c2 = temp; &#125; public static void swap2(Card c1,Card c2) &#123; int temp = c1.rank; c1.rank = c2.rank; c2.rank = temp; &#125; public static void main(String[] args) &#123; Card c1 = new Card(); c1.rank = 5; Card c2 = new Card(); c2.rank = 6; swap1(c1,c2); swap2(c1,c2); &#125;&#125; 结果是swap1并没有实现数值交换；swap2实现了数值的变换。分析：在main函数中，首先生成两个对象存储在堆中，并有引用变量c1,c2分别指向两个对象。在调用swap1，main函数的栈空间里复制c1,c2传递给函数，在函数中一波操作猛如虎，两个复制品的指向对象互换，然后函数结束，两个复制品出栈，然而原c1和c2的指向并没有改变。在swap2里，改的直接是存储在堆里的对象的变量，指向没有变化，但是内部的数值已经交换了。]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计范式]]></title>
    <url>%2F2018%2F06%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.第一范式(1NF) 定义：如果关系模式R的所有属性的域都是原子的，那么称关系模式R属于第一范式。 通俗的讲，第一范式就是属性不可再分。比如地址属性，可以再分为省、市、县等属性，所以在这种情况下，地址属性所在的关系模式就不符合第一范式。 2.第二范式(2NF) 定义：若R满足第一范式，且每一个非主属性完全函数依赖于主码，则R满足第二范式。 这里首先补充函数依赖的知识 平凡依赖和非平凡依赖如果A-&gt;B，A是B的超集，则称此函数依赖为平凡的。举个例子：A-&gt;A AB-&gt;A ABC-&gt;AB都是平凡依赖（此处的A、B、C为原子属性）非平凡依赖就是不包含自己或包含自己的集决定自己的函数依赖。 完全依赖和部分依赖函数依赖A-&gt;B称为部分依赖的条件是存在A的真子集C使得C-&gt;B。即A中的一部分就可以决定B，不需要所有的属性来决定B。反之，需要A中所有的属性才能来决定B，缺一不可，那么A-&gt;B就是一个完全依赖。 传递依赖如果A、B是两个属性集，存在A-&gt;B，如果c是一个属性，并且c不属于A或B，并且存在B-&gt;c，那么c就传递依赖于A。 根据2NF的定义，我们可以知道，单属性主键的关系模式一定符合第二范式。 3.第三范式(3NF) 定义：对于F*(F的闭包)中所有形如A-&gt;B的函数依赖（其中A、B都包含于R），以下至少一项成立： · A-&gt;B是一个平凡的函数依赖 · A是R的一个超码 · B-A中的每个属性c都包含于R的一个候选码中 简单的说，若R满足第二范式，且每一个非主属性都不传递函数依赖于主码，则R满足第三范式。即不存在如下依赖关系： 关键字段 → 非关键字段x → 非关键字段y举个例子：假定学生关系表为Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)，关键字为单一关键字”学号”，因为存在如下决定关系： (学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话) 这个数据库是符合2NF的，但是不符合3NF，因为存在如下决定关系： (学号) → (所在学院) → (学院地点, 学院电话) 即存在非关键字段”学院地点”、”学院电话”对关键字段”学号”的传递函数依赖。 4.BC范式(BCNF) 定义：若R满足第三范式，且每一个主属性都不部分函数依赖或传递函数依赖于主码，则R满足第三范式。· 每一个决定属性集（因素）都包含（候选）码· R中的所有属性（主，非主属性）都完全函数依赖于码 举个例子：假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系： (仓库ID, 存储物品ID) →(管理员ID, 数量) (管理员ID, 存储物品ID) → (仓库ID, 数量) 所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系： (仓库ID) → (管理员ID) (管理员ID) → (仓库ID) 即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。 BCNF分解算法1234567while(有违反BCNF的函数依赖)&#123; 找出违反BCNF的函数依赖A-&gt;B； 先计算A的闭包，且用A的闭包(除去A)替换B，并将其分解为&#123;A+&#125;和&#123;AU(R-(A+)&#125;; //比如A-&gt;B ，而&#123;A&#125;+=&#123;A,B,C&#125;，则用A-&gt;BC替换A-&gt;B; 求出分解后的关系满足的投影FD集合； 再看分解后的关系的FD集合是否满足BCNF，如果不满足，则继续分解&#125; 举个例子： 3NF分解算法 致谢：分解算法参考博客：https://blog.csdn.net/xiazdong/article/details/7517438]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库练习题(基础)]]></title>
    <url>%2F2018%2F06%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%E9%A2%98(%E6%AF%94%E8%BE%83%E5%9F%BA%E7%A1%80)%2F</url>
    <content type="text"><![CDATA[一、基本表的定义与删除T1.用SQL语句创建如下三张表：学生（Student）,课程表（Course）,和学生选课表（SC）,这三张表的结构如表1-1到表1-3所示。表1-1 Student表结构 列名 说明 数据类型 约束 Sno 学号 字符串 长度为7，主码 Sname 姓名 字符串 长度为10，非空 Ssex 性别 字符串 长度为2，取‘男’或‘女’ Sage 年龄 整数 取值15~45 Sdept 所在系 字符串 长度为20 默认为‘计算机系’ 123456create table Student(Sno varchar(7) primary key,Sname varchar(10) not null,Ssex varchar(2) check(Ssex='男' or Ssex='女'),Sage int check(Sage&gt;=15 and Sage &lt;=45),Sdept varchar(20) default('计算机系')); 表1-2Course表结构 列名 说明 数据类型 约束 Cno 课程号 字符串 长度为10，主码 Cname 课程名 字符串 长度为20，非空 Ccredit 学分 整数 取值大于0 Semster 学期 整数 取值大于0 Cperiod 学时 整数 取值大于0 1234567create table Course(Cno varchar(10) primary key,Cname varchar(20) not null,Ccredit int check(Ccredit&gt;0),Semster int check(Semster &gt;0),Cperiodint check(Cperiod&gt;0)); 表1-3 SC表结构表1-2Course表结构 列名 说明 数据类型 约束 Sno 学号 字符串 长度为7，主码，参照Student的外码 Cno 课程名 字符串 长度为10，主码，参照Course Grade 成绩 整数 取值0~100 1234567create table SC(Sno varchar(7),Cno varchar(10),Grade int check(Grade &gt;=0 and Grade &lt;=100),primary key(Sno,Cno),foreign key (Sno) references Student(Sno),foreign key (Cno) references Course(Cno)); PS:外码(键): 一个关系模式(r1)可能在它的属性中包含另一个关系模式(r2)的主码,这个属性在r1上称作参照r2的外码。关系r1称为外码依赖的参照关系，关系r2称为外码的被参照关系。FK一定来自另一个表的PK，FK是PK的子集。 如果外键或者主键要求命名，请使用以下语法12constraint pk_Student_Sno primary key (Sno)constraint fk_Student_Sno foreign key (Sno) references Student(Sno)//SC表，参照表后边的属性可以省略 已有表，添加外键1234alter table SCadd constraint fk_Student_Sno foreign key (Sno) references Student(Sno); 二、修改表结构T2.为SC表添加“选课类别”列，此列的定义为XKLB char(4) 1alter table SC add XKLB char(4); T3.将新添加的XKLB的类型修改为char(6)1alter table SC alter column XKLB char(6); T4.删除Course表的Cperiod列1alter table Course drop column Cperiod; T5.重命名Student表的Ssex列为sex1EXEC sp_rename 'Student.Ssex','sex'; 三、数据查询功能表3-1 Student表数据 Sno Sname Ssex Sage Sdept 9512101 李勇 男 19 计算机系 9512102 刘晨 男 20 计算机系 9512103 王敏 女 20 计算机系 9521101 张立 男 22 信息系 9521102 吴宾 女 21 信息系 9521103 张海 男 20 信息系 9531101 钱小平 女 18 数学系 9531102 王大力 男 19 数学系 12345678910insert into Studentvalues('9512101','李勇','男',19,'计算机系'),('9512102','刘晨','男',20,'计算机系'),('9512103','王敏','女',20,'计算机系'),('9521101','张立','男',22,'信息系'),('9521102','吴宾','女',21,'信息系'),('9521103','张海','男',20,'信息系'),('9531101','钱小平','女',18,'数学系'),('9531102','王大力','男',19,'数学系'); 表3-2 Course表数据 Cno Cname Ccredit Semster C01 计算机文化学 3 1 C02 VB 2 3 C03 计算机网络 4 7 C04 数据库基础 6 6 C05 高等数学 8 2 C06 数据结构 5 4 12345678insert into Course(Cno,Cname,Ccredit,Semster)values('C01','计算机文化学',3,1),('C02','VB',2,3),('C03','计算机网络',4,7),('C04','数据库基础',6,6),('C05','高等数学',8,2),('C06','数据结构',5,4); 表 3-3 SC表数据 Sno Cno Grade XKLB 9512101 c01 90 必修 9512101 c02 86 选修 9512101 c06 必修 9512102 c02 78 选修 9512102 c04 66 必修 9521102 c01 82 选修 9521102 c02 75 选修 9521102 c04 92 必修 9521102 c05 50 必修 9521103 c02 68 选修 9521103 c06 必修 9531101 c01 80 选修 9531101 c05 95 必修 9531102 c05 85 必修 12345678910111213141516insert into SC values('9512101','c01',90,'必修'),('9512101','c02',86,'选修'),('9512101','c06',NULL,'必修'),('9512102','c02',78,'选修'),('9512102','c04',66,'必修'),('9521102','c01',82,'选修'),('9521102','c02',75,'选修'),('9521102','c04',92,'必修'),('9521102','c05',50,'必修'),('9521103','c02',68,'选修'),('9521103','c06',NULL,'必修'),('9531101','c01',80,'选修'),('9531101','c05',95,'必修'),('9531102','c05',85,'必修'); T6.查询全体学生的学号与姓名12select Sno,Sname from Student; T7.查询全体学生的姓名，学号和所在系12select Sno,Sname,Sdept from Student; T8.查询全体学生的所有信息（三张表以上的关联查询）12select *from Student left join SC on Student.Sno=SC.Sno left join Course on SC.Cno=Course.Cno T9.查询全体学生的姓名及其出生年份12select Sname,2018-Sage as '出生年份'from Student T10.查询全体学生的姓名和出生年份，并在出生年份列前加入一个列，此列的每行数据均为“Year of Birth”常量值12select Sname,'Year of Birth',2018-Sage as '出生年份'from Student T11.在选课表（SC）中查询有哪些学生选修了课程，并列出学生的学号12select distinct Snofrom SC T12.查询计算机系全体学生的姓名123select Snamefrom Studentwhere Sdept='计算机系' T13.查询所有年龄在20岁以下的学生的姓名及年龄123select Sname,Sagefrom Student where Sage&lt;20 T14.查询考试成绩不及格的学生的姓名123select Snamefrom Student,SC where Student.Sno=SC.Sno and SC.Grade&lt;60 T15.查询年龄在20~23岁之间的学生的姓名，所在系和年龄123select Sname,Sdept,Sagefrom Student where Sage between 20 and 23 T16.查询年龄不在20~23之间的学生的姓名，所在系和年龄123select Sname,Sdept,Sagefrom Student where Sage not between 20 and 23 T17.查询信息系，数学系和计算机系学生的姓名和性别123select Sname,Ssexfrom Student where Sdept in ('信息系','数学系','计算机系') T18.查询既不属于信息系，数学系，也不属于计算机系的学生的姓名和性别123select Sname,Ssexfrom Student where Sdept not in ('信息系','数学系','计算机系') T19.查询学生表中姓“张”的学生的详细信息123select *from Student where Sname like '张%' T20.查询学生表中姓“张”，姓“李”和姓“刘”的学生的情况123select *from Student where Sname like '张%' or Sname like '李%' or Sname like '刘%' 使用下边的这种写法更加简便123select *from Student where Sname like '[张李刘]%' T21.查询名字中第2个字为“小”或“大”字的学生的姓名和学号123select Sname,Snofrom Student where Sname like '_[小大]%' T22.查询所有不姓“刘”的学生的姓名123select Snamefrom Student where Sname not like '刘%' T23.从学生表中查询学号的最后一位不是2，3，5的学生的情况123select *from Student where Sno not like '%[235]' T24.查询无考试成绩的学生的学号和相应的课程号123select Sno,Cnofrom SC where Grade is null T25.查询所有有考试成绩的学生的学号和课程号123select Sno,Cnofrom SC where Grade is not null T26.查询计算机系年龄在20岁以下的学生的姓名123select Snamefrom Student where Sdept='计算机系' and Sage&lt;20 T27.将学生按年龄升序排序123select *from Student order by Sage asc T28.查询选修了课程“c02”的学生的学号及其成绩，查询结果按成绩降序排列1234select Sno,Gradefrom SCwhere Cno='C02'order by Grade desc T29.查询全体学生的信息，查询结果按所在系的系名升序排列，同一系的学生按年龄降序排列123select *from Studentorder by Sdept,Sage desc T30.统计学生总人数12select count(*)from Student T31.统计选修了选修课程的学生的人数123select count(distinct Sno)from SCwhere XKLB='选修' T32.计算学号为9512101的学生的考试总成绩之和123select sum(Grade)from SCwhere Sno='9512101' T33.计算课程“c01”的学生的考试平均成绩123select avg(Grade)from SCwhere Cno='C01' T34.查询选修了课程“c01”的学生的最高分和最低分123select max(Grade),min(Grade)from SCwhere Cno='C01' T35.统计每门课程的选课人数，列出课程号和人数123select Cno,count(Sno) as '选课人数'from SCgroup by Cno T36.查询每名学生的选课门数和平均成绩123select Sno,count(Cno) as '选课门数',avg(Grade) as '平均成绩'from SCgroup by Sno T37.查询选修了3门以上课程的学生的学号1234select Snofrom SCgroup by Snohaving count(Cno)&gt;3 T38.查询选课门数等于或大于4门的学生的平均成绩和选课门数1234select Sno,avg(Grade) as '平均成绩',count(*) as '选课门数'from SCgroup by Snohaving count(*)&gt;=4 四、多表查询T39.查询每个学生的情况及其选课的情况12select *from Student left outer join SC on Student.Sno=SC.Sno T40.查询计算机系学生的选课情况，要求列出学生的名字，所修课的课程号和成绩123select Sname,Cno,Gradefrom Student,SCwhere Student.Sno=Sc.Sno and Sdept='计算机系' T41.查询信息系选修VB课程的学生的成绩，要求列出学生姓名，课程名和成绩123select Sname,Cname,Gradefrom Student,SC,Coursewhere Student.Sno=SC.Sno and SC.Cno=Course.Cno and sdept='信息系' and Cname='VB' 123select Sname,Cname,Grade from Student join SC on Student.Sno=SC.Sno join Course on Course.Cno=SC.Cno where Sdept = '信息系' and Cname = 'VB'; T42.查询所有选修了VB课程的学生的情况，要求列出学生姓名和所在的系123select Sname,Sdeptfrom Student join SC on Student.Sno=SC.Sno join Course on Course.Cno=SC.Cno where Cname='VB' T43.查询与刘晨在同一个系学习的学生的姓名和所在系12345select Sname,Sdeptfrom Studentwhere Sdept=(select Sdept from Student where Sname='刘晨') 123select s2.Sname,s2.Sdeptfrom Student as s1,Student as s2where s1.Sname='刘晨' and s2.Sname !='刘晨' and s1.Sdept=s2.Sdept T44.查询学生的选课情况，包括选修课程的学生和没有修课的学生12select *from Student left join SC on Student.Sno=SC.Sno T45.查询数学系成绩在80分以上的学生的学号，姓名123select Student.Sno,Snamefrom Student join SC on Student.Sno=SC.Snowhere Sdept='数学系' and Grade&gt;80 T46.查询计算机系考试成绩最高的学生的姓名123456select Snamefrom Student join SC on Student.Sno=SC.Snowhere Sdept='计算机系' and Grade=(select max(Grade) from Student join SC on Student.Sno=SC.Sno Group by Sdept having Sdept='计算机系') 五、嵌套子查询(T43) T47.查询成绩大于90分的学生的学号和姓名12345select Sno,Snamefrom Studentwhere Sno in (select Sno from SC where Grade&gt;90) T48.查询选修了“数据库基础”课程的学生的学号和姓名1234567select Sno,Snamefrom Studentwhere Sno in (select Sno from SC where Cno in (select Cno from Course where Cname='数据库基础')) T49.查询选修了刘晨没有选修的课程的学生的学号和所在系123456789select Sno,Sdeptfrom Studentwhere Sno in (select Sno from SC where Cno not in (select Cno from SC where Sno=(select Sno from Student where Sname='刘晨'))) T50.查询选修了课程“c02”且成绩高于此课程的平均成绩的学生的学号和成绩12345select Sno,Gradefrom SCwhere Cno='C02' and Grade&gt;(select avg(Grade) from SC where Cno='C02') T51.查询选修了课程“c01”的学生姓名12345select Snamefrom Studentwhere Sno in (select Sno from SC where Cno='C01') 12345select Snamefrom Studentwhere exists (select * from SC where Sno=Student.Sno and Cno='C01') PS.一般来说，在SQL中in子查询都可以用exists代替。EXISTS子查询可以看成是一个独立的查询系统，只为了获取真假逻辑值，EXISTS子查询与外查询查询的表是两个完全独立的毫无关系的表，当我们在子查询中添加了Sno关联之后，EXISTS子查询与外查询查询的表就统一了，是二者组合组建的虚表，是同一个表（这样当子查询查询到虚表中当前行的Cno为C01时，则将虚表当前行中对应的Sname查询到了）. 重点在于Sno关联之上，添加Sno关联，数据库会先将两张表通过Sno关联组合成一张虚表，所有的查询操作都在这张虚表上完成。 六、自查询T52.查询所有成绩大于C01课程最高成绩的学生的学号12345select SC2.Snofrom SC as SC1,SC as SC2where SC1.Sno=SC2.Sno and SC1.Cno=SC2.Cno and SC2.Grade&gt;all(select Grade from SC where SC.Cno='C01') 七、更新数据T53.将所有学生的年龄加112update Studentset Sage=Sage+1 T54.将“9512101”学生的年龄改为21岁123update Studentset Sage=21where Sno='9512101' T55.将计算机系学生的成绩加5分12345update SCset Grade=Grade+5where Sno in (select Sno from Student where Sdept='计算机系') 八、删除数据T56.删除所有学生的选课记录1DELETE FROM SC T57.删除所有不及格学生的选课记录12delete from SCwhere Grade&lt;60 T58.删除计算机系不及格学生的选课记录1234delete from SCwhere Grade&lt;60 and Sno in (select Sno from Student where Sdept='计算机系') 数据来源于网络，整理@lihui测试代码：建表代码题目代码测试环境：SQL Server 2017 考试结束了，烤糊了😭…附上题目留与后人吧2017-2018学年大连理工大学软件学院数据库考试题目说明 20分 10个选择（比较简单，复习注意概念，比如DBS，DB，DBMS都是什么。其中有两个有关事务的题，即第十二章内容，分别是ACID的四个性质内容和结束事务并回滚的语句是什么问题） 50分 4个关系代数，6个SQL，一个5分。考了not exists和not in 相互转换, not exists…except结构, 标量子查询，分组聚集的内容（懵的一匹@_@） 10分 范式分解 属性闭包和候选码（6分），判断第几范式（2分），BCNF分解（2分） 20分 ER图 画ER图（10分），转换成关系模式（10分）。（回忆版）商店记录商品信息和客户信息，商品信息包括商品编号、名称、单价等，客户信息包括客户编号、客户姓名、电话等。一个顾客可以购买多个商品，一件商品可以购买不同数量，一次性的购物记录在一个购物单里，商品销售时价格可以调整。要求商店可以查询一个客户的消费记录和消费总额。根据题意设计ER图，可以自己添加必要属性。]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【python learning 1】从Hello world!开始（print()函数解析）]]></title>
    <url>%2F2018%2F06%2F06%2F%E3%80%90python%20learning%201%E3%80%91%2F</url>
    <content type="text"><![CDATA[老规矩，学习一门语言，肯定要从Hello world开始啦 python2print &quot;Hello world!&quot; python3print(&quot;Hello world!&quot;)不同的原因是，在python3中，print只作为一个函数调用，括号中的内容作为函数的参数。 但是，在python2中使用括号也没有问题。 print()函数: print（*objects,sep=&#39; &#39;,end=&#39;\n&#39;,file=sys.stdout,flush=False） 参数意义 *objects 表示要输出的值，可以是多个，用逗号分隔 sep 表示多个输出值之间的间隔，可以自己赋值，默认为一个空格 end 表示输出语句最末尾附加的字符串，默认为’\n’，即换行 #ps: 在Python2中，如果不想换行则在输出语句的末尾加一个逗号，Python3中写成print(“hhh”,end=’’)就好了。 file 表示输出的对象，可以是文件也可以是数据流，默认是sys.stdout flush 表示是否立刻将输出语句输出的目标对象，默认为False]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
