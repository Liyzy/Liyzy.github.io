<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李三岁他很皮</title>
  
  <subtitle>学习干嘛 愣着啊</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liyzy.github.io/"/>
  <updated>2018-11-04T14:14:42.562Z</updated>
  <id>http://liyzy.github.io/</id>
  
  <author>
    <name>lihui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络与信息安全复习</title>
    <link href="http://liyzy.github.io/2018/11/04/review/"/>
    <id>http://liyzy.github.io/2018/11/04/review/</id>
    <published>2018-11-04T14:27:37.492Z</published>
    <updated>2018-11-04T14:14:42.562Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p><br><!--Read more--></p><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="安全攻击分类"><a href="#安全攻击分类" class="headerlink" title="安全攻击分类"></a>安全攻击分类</h3><p>被动攻击：信息内容泄露、流量分析<br>主动攻击：伪装、重播、消息修改、拒绝服务</p><h3 id="安全服务"><a href="#安全服务" class="headerlink" title="安全服务"></a>安全服务</h3><p>认证：保证通信的真实性。确保通信双方的身份是可信的。<br>访问控制：防止资源非授权使用<br>数据保密性：防止传输消息受到<strong>被动攻击</strong>。<br>数据完整性：与<strong>主动攻击</strong>有关，检测而不是阻止。<br>不可否认性：防止通信方对通信行为的否认，包括源不可否认性和宿不可否认性。<br>可用性：系统或系统资源能够按照要求根据系统性能规范被授权系统的实体访问和使用。</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="理论安全与实际安全"><a href="#理论安全与实际安全" class="headerlink" title="理论安全与实际安全"></a>理论安全与实际安全</h3><p>理论安全：攻击者无论截获多少密文，都无法得到足够的信息来唯一地决定明文。香农证明只有一次一密才能达到理论安全，不实用。<br>实际安全（计算安全）：在有限的资源内，攻击者都不能通过系统的分析方法来破解系统。</p><h3 id="密码体制"><a href="#密码体制" class="headerlink" title="密码体制"></a>密码体制</h3><h4 id="对称密码体制与非对称密码体制"><a href="#对称密码体制与非对称密码体制" class="headerlink" title="对称密码体制与非对称密码体制"></a>对称密码体制与非对称密码体制</h4><p>对称密码：加密密钥和解密密钥相同，或者一个密钥可以从另一个导出，能加密就能解密，加密能力和解密能力是结合在一起的，开放性差。<br>非对称密码：加密密钥和解密密钥不相同，从一个密钥导出另一个密钥是计算上不可行的，加密能力和解密能力是分开的，开放性好。</p><h4 id="序列密码体制和分组密码体制"><a href="#序列密码体制和分组密码体制" class="headerlink" title="序列密码体制和分组密码体制"></a>序列密码体制和分组密码体制</h4><p>序列密码：密文不仅与最初给定的算法和密钥有关，同时也与明文位置有关(是所处位置的函数)。<br>分组密码：经过加密所得到的密文仅与给定的密码算法和密钥有关，与被处理的明文数据在整个明文中的位置无关。</p><h4 id="确定型密码体制和概率型密码体制"><a href="#确定型密码体制和概率型密码体制" class="headerlink" title="确定型密码体制和概率型密码体制"></a>确定型密码体制和概率型密码体制</h4><p>确定型密码:当明文和密钥确定后，密文也就唯一地确定了。<br>概率密码：当明文和密钥确定后，密文通过客观随机因素从一个密文集合中产生，密文形式不确定。</p><h4 id="单向函数型密码体制和双向变换型密码体制"><a href="#单向函数型密码体制和双向变换型密码体制" class="headerlink" title="单向函数型密码体制和双向变换型密码体制"></a>单向函数型密码体制和双向变换型密码体制</h4><p>单向函数型密码体制：适用于不需要解密的场合，容易将明文加密成密文，如哈希函数。<br>双向变换型密码体制：可以进行可逆的加密、解密变换。</p><h3 id="现代密码学的基本原则"><a href="#现代密码学的基本原则" class="headerlink" title="现代密码学的基本原则"></a>现代密码学的基本原则</h3><p>设计加密系统时，总是假定密码算法是可以公开的，需要保密的是密钥。一个密码系统的安全性不在算法的保密，而在于密钥，即Kerckhoff原则。</p><h3 id="对加密系统的要求"><a href="#对加密系统的要求" class="headerlink" title="对加密系统的要求"></a>对加密系统的要求</h3><p>系统应该是实际安全的(practical secure)，截获密文或已知明文－密文对时，要决定密钥或任意明文在计算上是不可行的。<br>加密解密算法适用于密钥空间中的所有元素。<br>系统易于实现，使用方便。<br>系统的安全性不依赖于对加密体制或加密算法的保密，而依赖于密钥。<br>系统的使用不应使通信网络的效率过分降低。</p><h3 id="对加密信息的攻击类型"><a href="#对加密信息的攻击类型" class="headerlink" title="对加密信息的攻击类型"></a>对加密信息的攻击类型</h3><table><thead><tr><th>攻击类型</th><th>攻击者持有的信息 </th></tr></thead><tbody><tr><td> 唯密文攻击</td><td>加密算法、待解密密文</td></tr><tr><td> 已知明文攻击</td><td>加密算法 、待解密密文、与待解密密文（同一密钥加密）的明密文对</td></tr><tr><td> 选择明文攻击</td><td>加密算法 、待解密密文、攻击者选择的明文及对应的（同一密钥加密）密文</td></tr><tr><td> 选择密文攻击</td><td>加密算法 、待解密密文、攻击者选择的（同一密钥加密）密文及对应的明文</td></tr><tr><td> 选择文本攻击</td><td>加密算法 、待解密密文、攻击者选择的（同一密钥加密）密文及对应的明文、攻击者选择的明文及对应的（同一密钥加密）密文</td></tr></tbody></table><h3 id="代换与置换"><a href="#代换与置换" class="headerlink" title="代换与置换"></a>代换与置换</h3><p>代换法是将明文字母替换成其他字母、数字或符号的加密方法。如果把明文看成是二进制序列的话，代换就是用密文位串来代换明文位串。代换法改变明文内容的表示形式，保持内容元素之间相对位置不变。由于语言的冗余性（即字母单词使用频率的统计特性），单表代换虽然密钥空间很大，但并不安全。<br>置换法是改变明文内容元素的相对位置，保持内容的表现形式不变。通过重新安排消息字母的位置来隐藏明文信息，而不是用其他字母来代换明文字母。这种方法是很容易破译的，因为密文拥有与明文一样的字母频率统计特性。</p><h3 id="隐写术"><a href="#隐写术" class="headerlink" title="隐写术"></a>隐写术</h3><p>隐写术不是加密技术。比如将信息通过改变像素内容隐藏到图片中，不可见的墨水等。</p><h3 id="一次一密"><a href="#一次一密" class="headerlink" title="一次一密"></a>一次一密</h3><p>两个限制：产生大规模随机密钥有实际困难、密钥的分配和保护无法保证</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="流密码与分组密码"><a href="#流密码与分组密码" class="headerlink" title="流密码与分组密码"></a>流密码与分组密码</h3><p>流密码：每次加密数据流的一位或一个字节。<br>分组密码：将一个明文分组作为一个整体进行加密，并且一般得到等长的密文。</p><h3 id="扩散和混淆"><a href="#扩散和混淆" class="headerlink" title="扩散和混淆"></a>扩散和混淆</h3><p>扩散：明文统计特征消散在密文中。可以通过让多个明文数字影响一个密文数字，或者每个明文数字可以影响多个密文数字。<br>混淆：使密文和加密密钥之间的统计关系尽量复杂。</p><blockquote><p>Confusion means that each binary digit (bit) of the ciphertext should depend on several parts of the key, obscuring the connections between the two.<br>Diffusion means that if we change a single bit of the plaintext, then (statistically) half of the bits in the ciphertext should change, and similarly, if we change one bit of the ciphertext, then approximately one half of the plaintext bits should change. Since a bit can have only two states, when they are all re-evaluated and changed from one seemingly random position to another, half of the bits will have changed state.<br>In Shannon’s original definitions, confusion refers to making the relationship between the ciphertext and the symmetric key as complex and involved as possible; diffusion refers to dissipating the statistical structure of plaintext over the bulk of ciphertext. This complexity is generally implemented through a well-defined and repeatable series of substitutions and permutations. Substitution refers to the replacement of certain components (usually bits) with other components, following certain rules. Permutation refers to manipulation of the order of bits according to some algorithm. To be effective, any non-uniformity of plaintext bits needs to be redistributed across much larger structures in the ciphertext, making that non-uniformity much harder to detect.</p></blockquote><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>给定整数$a, b$及$n≠0$, 当且仅当$a-b=kn$时，$a$与$b$在模$n$时同余，记为$a≡b mod n$ 或 $a≡nb$。<br>如果$n|(a-b)$, 则$a≡b mod n$。</p><h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><p>$(a1 op a2) mod n =[(a1 mod n )] op (a2 mod n)] mod n$</p><h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p>如果一个整数与$n$互素，那么它在$Z_n$中存在一个乘法逆元。<br>对于任何一般的模数$n$，如果$a$与$n$互素，那么用乘数$a$作用到$Z_n$(即0,1,2,…,n-1)然后模$n$会得到完整的$Z_n$(元素顺序可能不同，也可以叫做$Z_n$的一个置换)。</p><table><thead><tr><th>Z8</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td> 乘以5</td><td>0</td><td>5</td><td>10</td><td>15</td><td>20</td><td>25</td><td>30</td><td>35</td></tr><tr><td> 剩余类</td><td>0</td><td>5</td><td>2</td><td>7</td><td>4</td><td>1</td><td>6</td><td>3</td></tr></tbody></table><h3 id="欧几里得算法与拓展欧几里得算法"><a href="#欧几里得算法与拓展欧几里得算法" class="headerlink" title="欧几里得算法与拓展欧几里得算法"></a>欧几里得算法与拓展欧几里得算法</h3><h4 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h4><p>又称辗转相除法。欧几里德定理：$ gcd(a, b) = gcd(b , a\%b)$</p><h4 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h4><p>对于不完全为$0$的非负整数 $a，b，gcd（a，b）$表示 $a，b$ 的最大公约数，必然存在整数对$ x，y $，使得$gcd（a，b）=a<em>x+b</em>y$。</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="双重DES"><a href="#双重DES" class="headerlink" title="双重DES"></a>双重DES</h3><p>因为对单重DES进行<strong>穷举攻击</strong>是可行的（密钥长度仅有56位）。<br>双重DES存在着<strong>中间相遇攻击</strong>。$C = E_{K2}(E_{K1}(P))， P = D_{K1}(D_{K2}(C))$，因为$X = E_{K1}(P) = D_{K2}(C)$，用所有可能的密钥加密明文P并把结果存储起来，然后用所有可能的密钥解密密文C，寻找匹配的X值，因此复杂度只有O($2^{56}$)。</p><h3 id="三重DES"><a href="#三重DES" class="headerlink" title="三重DES"></a>三重DES</h3><h4 id="使用两个密钥的三重DES"><a href="#使用两个密钥的三重DES" class="headerlink" title="使用两个密钥的三重DES"></a>使用两个密钥的三重DES</h4><p>$C=E_{K1}[D_{K2}[E_{K1}[P]]$<br>如果$K1=K2$，那么就变成了单重DES，从而实现对单重DES的兼容。</p><h4 id="使用三个密钥的三重DES"><a href="#使用三个密钥的三重DES" class="headerlink" title="使用三个密钥的三重DES"></a>使用三个密钥的三重DES</h4><p>$C = E_{K3}[D_{K2}[E_{K1}[P]]]$<br>如果$K1=K2$或者是$K2=K3$，那么就变成了单重DES，从而实现对单重DES的兼容。</p><h3 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h3><h4 id="电子密码本模式ECB"><a href="#电子密码本模式ECB" class="headerlink" title="电子密码本模式ECB"></a>电子密码本模式ECB</h4><p>明文分成64的分组进行加密，必要时填充，每个分组用同一密钥加密，同样明文分组加密得相同密文。<br>ECB模式特别适合数据较少的情况，如安全传输DES密钥。<br>一段明文消息中若有几个相同的明文组，则密文也将出现几个相同的片段。<br>对于很长的消息，ECB是不安全的，如果消息是非常结构化的，密码分析可能利用其结构特征来破解。<br>ECB的弱点来源于其加密过的密文分组是互相独立的。<br><img src="http://pg60us30v.bkt.clouddn.com//image/ECB.jpg" alt="ECB"></p><h4 id="密文分组链接模式CBC"><a href="#密文分组链接模式CBC" class="headerlink" title="密文分组链接模式CBC"></a>密文分组链接模式CBC</h4><p>加密输入是当前明文分组和前一密文分组的异或，形成一条链，使用相同的密钥， 这样每个明文分组的加密函数输入与明文分组之间不再有固定的关系。<br>每个密文分组依赖于所有明文分组。<br>发送方和接收方需要共享初始向量Initial Value(IV)。如果IV被明文传送，则攻击者可以预先改变IV中的某些位，则接收者收到的P1也就相应改变了。因此，IV必须是一个固定的值或者必须用<strong>ECB方式</strong>在消息之前加密传送。<br>在消息的最后，还要处理不够长度的分组进行填充。<br>明文消息中的任何一点变化都会影响所有的密文分组。<br><img src="http://pg60us30v.bkt.clouddn.com//image/CBC.jpg" alt="CBC"></p><h4 id="密文反馈模式CFB"><a href="#密文反馈模式CFB" class="headerlink" title="密文反馈模式CFB"></a>密文反馈模式CFB</h4><p>可以视为流密码，不再要求报文被填充成整个分组，可以实时运行，如果要传输一个字符流，每个字符都可以使用面向字符的流密码加密后立即传输。<br>加密：加密函数的输入是一个64位的移位寄存器，产生初始向量IV。加密函数高端j位与明文P1的第一单元异或，产生j位密文C1进入移位寄存器低端，继续加密，与P2输入异或，如此重复直到所有明文单元都完成加密。<br>解密：采用相同方案，但是<strong>使用加密函数</strong>而非解密函数。<br>设$MSB_s(X)$表示X的最左边s位。则<br>$C1=P1 \bigoplus MSB_s[E(K,IV)]$<br>从而有$P1=C1 \bigoplus MSB_s[E(K,IV)]$<br>如果在传输过程中某一个分组的密文发生改变，则会影响到这个分组及其后的分组的明文正确性。<br><img src="http://pg60us30v.bkt.clouddn.com//image/CFB.jpg" alt="CFB"></p><h4 id="输出反馈模式OFB"><a href="#输出反馈模式OFB" class="headerlink" title="输出反馈模式OFB"></a>输出反馈模式OFB</h4><p>结构上类似CFB，但是OFB中加密函数输出被反馈回移位寄存器，CFB中是密文单元被反馈回移位寄存器（对比两个图，可以看到反馈位置是不同的）。优点是传输中的比特差错不会传播，缺点是比CFB更容易受报文流篡改攻击。OFB的IV必须是时变值。<br>OFB的一个优点是，传输过程中在某位上发生的错误不会影响到其他位。比如，C1中有1位发生了错误，只会影响到P1的恢复，后续的明文单元不受影响。<br>OFB的缺点是，抗消息流篡改攻击的能力不如CFB。即密文中的某位取反，恢复出的明文相应位也取反。<br><img src="http://pg60us30v.bkt.clouddn.com//image/OFB.jpg" alt="OFB"></p><h4 id="计数器模式CTR"><a href="#计数器模式CTR" class="headerlink" title="计数器模式CTR"></a>计数器模式CTR</h4><p>与OFB很像，但是加密的是计数器的值而不是任何反馈回来的值。每一个明文分组都必须使用一个不同的密钥和计数器值，决不要重复使用。<br>高效、可以做<strong>并行</strong>加密<br>对高速链路的突发数据加密尤其有效<br>可以对被加密的分组进行随机存取<br>安全、简洁<br>不需要填充<br><img src="http://pg60us30v.bkt.clouddn.com//image/CTR.jpg" alt="CTR"></p><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><h3 id="费马定理"><a href="#费马定理" class="headerlink" title="费马定理"></a>费马定理</h3><p>若$p$是素数, $a$是正整数且不能被$p$整除, 则$a^{p-1} mod p=1$<br>证明：<br>$对于X={ a mod p,2a mod p,…, (p-1)a mod p}$<br>$\because a是正整数且不能被p整除$<br>$\therefore X内的元素均大于零$<br>$假设ja≡ka(modp)，其中1\leqslant j&lt;k\leqslant p-1$<br>$\because a与p互素$<br>$\therefore 两边可以把a消去，则推出j ≡ k(mod p)，与假设矛盾$<br>$也就是说，X内的元素均为正整数且互不相等$<br>$\because { a mod p, 2a mod p, …, (p-1)a mod p} 是{ 1, 2, …, (p-1)} 的置换形$<br>$\therefore (aｘ2aｘ … ｘ (p-1)a)≡(1ｘ2ｘ … ｘ(p-1)) (mod p)≡ (p-1)! (mod p)$<br>$\because aｘ2aｘ…ｘ(p-1)a=(p-1)!a^{p-1}，即 (p-1)!a^{p-1}≡(p-1)! (mod p)$<br>$两边去掉(p-1)!，即得 a^{p-1}mod p = 1$</p><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>$\varphi (n)$是比n小且与n互素的正整数的个数，定义$\varphi (1)=1$。<br><img src="http://pg60us30v.bkt.clouddn.com//image/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0.jpg" alt=""></p><h4 id="欧拉函数定理"><a href="#欧拉函数定理" class="headerlink" title="欧拉函数定理"></a>欧拉函数定理</h4><p>$p和q是素数, n=p*q, \varphi (n)= \varphi (p)\varphi (q)=(p-1)(q-1)$<br>证明：$考虑余数集合{ 0, 1, …, (pq-1)} 中不与n互素的余数集合是{ p, 2p, …, (q-1)p} , { q, 2q, …, (p-1)q} , 所以\varphi (n)= (pq-1)-[(q-1)+(p-1)]=pq-(p+q)+1= (p-1)(q-1)=\varphi (p)\varphi (q)$</p><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>对任意互素的$a$与$n$，$a^{\varphi (n)} \equiv 1(modn)$<br>证明：<br>$若n为素数，则根据\varphi (n)=n-1和a^{p-1}\ mod\ p=1可知成立。但这是不完全的证明。$<br>$考虑集合R=${$x_1,x_2,…,x_{\varphi (n)}$},$每一个元素都有gcd(x_i,n)=1。$<br>$令S={ (ax_1\ mod\ n),(ax_2\ mod\ n),…,(ax_{\varphi (n)}\ mod\ n)}$<br>$S是R的一个置换，因为<br>(1) a与n互素，且x_i与n互素，所以ax_i必与n互素，这样S中所有元素均小于n且与n互素。<br>(2) S中没有重复元素，因为如果ax_i\equiv ax_j(modn)，则x_i=x_j，显然不成立。$<br>$\prod_{i=1}^{\varphi (n)}(ax_imodn)=\prod_{i=1}^{\varphi (n)}x_i$<br>$\prod_{i=1}^{\varphi (n)}ax_i\equiv \prod_{i=1}^{\varphi (n)}x_i(modn)$<br>$a^{\varphi (n)}\times [\prod_{i=1}^{\varphi (n)}x_i]\equiv \prod_{i=1}^{\varphi (n)}x_i(modn)$<br>$两边同时消去，得到a^{\varphi (n)} \equiv 1(modn)$</p><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>中国余数定理CRT说明某一范围内的整数可通过它对两两互素的整数取模所得的余数来重构。<br>例如：$Z_{10}(0,1,…,9)$中的10个整数可通过它们对2和5(10的素因子)取模所得的两个余数来重构. 假设数$x$的余数$r_2=0$ 且$r_5=3$, 即$x\ mod\ 2=0$, $x\ mod\ 5=3$, 则$x$是$Z_{10}$中的偶数且被5除余3, 唯一解$x=8$。</p><h4 id="一种CRT的表示形式"><a href="#一种CRT的表示形式" class="headerlink" title="一种CRT的表示形式"></a>一种CRT的表示形式</h4><p>$令M=\prod_{i=1}^{k}m_i,  其中m_i两两互素, 1\leqslant i, j\leqslant k, i≠j, gcd(m_i, m_j)=1。将Z_M中的任一整数对应一个k元组, 该k元组的元素均在Z_{m_i}中, 对应关系为A\leftrightarrow (a_1,a_2,…,a_k), 其中A∈Z_M,  对1\leqslant i\leqslant k, a_i∈Z_{m_i},  且a_i = A\ mod\ m_i。$</p><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="对称密码与非对称密码"><a href="#对称密码与非对称密码" class="headerlink" title="对称密码与非对称密码"></a>对称密码与非对称密码</h3><h4 id="对称密码体制的问题"><a href="#对称密码体制的问题" class="headerlink" title="对称密码体制的问题"></a>对称密码体制的问题</h4><p>加密能力与解密能力是捆绑在一起的。<br>密钥更换、传递和交换需要可靠信道，密钥分发困难。<br>如有N用户，则需要$C=\frac {N\times (N-1)}{2}$个密钥，n=1000时，C(1000, 2)≈500000, 密钥管理困难。<br>无法满足不相识的人之间通信的保密要求。<br>不能实现数字签名。</p><h4 id="非对称密码体制的基本特点"><a href="#非对称密码体制的基本特点" class="headerlink" title="非对称密码体制的基本特点"></a>非对称密码体制的基本特点</h4><p>加密能力与解密能力是分开的。<br>密钥分发简单。<br>需要保存的密钥量大大减少，N个用户只需要N个密钥。<br>可满足不相识的人之间保密通信。<br>可以实现数字签名。</p><h3 id="公钥密码体制的应用"><a href="#公钥密码体制的应用" class="headerlink" title="公钥密码体制的应用"></a>公钥密码体制的应用</h3><p>加密/解密：发送方用接收方的公钥对消息加密。<br>数字签名：发送方用其私钥对消息签名，可以对整体消息签名或对消息的摘要签名。<br>密钥交换：通信双方交换会话密钥。</p><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>随机选择两个秘密大素数$p$和$q$<br>计算公开模数$n=p\times q$<br>计算秘密的欧拉指数函数$\varphi (n)=(p-1)(q-1)$<br>选择一个与$\varphi (n)$互素的数，作为$e$或$d$<br>用$Euclid$算法计算模$\varphi (n)$的乘法逆元素，即根据$ed\ mod\ φ(n)=1$, 求$d$或$e$<br>加密：$C=M^e\ mod\ n$<br>解密：$M=C^d\ mod\ n = (M^e\ mod\ n)^d\ mod\ n=M^{ed}\ mod\ n=M$<br>公钥：$PU={ e,n}$ 私钥：$PR={ d,n}$</p><h4 id="需要满足的条件"><a href="#需要满足的条件" class="headerlink" title="需要满足的条件"></a>需要满足的条件</h4><p>有可能找到e, d, n的值, 使得对所有$M&lt;n$有$M^{ed}\ mod\ n = M$。<br>对于所有$M&lt;n$的值, 要计算$M^e$和$C^d$是相对容易的。<br>在给定e和n时, 计算d是不可行的。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>已知：$ed\ mod\  \varphi (n)=1，M&lt;n$<br>求证：$M^{ed}\ mod\ n=M$<br><img src="http://pg60us30v.bkt.clouddn.com//image/RSA.jpg" alt=""></p><h4 id="可能的攻击方式"><a href="#可能的攻击方式" class="headerlink" title="可能的攻击方式"></a>可能的攻击方式</h4><p>穷举攻击：尝试所有可能的密钥<br>数学攻击：对两个素数乘积的因子分解(FAC问题)<br>计时攻击：依赖于解密算法的运行时间<br>RSA的安全性问题依赖于大合数的素因子分解。</p><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><h3 id="几种公钥分配方法"><a href="#几种公钥分配方法" class="headerlink" title="几种公钥分配方法"></a>几种公钥分配方法</h3><p>公开发布、公开可访问的目录、公钥授权、公钥证书</p><h4 id="公开发布"><a href="#公开发布" class="headerlink" title="公开发布"></a>公开发布</h4><p><img src="http://pg60us30v.bkt.clouddn.com//image/%E8%87%AA%E7%94%B1%E5%8F%91%E5%B8%83.png" alt=""></p><h4 id="公开可访问的目录"><a href="#公开可访问的目录" class="headerlink" title="公开可访问的目录"></a>公开可访问的目录</h4><p><img src="http://pg60us30v.bkt.clouddn.com//image/%E5%85%AC%E5%BC%80%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9B%AE%E5%BD%95.png" alt=""><br>一个可信实体或组织负责这个公开目录的维护和分配。</p><ul><li>目录包含{name, public-key}等项。</li><li>每一通信方通过目录管理员以安全的方式注册一个公钥。</li><li>通信方在任何时刻可以用新的密钥替代当前的密钥。</li></ul><p>目录定期更新。<br>目录可通过电子方式访问。<br>安全问题：一旦攻击者获得目录管理员私钥，则可传递伪造的公钥，可以假冒任何通信方以窃取消息，或者修改已有的记录。</p><h4 id="公钥授权"><a href="#公钥授权" class="headerlink" title="公钥授权"></a>公钥授权</h4><p><img src="http://pg60us30v.bkt.clouddn.com//image/%E5%85%AC%E9%92%A5%E6%8E%88%E6%9D%83.png" alt=""><br>(1) A发送带有时间戳的消息给公钥管理员, 请求B的当前公钥。<br>(2) 管理员给A发送用其私钥$KR_{auth}$加密的消息, A用管理员的公钥解密，可以确信该消息来自管理员。</p><p><font color="red"><br>B的公钥$KU_b$，用来加密；<br>原始请求$Request$，A可以验证其请求未被修改；<br>原始时间戳$Time_1$, A可以确定收到的不是来自管理员的旧消息。<br></font><br>(3) A保存B的公钥, 并用它对包含A的标识$ID_A$和$N_1$的消息加密, 然后发送给B。<br>(45) B以同样方式从管理员处得到A的公钥。<br>(6) B用$KUa$对A的$N_1$和B的$N_2$加密, 发送给A。<br>(7) A用B的公钥对$N_2$加密并发送给B, 使B相信其通信伙伴是A。</p><h4 id="公钥证书"><a href="#公钥证书" class="headerlink" title="公钥证书"></a>公钥证书</h4><p><img src="http://pg60us30v.bkt.clouddn.com//image/%E5%85%AC%E9%92%A5%E8%AF%81%E4%B9%A6.png" alt=""><br>有了公钥证书使得不通过实时访问公钥授权部门而实现公钥交换成为可能。<br>公钥证书将一个通信方的身份与他的公开密钥绑定在一起，通常还包括有效期和使用方法等。<br>证书的所有内容必须经由可信公钥授权方或者证书授权方签名后方可生效。<br>知道公钥授权当局公开密钥的任何人都可以验证一个用户的公开密钥证书的有效性。</p><p>对于申请者A，管理员提供的证书为：<br>$C_A = E_{KR_{auth}} [Time_1, ID_A, KU_a]$<br>其他人读取并验证：<br>$D_{KU_{auth}}[C_A]=D_{KU_{auth}} [E_{KR_{auth}} [Time_1, ID_A, KU_a]]=(Time_1, ID_A, KU_a)$</p><h3 id="公钥密码分配传统密码体制密码"><a href="#公钥密码分配传统密码体制密码" class="headerlink" title="公钥密码分配传统密码体制密码"></a>公钥密码分配传统密码体制密码</h3><p>公钥密码算法速度较慢，因此更适合作为传统密码中实现秘密密钥分配的一种手段。<br>下图是一个利用公钥密码体制分配（传输）对称式密码（会话密钥$K_s$）的例子：<br><img src="http://pg60us30v.bkt.clouddn.com//image/%E4%BC%A0%E7%BB%9F%E5%AF%86%E9%92%A5%E5%88%86%E9%85%8D.png" alt=""><br>(1) A用$KU_b$加密消息$N_1$和$ID_A$发送给B。<br>(2) 只有B拥有B的私钥，即$N_1$只有B可见，B产生随机值$N_2$，和$N_1$一起加密后发送给A，A看到$N_1$后即可确定消息是B发来的。<br>(3) 同理，$N_2$只有A可见，B可以确定消息是A发来的。<br>(4) A产生本次会话的密钥，先用自己的私钥加密再用B的公钥加密发送给B。<br>上述过程中存在的安全问题：消息(4)可以进行重放攻击。在下次会话时上次的会话密钥可能已经泄露，攻击者可以重放上次的消息(4)进行攻击。解决方案是将消息(3)和消息(4)合并发送，即(3)$E_{KU_b}[N_2 || E_{KR_a}[K_s]]$。</p><h3 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h3><p>Diffie-Hellman密钥交换算法是一种公钥分发机制。它不是用来加密消息的，所生成的是通信双方共享的会话密钥，必须保密，其值取决于通信双方的私钥和公钥信息。</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>通信双方约定一个大素数(或多项式)p, 和模p的一个素根α（p与α是公开的）<br>双方分别选择一个秘密钥(整数值)，如$x_A&lt; p， x_B&lt; p$<br>计算公钥, 如$y_A = α^{x_A}\ mod\ p, y_B = α^{x_B}\ mod\ p$, 并相互交换<br>双方共享的会话密钥$K_{AB}$可以如下算出<br>$K_{AB} = α^{x_Ax_B}\ mod\ p= y_A^{x_B}\ mod\ p  (which\ B\ can\ compute) = y_B^{x_A}\ mod\ p  (which\ A\ can\ compute) $<br>$K_{AB}$是双方用对称密码通信时共享的密钥<br>如果双方继续通信，可以继续使用这个密钥，除非他们要选择新的密钥</p><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>攻击者如果想要获得x, 则必须解决DLP(离散对数)问题。$X_B=dlog_{α,p}Y_B$，即求$Y_B$的以$α$为底的模$p$的离散对数。</p><h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><p><img src="http://pg60us30v.bkt.clouddn.com//image/mid-attack.jpg" alt=""><br><img src="http://pg60us30v.bkt.clouddn.com//image/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png" alt=""></p><h3 id="ELGamal概率密码系统"><a href="#ELGamal概率密码系统" class="headerlink" title="ELGamal概率密码系统"></a>ELGamal概率密码系统</h3><h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h4><p>假设A和B互相通信，共享大素数$p$，本原元素$α，1≤m≤p-1$<br><strong>加密：</strong><br>A选择$k∈[1, p-1]$, $k$的作用其实即为$x_A$, A访问公共区域找到B的公开密钥$Y_B = α^{x_B}\ mod\ p$, 计算：$K = (Y_B)^k\ mod\ p, 即K = α^{x_Bk}\ mod\ p$<br>$c1 = α^k\ mod\ p$<br>$c2 = mK\ mod\ p$<br>密文即为 $(c1, c2)$<br><strong>解密：</strong><br>B首先恢复K：K $= c1^{x_B}\ mod\ p = α^{kx_B}\ mod\ p$<br>然后恢复m：m $=c2K^{-1}\ mod\ p$。这里的$K^{-1}$指$KK^{-1}\ mod\ p=1$</p><h4 id="效率及安全性"><a href="#效率及安全性" class="headerlink" title="效率及安全性"></a>效率及安全性</h4><p>ElGamal密码体制加密效率是50%，因为密文大小是明文的两倍。<br>ElGamal密码体制是概率密码体制，同样的明文每次加密得到不同的密文, 因为每次随机选择k。<br>ElGamal密码体制的破译难度同Diffie-Hellman的方法,即基于DLP，离散对数问题，最快的算法需要T=exp((ln(p)lnln(p)1/2)次运算。</p><h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><h3 id="消息认证"><a href="#消息认证" class="headerlink" title="消息认证"></a>消息认证</h3><p>消息认证就是验证接受的消息确实来自真正的发送方，且是未经修改过的消息，并且可以认证消息的顺序和及时性。</p><h3 id="消息认证函数"><a href="#消息认证函数" class="headerlink" title="消息认证函数"></a>消息认证函数</h3><h4 id="消息加密"><a href="#消息加密" class="headerlink" title="消息加密"></a>消息加密</h4><p>消息加密本身提供了一种认证手段。<br><strong>对称加密</strong><br><img src="http://pg60us30v.bkt.clouddn.com//image/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png" alt=""></p><ul><li>保密性：如果除了源和宿没有其他人知道密码，那么就保证了保密性。</li><li>认证：宿可以确信消息是由源产生的，因为除了宿以外只有源拥有加密密钥，产生出用此密钥可以解密的密文。</li></ul><p>如果消息可以是任意的位模式，接收方无法确定收到的消息是合法明文的密文（不具有可读性）。因此要求明文具有某种易于识别的结构，如在加密前对每个消息附加一个帧校验序列FCS。<br><img src="http://pg60us30v.bkt.clouddn.com//image/InternalErrorControl.png" alt=""><br>FCS和加密函数E执行的顺序很重要。图中(a)为内部错误控制，攻击者很难产生密文使得控制码仍为正确，所以可以提供认证。图中(b)为外部错误控制，攻击者可以构造出具有正确控制码的消息，虽然不知道解密后的消息是什么，但是可以混淆破坏通信。<br><strong>公钥加密</strong><br><img src="http://pg60us30v.bkt.clouddn.com//image/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86.png" alt=""><br>(b) 保密性：只有接受方具有私钥可以解密消息，因此具有保密性；但公钥是公开的，任何人都可以假冒发送方给接收方发送消息，因此没有认证。<br>(c) 认证和签名：只有发送方有自己的私钥，因此接收方接收到密文并可以解密就可以确定发送方是真实的。如果明文是具有某种结构的（具有可读性以区分真实的明文和随机串），就相当于是一个签名。<br>(d) 保密性、认证和签名：发送方先用自己的私钥加密以作为认证和签名，再用接收方的公钥加密实现保密性。缺点是一次通信执行四次公钥算法（两次加密两次解密）。</p><h4 id="消息认证码MAC"><a href="#消息认证码MAC" class="headerlink" title="消息认证码MAC"></a>消息认证码MAC</h4><p>利用密钥产生一个固定长度的短数据块。假如通信双方共享密钥K，则MAC=C(K,M)。如果接收方通过密钥和消息计算的MAC与收到的一致，那么可以确信(1)消息未被修改过(2)消息来自真正的发送方(3)如果消息中含有序列号，那么可以确定消息顺序是正确的。<br>因为MAC是定长的，而消息数远大于MAC的取值范围，因此MAC是一个多对一的函数。<br>因为K是通信双方所共有的，所以MAC不是数字签名。同时MAC不需要解密，因此不需要具有可逆性，使得MAC比加密更加难以破解。<br><img src="http://pg60us30v.bkt.clouddn.com//image/MAC.png" alt=""><br>(a) 消息认证：整个消息以明文发送，没有保密性，但有消息认证。<br>(b) 与明文捆绑的消息认证和保密性：对明文做MAC然后与明文一起加密。<br>(c) 与密文捆绑的消息认证和保密性：对明文加密，然后对密文做MAC，与密文一起发送。</p><h4 id="散列函数HASH"><a href="#散列函数HASH" class="headerlink" title="散列函数HASH"></a>散列函数HASH</h4><p>一个散列函数以变长的报文M作为输入，产生定长的散列码H(M)作为输出，亦称作报文摘要。 散列码是报文所有比特的函数值，具有差错检测能力，报文任意一比特的改变都将引起散列码的改变。<br><strong>Hash函数的安全性需求</strong></p><table><thead><tr><th>需求</th><th>描述 </th></tr></thead><tbody><tr><td> 输入长度可变</td><td>H可以应用于任意大小的数据块 </td></tr><tr><td> 输出长度固定</td><td>H产生固定长度的输出 </td></tr><tr><td> 效率</td><td>对任意给定的明文x，计算H(x)容易，可由硬件或软件实现 </td></tr><tr><td> 抗原像攻击（单向性）</td><td>对任意给定的散列码h，找到满足H(x)=h的x，在计算上不可行</td></tr><tr><td> 抗第二原像攻击（抗弱碰撞性）</td><td>对任何给定的分组x，找到满足y≠x且H(x)=H(y)的y，在计算上不可行</td></tr><tr><td> 抗强碰撞性</td><td>找到任何满足H(x)=H(y)的偶对(x, y)，在计算上不可行</td></tr><tr><td> 伪随机性</td><td>H的输出满足伪随机性测试标准</td></tr></tbody></table><p>满足前五条的称为弱哈希函数，如果第六条也满足则称为强哈希函数。<br><strong>三个安全特性之间的关系</strong><br>抗强碰撞那么一定抗弱碰撞，反之不成立。<br>抗强碰撞不一定抗原像，反之亦然。<br>抗弱碰撞不一定抗原像，反之亦然。<br>抗强碰撞可以看作是在人群中寻找两个名字相同的人，抗弱碰撞性可以看作是给定一个名字，然后在人群中找一个和这个名字相同的人。</p>]]></content>
    
    <summary type="html">
    
      网络与信息安全复习笔记
    
    </summary>
    
    
      <category term="网络信息安全" scheme="http://liyzy.github.io/tags/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>【python learning】词法结构</title>
    <link href="http://liyzy.github.io/2018/10/17/%E3%80%90python%20learning%E3%80%91%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/"/>
    <id>http://liyzy.github.io/2018/10/17/【python learning】词法结构/</id>
    <published>2018-10-17T07:05:28.324Z</published>
    <updated>2018-10-17T07:36:55.606Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p></p><br><a id="more"></a><p></p><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>通常，python的源代码必须完全由ASCII码组成。若想在程序中的注释和字符串常量中使用非ASCII字符，需在源代码的第一行添加注释<code># -*- coding: &lt;encoding-name&gt; -*-</code></p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>通常python的风格是类名称以大写字母开始，其他的标识符都是小写字母。以单个下划线开始的标识符是私有的，以两个下划线开始的标识符是非常强的私有标识符；如果标识符还以两个下划线结尾，则表示该标志符是python语言定义的特殊名称。</p><h3 id="关键字-3-7-1版本"><a href="#关键字-3-7-1版本" class="headerlink" title="关键字(3.7.1版本)"></a>关键字(3.7.1版本)</h3><pre><code>False      await      else       import     passNone       break      except     in         raiseTrue       class      finally    is         returnand        continue   for        lambda     tryas         def        from       nonlocal   whileassert     del        global     not        withasync      elif       if         or         yield</code></pre><h3 id="逻辑行与物理行"><a href="#逻辑行与物理行" class="headerlink" title="逻辑行与物理行"></a>逻辑行与物理行</h3><p>逻辑行由一个或多个物理行组成。</p><ul><li><p>当某一物理行以backslash(\)结束，并且后面没有注释，就会连接到下一个物理行作为一个逻辑行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">1900</span> &lt; year &lt; <span class="number">2100</span> <span class="keyword">and</span> <span class="number">1</span> &lt;= month &lt;= <span class="number">12</span> \</span><br><span class="line">        <span class="keyword">and</span> <span class="number">1</span> &lt;= day &lt;= <span class="number">31</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= hour &lt; <span class="number">24</span> \</span><br><span class="line">        <span class="keyword">and</span> <span class="number">0</span> &lt;= minute &lt; <span class="number">60</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= second &lt; <span class="number">60</span>:  <span class="comment"># Looks like a valid date</span></span><br><span class="line">    print(<span class="string">"It's a valid date."</span>)</span><br></pre></td></tr></table></figure></li><li><p>如果一个左边的圆括号、方括号、花括号还没有对应的右括号，则python会自动把多个物理行连接成一个逻辑行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">month_names = [<span class="string">'January'</span>, <span class="string">'February'</span>, <span class="string">'March'</span>,      <span class="comment"># These are the</span></span><br><span class="line">               <span class="string">'April'</span>,   <span class="string">'May'</span>,      <span class="string">'June'</span>,       <span class="comment"># Dutch names</span></span><br><span class="line">               <span class="string">'July'</span>,    <span class="string">'August'</span>, <span class="string">'September'</span>,  <span class="comment"># for the months</span></span><br><span class="line">               <span class="string">'October'</span>, <span class="string">'November'</span>, <span class="string">'December'</span>]   <span class="comment"># of the year</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      本篇学习python词法结构
    
    </summary>
    
    
      <category term="python" scheme="http://liyzy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>僕が死のうと思ったのは</title>
    <link href="http://liyzy.github.io/2018/10/12/%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF/"/>
    <id>http://liyzy.github.io/2018/10/12/僕が死のうと思ったのは/</id>
    <published>2018-10-12T13:04:24.154Z</published>
    <updated>2018-10-17T05:39:38.350Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"http://pg60us30v.bkt.clouddn.com//vedio/%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.mp4","pic":"http://pg60us30v.bkt.clouddn.com//image/image-video/%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
    
    <summary type="html">
    
      一味考虑着死的事 一定是因为太过认真地活
    
    </summary>
    
    
      <category term="music" scheme="http://liyzy.github.io/tags/music/"/>
    
      <category term="video" scheme="http://liyzy.github.io/tags/video/"/>
    
  </entry>
  
  <entry>
    <title>【java学习笔记】全系列内容提要篇</title>
    <link href="http://liyzy.github.io/2018/10/06/%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%85%A8%E7%B3%BB%E5%88%97%E5%86%85%E5%AE%B9%E6%8F%90%E8%A6%81%E7%AF%87/"/>
    <id>http://liyzy.github.io/2018/10/06/【java学习笔记】全系列内容提要篇/</id>
    <published>2018-10-06T13:58:03.611Z</published>
    <updated>2018-10-06T14:16:57.650Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p></p><br><a id="more"></a><p></p><h2 id="【java学习笔记1】"><a href="#【java学习笔记1】" class="headerlink" title="【java学习笔记1】"></a>【java学习笔记1】</h2><p>基本数据类型<br>对象和类<br>数据声明<br>函数声明<br>参数传递 </p><h2 id="【java学习笔记2】"><a href="#【java学习笔记2】" class="headerlink" title="【java学习笔记2】"></a>【java学习笔记2】</h2><p>数组<br>运算符<br>包<br>访问权限<br>修饰符</p><h2 id="【java学习笔记3】"><a href="#【java学习笔记3】" class="headerlink" title="【java学习笔记3】"></a>【java学习笔记3】</h2><p>继承<br>多态</p><h2 id="【java学习笔记4】"><a href="#【java学习笔记4】" class="headerlink" title="【java学习笔记4】"></a>【java学习笔记4】</h2><p>异常处理</p><h2 id="【java学习笔记5】"><a href="#【java学习笔记5】" class="headerlink" title="【java学习笔记5】"></a>【java学习笔记5】</h2><p>抽象类、抽象函数<br>接口</p><h2 id="【java学习笔记6】"><a href="#【java学习笔记6】" class="headerlink" title="【java学习笔记6】"></a>【java学习笔记6】</h2><p>Object类<br>Class类<br>String类<br>System类<br>包装类</p><h2 id="【java学习笔记7】"><a href="#【java学习笔记7】" class="headerlink" title="【java学习笔记7】"></a>【java学习笔记7】</h2><p>泛型</p><h2 id="【java学习笔记8】"><a href="#【java学习笔记8】" class="headerlink" title="【java学习笔记8】"></a>【java学习笔记8】</h2><p>集合类，集合接口<br>Collection类<br>List LinkedList ArrayList<br>Map HashMap TreeMap<br>Set HashSet TreeSet</p><h2 id="【java学习笔记9】"><a href="#【java学习笔记9】" class="headerlink" title="【java学习笔记9】"></a>【java学习笔记9】</h2><p>File<br>RandomAccessFile<br>文本流<br>Preoperties  // 配置文件的使用<br>多线程</p><h2 id="【java学习笔记10】"><a href="#【java学习笔记10】" class="headerlink" title="【java学习笔记10】"></a>【java学习笔记10】</h2><p>线程同步、锁</p><h2 id="【java学习笔记11】"><a href="#【java学习笔记11】" class="headerlink" title="【java学习笔记11】"></a>【java学习笔记11】</h2><p>网络编程</p><h2 id="【java学习笔记12】"><a href="#【java学习笔记12】" class="headerlink" title="【java学习笔记12】"></a>【java学习笔记12】</h2><p>数据库编程</p><p><em>我比较懒，另一方面由于还在上学，时间比较少，慢慢更新~</em></p>]]></content>
    
    <summary type="html">
    
      这是【java学习笔记】这个系列的一个内容提要，相当于是一个目录吧，方便更快找到要找的知识点
    
    </summary>
    
    
      <category term="JAVA" scheme="http://liyzy.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>双系统安装Ubuntu18.04</title>
    <link href="http://liyzy.github.io/2018/10/01/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    <id>http://liyzy.github.io/2018/10/01/双系统安装/</id>
    <published>2018-10-01T06:24:25.819Z</published>
    <updated>2018-10-06T15:10:11.648Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p></p><br><a id="more"></a><p></p><h3 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h3><p>以<a href="https://www.ubuntu.com/download/desktop" target="_blank" rel="noopener">Ubuntu18.04</a>为例</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>工具为<a href="https://cn.ultraiso.net/xiazai.html" target="_blank" rel="noopener">软碟通UltraISO</a>。</p><ul><li>准备一个U盘，格式化。</li><li>以管理员身份运行软碟通，菜单栏里选择“启动-&gt;写入硬盘映像”，写入方式选择“usb-HDD+”，“便捷启动-&gt;写入新的驱动程序引导扇区-&gt;Syslinux”。<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4>工具为<a href="http://rufus.akeo.ie/" target="_blank" rel="noopener">rufus</a>。</li><li>这是一个Ubuntu官方推荐的工具，用起来还是很方便的。唯一需要注意的就是选择Partition schema为MBR还是GPT。</li><li>查看硬盘分区表类型可以使用windows下的磁盘管理。点击要查看的硬盘，右键，“属性-&gt;卷”就能看到了。<br>还有很多其他的工具可用，不一一赘述了。<h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3></li><li>首先，重启电脑进入BIOS，关闭安全启动(如果之前装过双系统的话应该关掉了)，设置第一启动项为U盘启动，设置完成后保存退出。</li><li>这时候电脑应该会自动重启，重启之后应该就是Ubuntu的安装引导了，选择Install Ubuntu。</li><li>选择语言和键盘布局。</li><li>在联网这一项上，选择暂不连接网络，这样可以加快安装的进度，一些东西可以安好系统后自己选择安装。</li><li>选择最小安装，其他的不用选。</li><li>如果要装双系统，选择与Windows共存就好了，Ubuntu可以自己选择你未分配的空间作为安装空间(前提是你有未分配的空间)。网上的一些教程都交了如何自己分区，非老手且没有什么特殊需求建议不要尝试了，没什么用。如果只保留Ubuntu，选择只保留Ubuntu就好了。</li><li>接下来就是一些时区，用户名的设置了。</li><li>设置完后，安装就开始了，大约需要30分钟左右吧(当然这要视电脑情况而定qwq)。<h3 id="系统升级"><a href="#系统升级" class="headerlink" title="系统升级"></a>系统升级</h3>如果之前你是16.04或者17.10等其他的版本，也可以升级到18.04版本。(注意提前做好备份，万一装崩了呢/doge)</li><li><p>首先，更新升级已安装的软件包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt dist-upgrade</span><br><span class="line">sudo apt autoremove</span><br></pre></td></tr></table></figure></li><li><p>在软件更新器里选择更新版本为长期支持版本。</p></li><li>安装update-manager-core <code>sudo apt-get install update-manager-core</code></li><li>执行<code>sudo do-release-upgrade -d</code>等待完成就ok了，我大概用了100分钟的时间。<h3 id="安装Gnome插件"><a href="#安装Gnome插件" class="headerlink" title="安装Gnome插件"></a>安装Gnome插件</h3>Ubuntu18.04回归了gnome桌面，意味着我们可以使用很多有用的插件来使它更加的高效和炫酷。<br>如何安装gnome插件呢？<br>网上说了很多方法，有用Tweaks的，有在官网下载后解压的。这些方法首先肯定都没错。但是我一开始也是用的这两种方法进行尝试，然鹅并没有成功。万念俱灰之际，我发现在Ubuntu的软件中心有一个附加组件项，点进去，卧槽，这不就是现成的嘛…<br>推荐几个插件吧：<br>Simple net speed    顶栏实时网速显示<br>Openweather            顶栏显示天气<br>EasyScreenCast        录屏<br>Coverflow alt-tab    效果超赞的 alt-tab 切换效果<br>……<br>更多有趣的插件自己探索吧~</li></ul>]]></content>
    
    <summary type="html">
    
      十一假期，想要卸载掉deepin，Ubuntu18.04已经发布半年了，bug应该改的差不多了，想要尝试一下，而且18.04的桌面看起来有点好看的感觉欸~
    
    </summary>
    
    
      <category term="操作系统" scheme="http://liyzy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>词法分析器</title>
    <link href="http://liyzy.github.io/2018/10/01/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>http://liyzy.github.io/2018/10/01/词法分析/</id>
    <published>2018-10-01T06:18:20.686Z</published>
    <updated>2018-10-06T09:22:15.815Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p></p><br><a id="more"></a><p></p><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><blockquote><p>In computer science, lexical analysis, lexing or tokenization is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of tokens (strings with an assigned and thus identified meaning).<br>在计算机科学中，词法分析，lexing或标记化是将一系列字符（例如在计算机程序或网页中）转换成一系列标记（具有指定且因此标识的含义的字符串）的过程。</p></blockquote><h2 id="编码目标"><a href="#编码目标" class="headerlink" title="编码目标"></a>编码目标</h2><p>给定一个源代码文件，能够将其转化为词法记号流。<br>比如规定int的词法记号为30，输出就是&lt;30,  int&gt;；数字的词法记号为11，则输入123，输出为&lt;11, 123&gt;。</p><h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>把程序中的词法单元分为四类：标识符（分为关键字和一般标识符）、数字、特殊字符、空白（空格、Tab、回车换行等）</p><h2 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h2><p><img src="http://pg60us30v.bkt.clouddn.com/image/content/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8-%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="程序流程图"><br>对于运算符等符号，这里只考虑两个字符的组合情况，不考虑三个字符组成的运算符。之所以要在读到特殊字符之后在往后读一个字符是因为有可能在表中存在类似<code>&gt;=</code>和<code>&gt;</code>的运算符，要保证最长字符匹配。</p><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><h3 id="首字符类型判断"><a href="#首字符类型判断" class="headerlink" title="首字符类型判断"></a>首字符类型判断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCharType</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        String regex_Letter = <span class="string">"[a-zA-Z]"</span>;</span><br><span class="line">        String regex_Number = <span class="string">"[0-9]"</span>;</span><br><span class="line">        String regex_Blank = <span class="string">"\\s"</span>;</span><br><span class="line">        Pattern pattern;</span><br><span class="line"></span><br><span class="line">        pattern = Pattern.compile(regex_Letter);</span><br><span class="line">        Matcher matcher = pattern.matcher(str);</span><br><span class="line">        <span class="keyword">if</span> (matcher.find())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"LETTER"</span>;</span><br><span class="line"></span><br><span class="line">        pattern = Pattern.compile(regex_Number);</span><br><span class="line">        matcher = pattern.matcher(str);</span><br><span class="line">        <span class="keyword">if</span> (matcher.find())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"NUMBER"</span>;</span><br><span class="line"></span><br><span class="line">        pattern = Pattern.compile(regex_Blank);</span><br><span class="line">        matcher = pattern.matcher(str);</span><br><span class="line">        <span class="keyword">if</span> (matcher.find())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"BLANK"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"SPECIAL"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="如果首字符为字母"><a href="#如果首字符为字母" class="headerlink" title="如果首字符为字母"></a>如果首字符为字母</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"LETTER"</span>:</span><br><span class="line">pattern = Pattern.compile(regex_ID);</span><br><span class="line">matcher = pattern.matcher(srcCode);</span><br><span class="line"><span class="keyword">if</span> (matcher.lookingAt()) &#123;</span><br><span class="line">String result = matcher.group();</span><br><span class="line"><span class="keyword">if</span> (LexicalToken.isKeyWord(result)) &#123;</span><br><span class="line"><span class="keyword">int</span> token = lextok.getToken(result);</span><br><span class="line">System.out.printf(<span class="string">"&lt;%d,%s&gt;  "</span>, token, result);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> token = lextok.getToken(<span class="string">"ID"</span>);</span><br><span class="line">System.out.printf(<span class="string">"&lt;%d,%s&gt;  "</span>, token, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">srcCode = srcCode.substring(matcher.end());</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="如果首字符是数字"><a href="#如果首字符是数字" class="headerlink" title="如果首字符是数字"></a>如果首字符是数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"NUMBER"</span>:</span><br><span class="line">pattern = Pattern.compile(regex_NUM);</span><br><span class="line">    matcher = pattern.matcher(srcCode);</span><br><span class="line">    <span class="keyword">if</span> (matcher.lookingAt()) &#123;</span><br><span class="line">    String result = matcher.group();</span><br><span class="line">        <span class="keyword">int</span> token = lextok.getToken(<span class="string">"NUM"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"&lt;%d,%s&gt;  "</span>, token, result);</span><br><span class="line">     &#125;</span><br><span class="line">     srcCode = srcCode.substring(matcher.end());</span><br><span class="line">     <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="如果首字符是空格"><a href="#如果首字符是空格" class="headerlink" title="如果首字符是空格"></a>如果首字符是空格</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"BLANK"</span>:</span><br><span class="line">srcCode = srcCode.substring(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="如果首字符是特殊符号"><a href="#如果首字符是特殊符号" class="headerlink" title="如果首字符是特殊符号"></a>如果首字符是特殊符号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"SPECIAL"</span>:</span><br><span class="line"><span class="keyword">if</span> (srcCode.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    String secondChar = srcCode.substring(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        String result;</span><br><span class="line">        LinkedHashMap tokenMap = lextok.getLexicalTokenMap();</span><br><span class="line">        Set set = tokenMap.keySet();</span><br><span class="line">        result = firstChar + secondChar;</span><br><span class="line">        <span class="keyword">if</span> (getCharType(secondChar).equals(<span class="string">"SPECIAL"</span>) &amp;&amp; set.contains(result)) &#123;</span><br><span class="line">            <span class="keyword">int</span> token = lextok.getToken(result);</span><br><span class="line">            System.out.printf(<span class="string">"&lt;%d,%s&gt;  "</span>, token, result);</span><br><span class="line">            srcCode = srcCode.substring(<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = firstChar;</span><br><span class="line">            <span class="keyword">int</span> token = lextok.getToken(result);</span><br><span class="line">            System.out.printf(<span class="string">"&lt;%d,%s&gt;  "</span>, token, result);</span><br><span class="line">            srcCode = srcCode.substring(<span class="number">1</span>);</span><br><span class="line">              &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// 字符串中只有一个字符时</span></span><br><span class="line">           <span class="keyword">int</span> token = lextok.getToken(srcCode);</span><br><span class="line">           System.out.printf(<span class="string">"&lt;%d,%s&gt;  "</span>, token, srcCode);</span><br><span class="line">           srcCode = srcCode.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>源码地址：<a href="https://github.com/Liyzy/Lexer" target="_blank" rel="noopener">https://github.com/Liyzy/Lexer</a><br>开发环境：IJ idea 2018.2</p>]]></content>
    
    <summary type="html">
    
      词法分析，lexing或标记化是将一系列字符（例如在计算机程序或网页中）转换成一系列标记（具有指定且因此标识的含义的字符串）的过程。
    
    </summary>
    
    
      <category term="JAVA" scheme="http://liyzy.github.io/tags/JAVA/"/>
    
      <category term="编译原理" scheme="http://liyzy.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>双系统卸载</title>
    <link href="http://liyzy.github.io/2018/09/23/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%8D%B8%E8%BD%BD/"/>
    <id>http://liyzy.github.io/2018/09/23/双系统卸载/</id>
    <published>2018-09-23T12:38:58.017Z</published>
    <updated>2018-10-06T12:02:29.635Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p></p><br><a id="more"></a><br>本文主要针对windows+Linux双系统卸载Linux/Unix系统(Ubuntu\Deepin...)。<p></p><h1 id="删除系统"><a href="#删除系统" class="headerlink" title="删除系统"></a>删除系统</h1><p>在windows上，右键开始打开磁盘管理(或者直接搜索“磁盘管理”)，看到装有Linux系统的硬盘分区，右键删除卷，删除后分区变为“未分配”。如果不安装新的系统，可以“新建简单卷”；如果还要安装别的系统，就暂不处理。</p><p>如果之前Linux/Unix系统是第一启动项，那么这时候你重启计算机的话是会出现错误的，因为引导找不到这个系统了。而且，在BIOS的启动项里还存在着这个系统。这时我们就要修复引导。</p><h1 id="修复引导"><a href="#修复引导" class="headerlink" title="修复引导"></a>修复引导</h1><p>我们用到一个工具：<a href="https://www.easyuefi.com/index-us.html" target="_blank" rel="noopener">EasyUEFI</a> 下个试用版就OK。<br>运行EasyUEFI，选择“管理EFI启动项”，可以看到你要卸载的系统的启动项，选中，选择“删除选中项”。<br>之后在进入BIOS查看启动项，发现只剩下一个windows的启动项了，成功！</p>]]></content>
    
    <summary type="html">
    
      双系统，只留一个或者想换另一种系统玩一下，第一步都要先卸载不要的系统，只格式化所在分区就行了麽？
    
    </summary>
    
    
      <category term="操作系统" scheme="http://liyzy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>【python学习笔记1】数据类型篇</title>
    <link href="http://liyzy.github.io/2018/09/22/%E3%80%90python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%91/"/>
    <id>http://liyzy.github.io/2018/09/22/【python学习笔记1】/</id>
    <published>2018-09-22T01:53:58.495Z</published>
    <updated>2018-10-17T07:11:12.986Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p></p><br><a id="more"></a><p></p><h2 id="python简单介绍"><a href="#python简单介绍" class="headerlink" title="python简单介绍"></a>python简单介绍</h2><blockquote><p>作为一种<em>解释型语言</em>，Python的设计哲学强调代码的可读性和简洁的语法（尤其是使用空格缩进划分代码块，而非使用大括号或者关键词）。<br>与Scheme、Ruby、Perl、Tcl等动态类型编程语言一样，Python拥有<em>动态类型</em>系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。其本身拥有一个巨大而广泛的标准库。<br>Python是完全物件导向的语言。函数、模组、数字、字串都是物件。并且完全支持继承、重载、派生、多重继承，有益于增强原始码的复用性。Python支持重载运算符，因此Python也支持泛型设计。<br>Python编译器本身也可以被集成到其它需要脚本语言的程式内。因此，有很多人把Python作为一种<em>“胶水语言”</em>使用。使用Python将其他语言编写的程式进行集成和封装。<br>Python属于<em>动态类型语言</em>，动态类型语言是在运行期间检查数据的类型，不得不保持描述变量值的实际类型标记，程序在每次操作变量时，需要执行数据依赖分支，而静态类型语言相对于动态类型语言，在声明变量时已经指定了数据类型和表示方法，根据这一原理导致Python相对于C、Visual Basic等静态类型语言来说<em>运行速度较慢</em>。</p><p>摘录自Wikipedia</p></blockquote><h2 id="python数据类型"><a href="#python数据类型" class="headerlink" title="python数据类型"></a>python数据类型</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>python中没有关键字表示常量，用大写来代表这是一个常量。例如NUM=5，NUM就是一个常量。因此，在编写python代码时，要严格区分大小写。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>python中变量声明不需要声明变量类型。<br>但是，python是一种强类型语言，不能因此而判断python是弱类型的。<br><strong>python是动态的、强类型的语言。</strong><br><a href="https://wiki.python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language" target="_blank" rel="noopener">Why is Python a dynamic language and also a strongly typed language？</a></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="分为两大类：内置数据类型、自定义数据类型"><a href="#分为两大类：内置数据类型、自定义数据类型" class="headerlink" title="分为两大类：内置数据类型、自定义数据类型"></a>分为两大类：内置数据类型、自定义数据类型</h4><p>内置数据类型分为：数值、序列、集合、字典、特殊、其他<br>数值数据类型：整数、浮点数、布尔、复数<br>序列数据类型：字符串、元组、字节序列、列表、字节数组<br>集合数据类型：集、不可变集</p><h4 id="内置的type-函数可以用来查询变量所指的对象类型"><a href="#内置的type-函数可以用来查询变量所指的对象类型" class="headerlink" title="内置的type()函数可以用来查询变量所指的对象类型"></a>内置的type()函数可以用来查询变量所指的对象类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="keyword">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(a), type(b), type(c), type(d))</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt; &lt;type <span class="string">'float'</span>&gt; &lt;type <span class="string">'bool'</span>&gt; &lt;type <span class="string">'complex'</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a>int类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myInt = <span class="number">5</span> </span><br><span class="line">myInt = int(<span class="number">5</span>) <span class="comment">#int对象方式</span></span><br><span class="line">int(<span class="number">5.4</span>) <span class="comment">#自动类型转换</span></span><br><span class="line">int(<span class="string">"123"</span>) <span class="comment">#自动类型转换</span></span><br><span class="line"><span class="comment">#二进制以0b开头，八进制以0开头，十六进制以0x开头</span></span><br></pre></td></tr></table></figure><h4 id="float类型"><a href="#float类型" class="headerlink" title="float类型"></a>float类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myFloat = float(<span class="number">3.14</span>)</span><br><span class="line">myFloat = float(<span class="number">4</span>) <span class="comment">#自动类型转换，输出结果4.0</span></span><br></pre></td></tr></table></figure><h4 id="复数数据类型-虚部必须用j"><a href="#复数数据类型-虚部必须用j" class="headerlink" title="复数数据类型 虚部必须用j"></a>复数数据类型 虚部必须用j</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="number">1j</span> <span class="comment">#不可写成1+j</span></span><br><span class="line"><span class="number">0</span>+<span class="number">0j</span> <span class="comment">#0不能省略</span></span><br><span class="line">complex(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">#其中1为实部，2为虚部</span></span><br><span class="line">c1=complex(<span class="number">6</span>) <span class="comment">#输出c1为6+0j,等同于complex(6,0) complex(6,)</span></span><br><span class="line">c2=complex(<span class="number">2.1</span>,<span class="number">3.2</span>) <span class="comment">#实部与虚部可以为浮点数</span></span><br><span class="line"><span class="comment">#real:复数的实部 imag:复数的虚部  c2.real输出结果2.1,c2.imag输出结果3.2</span></span><br></pre></td></tr></table></figure><h4 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">True False开头首字母必须大写</span></span><br><span class="line"><span class="string">bool对象 bool(False)</span></span><br><span class="line"><span class="string">bool(0),bool(0.0) 结果为False,任何非零均为True例如   bool('0'),bool(5),bool(2.3),bool("abc")</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><h5 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h5><p><code>&quot;abc&quot;</code>  <code>&#39;abc&#39;</code>  <code>&#39;&#39;&#39;abc&#39;&#39;&#39;</code>  <code>&quot;&quot;&quot;abc&quot;&quot;&quot;</code>  前两个表示一行，后两个表示可以跨行</p><h5 id="字符串拼接与重复"><a href="#字符串拼接与重复" class="headerlink" title="字符串拼接与重复"></a>字符串拼接与重复</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"abc"</span>+<span class="string">'def'</span>  <span class="comment">#使用+进行字符串连接</span></span><br><span class="line"><span class="string">'abcdef'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"abc"</span> <span class="string">'def'</span>  <span class="comment">#默认自动连接</span></span><br><span class="line"><span class="string">'abcdef'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"abc"</span>*<span class="number">2</span>  <span class="comment"># *表示重复，*后的整数表示重复次数</span></span><br><span class="line"><span class="string">'abcabc'</span></span><br></pre></td></tr></table></figure><h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h5><table><thead><tr><th style="text-align:center">转义字符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">\n</td><td style="text-align:center">换行</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:center">回车</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:center">水平制表符</td></tr><tr><td style="text-align:center">\v</td><td style="text-align:center">垂直制表符</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">退格</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:center">换页</td></tr></tbody></table><p>使用r或R为开头的字符串成为原始字符串，其中包含的任何字符都不可进行转义。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myStr = <span class="string">r"abc\n"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(myStr)</span><br><span class="line"><span class="string">'abc\n'</span></span><br></pre></td></tr></table></figure></p><h5 id="str对象"><a href="#str对象" class="headerlink" title="str对象"></a>str对象</h5><p>str()<br>str(.14) 输出结果为 ‘0.14’ ，浮点数前导0可省略,隐式类型转换。</p><h5 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h5><p>Python中的字符串有两种索引方式，第一种是从左往右，从0开始依次增加；第二种是从右往左，从-1开始依次减少。<br><strong>注意，没有单独的字符类型，一个字符就是长度为1的字符串。</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">'Python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(word[<span class="number">0</span>], word[<span class="number">5</span>])</span><br><span class="line">P n</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(word[<span class="number">-1</span>], word[<span class="number">-6</span>])</span><br><span class="line">n P</span><br></pre></td></tr></table></figure></p><h5 id="字符串截取子串"><a href="#字符串截取子串" class="headerlink" title="字符串截取子串"></a>字符串截取子串</h5><p>用冒号分隔两个索引，形式为变量[头下标:尾下标]。<br>截取的范围是前闭后开的，并且两个索引都可以省略：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">'ilovepython'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line"><span class="string">'love'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:]</span><br><span class="line"><span class="string">'ilovepython'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">5</span>:]</span><br><span class="line"><span class="string">'python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-10</span>:<span class="number">-6</span>]</span><br><span class="line"><span class="string">'love'</span></span><br></pre></td></tr></table></figure></p><p>Python字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。</p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h5 id="列表的创建方式"><a href="#列表的创建方式" class="headerlink" title="列表的创建方式"></a>列表的创建方式</h5><h6 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h6><p>[x1,x2,x3,x4,…,xn]<br>列表中元素类型可以不同，如[1, 2, 3, ‘q’, True]<br>列表中的元素可以是表达式，如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">temp = [x + x, x * x, <span class="number">11</span>]</span><br><span class="line">list = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],<span class="number">8</span>]</span><br></pre></td></tr></table></figure></p><h6 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = list()  <span class="comment">#空列表</span></span><br><span class="line">list2 = list(<span class="string">"abcd"</span>)  <span class="comment">#结果['a', 'b', 'c', 'd']</span></span><br><span class="line">list3 = list(range(<span class="number">3</span>))  <span class="comment">#结果[0, 1, 2]</span></span><br></pre></td></tr></table></figure><h6 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h6><p>使用非常简单的表达式满足特定的列表<br><code>表达式　for 变量　in 序列</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list4 = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line">print(list4)   <span class="comment">#结果[1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line">list5 = [i <span class="keyword">for</span> i <span class="keyword">in</span> list4 <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>]  <span class="comment">#结果[4, 16, 36, 64]</span></span><br></pre></td></tr></table></figure></p><h5 id="列表的操作"><a href="#列表的操作" class="headerlink" title="列表的操作"></a>列表的操作</h5><p>列表的操作包括：索引、切片、连接、重复、成员关系、比较、求长度、最大值、最小值等</p><h6 id="索引访问"><a href="#索引访问" class="headerlink" title="索引访问"></a>索引访问</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list6 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(list6[<span class="number">0</span>], list6[<span class="number">-1</span>])  <span class="comment">#结果１　３</span></span><br><span class="line">list6[<span class="number">0</span>] = <span class="number">10</span>  <span class="comment">#list中的值可以改变，此时list6为[10, 2, 3]</span></span><br></pre></td></tr></table></figure><h6 id="删除列表中的元素"><a href="#删除列表中的元素" class="headerlink" title="删除列表中的元素"></a>删除列表中的元素</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list7 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  <span class="comment">#[1,2,3,4,5]</span></span><br><span class="line"><span class="keyword">del</span> list7[<span class="number">1</span>]  <span class="comment">#[1,3,4,5]</span></span><br></pre></td></tr></table></figure><h6 id="求长度、最大值、最小值、和"><a href="#求长度、最大值、最小值、和" class="headerlink" title="求长度、最大值、最小值、和"></a>求长度、最大值、最小值、和</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">list８ = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]  <span class="comment">#[1,2,3,4,5,6]</span></span><br><span class="line">len(list8)  <span class="comment">#6</span></span><br><span class="line">min(list8)  <span class="comment">#1</span></span><br><span class="line">max(list8)  <span class="comment">#6</span></span><br><span class="line">sum(list8)  <span class="comment">#21</span></span><br><span class="line">list9 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">'a'</span>,<span class="number">5</span>]</span><br><span class="line">len(list9)  <span class="comment">#6</span></span><br><span class="line">max(list9)  <span class="comment">#TypeError: unorderable types: str() &gt; int(), min和sum同样错误。</span></span><br><span class="line">list10 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]  <span class="comment">#可以算len,max,min，但不能求和</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python 2.7.15中测试结果如下</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">'a'</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>max(list1)</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min(list1)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(list1)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> +: <span class="string">'int'</span> <span class="keyword">and</span> <span class="string">'str'</span></span><br></pre></td></tr></table></figure><h6 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h6><p>s[i:j]    从索引i开始，到j结束，左闭右开。省略i从0开始，省略j到结尾结束<br>s[i:j:k]　k表示步长<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">temp = list1[<span class="number">1</span>:<span class="number">6</span>:<span class="number">2</span>]</span><br><span class="line">print(temp)  <span class="comment"># 结果[2, 4, 6]</span></span><br><span class="line">list1[:<span class="number">1</span>] = []  <span class="comment"># list1变为[2,3,4,5,6,7]</span></span><br></pre></td></tr></table></figure></p><h6 id="连接与重复"><a href="#连接与重复" class="headerlink" title="连接与重复"></a>连接与重复</h6><p>连接<code>+</code>　重复<code>*</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list3 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">print(list2+list3)  <span class="comment"># 结果[1, 2, 3, 3, 4, 5],只连接不去重</span></span><br><span class="line">print(<span class="number">2</span>*list2)  <span class="comment"># 结果[1, 2, 3, 1, 2, 3]</span></span><br><span class="line">list2 += list3  <span class="comment"># 结果[1, 2, 3, 3, 4, 5],等价于list2 = list2 + list3</span></span><br></pre></td></tr></table></figure></p><h6 id="成员关系操作"><a href="#成员关系操作" class="headerlink" title="成员关系操作"></a>成员关系操作</h6><p>判断一个元素是否在列表中<br><code>in</code> 和<code>not in</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(<span class="number">7</span> <span class="keyword">in</span> list1)  <span class="comment"># False</span></span><br><span class="line">print(<span class="number">3</span> <span class="keyword">in</span> list1)  <span class="comment"># True</span></span><br><span class="line">print(list1.count(<span class="number">3</span>))  <span class="comment"># 3  计算某一个元素在列表中出现的次数</span></span><br><span class="line">print(list1.index(<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>))  <span class="comment"># 2 查找某个元素在给定范围内第一次出现的索引,例子中范围为[2,6)</span></span><br></pre></td></tr></table></figure></p><h6 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">list2 = [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">list3 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">list4 = [<span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]</span><br><span class="line">print(list1 == list2)  <span class="comment"># True</span></span><br><span class="line">print(list3 &gt; list2)   <span class="comment"># True</span></span><br><span class="line">print(list3 &gt; list4)   <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 从第一个元素开始比较</span></span><br></pre></td></tr></table></figure><h6 id="列表的排序"><a href="#列表的排序" class="headerlink" title="列表的排序"></a>列表的排序</h6><p><code>sorted(list1))</code></p><h6 id="any-和all"><a href="#any-和all" class="headerlink" title="any()和all()"></a>any()和all()</h6><p>any() 列表中是否有元素为True<br>all() 列表中的元素是否都为True</p><h6 id="列表的拆分"><a href="#列表的拆分" class="headerlink" title="列表的拆分"></a>列表的拆分</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">a,b,c,d = list1</span><br><span class="line">print(a,b,c,d)  <span class="comment"># 结果１　２　３　４</span></span><br><span class="line"><span class="comment">#　应保证前面的变量数与列表的长度相同</span></span><br></pre></td></tr></table></figure><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><h5 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h5><p>定值表，用来存储不变值表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>         <span class="comment"># 表示元组</span></span><br><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)       <span class="comment"># 表示元组</span></span><br><span class="line">t = ()              <span class="comment"># 表示空元组</span></span><br><span class="line">t = <span class="number">1</span>,              <span class="comment"># 表示只有一个元素的元组，必须有逗号</span></span><br><span class="line">t = tuple(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)  <span class="comment"># 错误写法，只能有一个参数</span></span><br><span class="line">t = tuple([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])<span class="comment"># 正确写法</span></span><br><span class="line">t = tuple(<span class="string">"abcd"</span>)   <span class="comment"># 结果为（'a','b','c','d'）</span></span><br><span class="line">t = tuple(range(<span class="number">8</span>)) </span><br><span class="line">t = tuple(<span class="number">2</span>*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>)) <span class="comment"># 结果为(2,4,6,8)</span></span><br></pre></td></tr></table></figure></p><h5 id="元组的操作"><a href="#元组的操作" class="headerlink" title="元组的操作"></a>元组的操作</h5><p>索引访问、切片、连接、重复、成员关系、最大值、最小值、和、长度、排序等<br>与列表的操作类似，可以进行对比。一些内容不作赘述。</p><h6 id="元组的排序"><a href="#元组的排序" class="headerlink" title="元组的排序"></a>元组的排序</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tuple1 = tuple([<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>])</span><br><span class="line">print(tuple1)</span><br><span class="line">print(sorted(tuple1))</span><br><span class="line">print(tuple1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>]  <span class="comment"># 输出的是列表</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>)  <span class="comment"># 原元组没有变化</span></span><br></pre></td></tr></table></figure><h6 id="元组的拆分"><a href="#元组的拆分" class="headerlink" title="元组的拆分"></a>元组的拆分</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a, *s, d, f = tuple1 </span><br><span class="line">print(a, d, f)      <span class="comment"># 结果为 2 4 6</span></span><br><span class="line">a, s, d, *f = tuple1</span><br><span class="line">print(a, s, d)      <span class="comment"># 结果为 2 1 9</span></span><br><span class="line"><span class="comment"># 元组的拆分前面变量的个数必须与元组元素个数相等。如果元组元素个数过多，可以使用*代表多个变量</span></span><br><span class="line"></span><br><span class="line">_, a, b, _, *_ = tuple1</span><br><span class="line">print(a, b, _)      <span class="comment"># 结果为 1 9 [4, 6]</span></span><br><span class="line"><span class="comment"># 没有意义的命名可以使用临时变量下划线(_)表示。输出临时变量，只会保留最后一个。</span></span><br></pre></td></tr></table></figure><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><h5 id="字面量-1"><a href="#字面量-1" class="headerlink" title="字面量"></a>字面量</h5><p><code>{键:值,键:值,键:值,键:值,}</code></p><h5 id="字典对象"><a href="#字典对象" class="headerlink" title="字典对象"></a>字典对象</h5><p><code>dict()</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(dict([[<span class="string">'优'</span>,<span class="number">90</span>],[<span class="string">'良'</span>,<span class="number">80</span>]]))</span><br><span class="line">print(dict(((<span class="string">'优'</span>,<span class="number">90</span>),(<span class="string">'良'</span>,<span class="number">80</span>))))</span><br><span class="line">print(dict(zip([<span class="string">'优'</span>,<span class="string">'良'</span>],[<span class="number">90</span>,<span class="number">80</span>])))</span><br><span class="line"><span class="comment"># 结果均为 &#123;'优': 90, '良': 80&#125;</span></span><br><span class="line">dict1 = dict(a=<span class="string">"apple"</span>, b=<span class="string">"banane"</span>)  <span class="comment"># &#123;'a':'apple', 'b':'banane'&#125;</span></span><br></pre></td></tr></table></figure></p><h5 id="fromkeys"><a href="#fromkeys" class="headerlink" title="fromkeys()"></a>fromkeys()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict2 = &#123;&#125;.fromkeys([<span class="string">'优'</span>,<span class="string">'良'</span>],<span class="string">"大于70分"</span>)  <span class="comment"># &#123;'优': '大于70分', '良': '大于70分'&#125;</span></span><br><span class="line">dict3 = &#123;&#125;.fromkeys([<span class="string">'优'</span>,<span class="string">'良'</span>])  <span class="comment"># &#123;'优': None, '良': None&#125;</span></span><br><span class="line">dict4 = &#123;&#125;.fromkeys([<span class="string">'优'</span>,<span class="string">'良'</span>],<span class="keyword">None</span>)  <span class="comment"># &#123;'优': None, '良': None&#125;</span></span><br></pre></td></tr></table></figure><h5 id="推导式-1"><a href="#推导式-1" class="headerlink" title="推导式"></a>推导式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict5 = &#123;n:n**<span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>)&#125; <span class="comment"># &#123;1:1,2:4,3:9,4:16&#125;</span></span><br></pre></td></tr></table></figure><h5 id="得到键对应的值"><a href="#得到键对应的值" class="headerlink" title="得到键对应的值"></a>得到键对应的值</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dict2[<span class="string">'优'</span>]  <span class="comment"># 大于70分</span></span><br><span class="line">dict2.get(<span class="string">'优'</span>)  <span class="comment"># 大于70分</span></span><br><span class="line">dict2.get(<span class="string">'秀'</span>)  <span class="comment"># 没有反应，也没有报错</span></span><br><span class="line">dict2.get(<span class="string">'秀'</span>,<span class="string">'自定义错误提示'</span>)  <span class="comment"># 如果有“秀”对应的值，则输出对应的值；否则输出后面的提示信息</span></span><br><span class="line">dict2.get(<span class="string">'优'</span>, <span class="string">'自定义错误提示'</span>)  <span class="comment"># 大于70分</span></span><br><span class="line">dict2.items()  <span class="comment"># 获取所有的键值对</span></span><br><span class="line">dict2.keys()  <span class="comment"># 返回所有的键值</span></span><br><span class="line">dict2.values()  <span class="comment">#返回所有的值</span></span><br></pre></td></tr></table></figure><h5 id="添加键值对"><a href="#添加键值对" class="headerlink" title="添加键值对"></a>添加键值对</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict1[<span class="string">'c'</span>] = cat  <span class="comment"># &#123;'a':'apple', 'b':'banane', 'c':'cat'&#125; 没有则添加</span></span><br><span class="line">dict1[<span class="string">'a'</span>] = allen  <span class="comment"># &#123;'a':'allen', 'b':'banane'&#125; 有则修改</span></span><br></pre></td></tr></table></figure><h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dict6 = &#123;<span class="string">'No1'</span>:<span class="string">'java'</span>,<span class="string">'No2'</span>:<span class="string">'python'</span>&#125;</span><br><span class="line">dict7 = &#123;<span class="string">'No3'</span>:<span class="string">'C++'</span>&#125;</span><br><span class="line">dict8 = &#123;<span class="string">'No2'</span>,<span class="string">'C'</span>&#125;</span><br><span class="line">dict6.update(dict7)  <span class="comment"># dict6为&#123;'No1': 'java', 'No2': 'python', 'No3': 'C++'&#125;</span></span><br><span class="line">dict6.update(dict8)  <span class="comment"># dict6为&#123;'No1':'java','No2':'C'， 'No3': 'C++'&#125;</span></span><br></pre></td></tr></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span>(dict6[<span class="string">'No2'</span>])</span><br><span class="line">print(dict6)  <span class="comment"># &#123;'No1': 'java'， 'No3': 'C++'&#125;</span></span><br><span class="line"><span class="keyword">del</span> dict6</span><br><span class="line">print(dict6)  <span class="comment"># 报错，未定义dict1</span></span><br><span class="line"></span><br><span class="line">dict6.pop(<span class="string">'No2'</span>,<span class="string">'自定义错误提示'</span>)  <span class="comment"># 存在则删除；不存在输出自定义错误提示，即参数二</span></span><br><span class="line">dict9 = &#123;<span class="string">'No1'</span>:<span class="string">'java'</span>,<span class="string">'No2'</span>:<span class="string">'python'</span>,<span class="string">'No3'</span>:<span class="string">'C++'</span>&#125;</span><br><span class="line">dict9.popitem()  <span class="comment"># 从后往前删除，每次删除一个。先删除No3,再删除No2...</span></span><br><span class="line">dict9.clear()  <span class="comment"># dict9为 &#123;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>可变集合(set) 不可变集合(frozenset)<br>没有顺序，没有重复元素</p><h5 id="字面量-2"><a href="#字面量-2" class="headerlink" title="字面量"></a>字面量</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)  <span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">print(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>&#125;)  <span class="comment"># &#123;1, 2, 4&#125;</span></span><br><span class="line">print(&#123;<span class="number">1</span>,<span class="keyword">True</span>&#125;)   <span class="comment"># &#123;1&#125;</span></span><br><span class="line">print(&#123;<span class="number">1</span>,<span class="keyword">False</span>&#125;)  <span class="comment"># &#123;False, 1&#125;</span></span><br></pre></td></tr></table></figure><h5 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = set(<span class="string">'hello'</span>)    <span class="comment"># &#123;'h', 'e', 'l', 'o'&#125;</span></span><br><span class="line">set2 = set((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))  <span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">set3 = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])  <span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">set4 = set((<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))<span class="comment"># 错误</span></span><br></pre></td></tr></table></figure><h5 id="推导式-2"><a href="#推导式-2" class="headerlink" title="推导式"></a>推导式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>)&#125;  <span class="comment"># &#123;16, 1, 4, 9&#125;</span></span><br></pre></td></tr></table></figure><h5 id="交并差集"><a href="#交并差集" class="headerlink" title="交并差集"></a>交并差集</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set5 = set(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">set6 = set(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">set5 | set6  <span class="comment"># 并集 &#123;1, 2, 3, 4, 5, 6&#125; </span></span><br><span class="line">set5 &amp; set6  <span class="comment"># 交集 &#123;3, 4&#125; </span></span><br><span class="line">set5 - set6  <span class="comment"># 差集 &#123;1, 2&#125; </span></span><br><span class="line">set5 ^ set6  <span class="comment"># 对称差集 &#123;1, 2, 5, 6&#125;</span></span><br></pre></td></tr></table></figure><h5 id="合并-1"><a href="#合并-1" class="headerlink" title="合并"></a>合并</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set5.update(set6)  <span class="comment"># &#123;1,2,3,4,5,6&#125;</span></span><br></pre></td></tr></table></figure><h5 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set7 = set6.copy()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      这是python学习的课上笔记第一篇，主要内容有数据结构
    
    </summary>
    
    
      <category term="python" scheme="http://liyzy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>利用ZXing工具生成二维码以及解析二维码</title>
    <link href="http://liyzy.github.io/2018/09/06/%E5%88%A9%E7%94%A8ZXing%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%BB%A5%E5%8F%8A%E8%A7%A3%E6%9E%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://liyzy.github.io/2018/09/06/利用ZXing工具生成二维码以及解析二维码/</id>
    <published>2018-09-06T10:40:52.971Z</published>
    <updated>2018-10-06T09:27:12.460Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p></p><br><a id="more"></a><p></p><h3 id="一、-二维码生成原理（即工作原理）"><a href="#一、-二维码生成原理（即工作原理）" class="headerlink" title="一、 二维码生成原理（即工作原理）"></a>一、 二维码生成原理（即工作原理）</h3><p>二维码官方叫版本Version。Version 1是21 x 21的矩阵，Version 2是 25 x 25的矩阵，Version 3是29的尺寸，每增加一个version，就会增加4的尺寸，公式是：(V-1)<em>4 + 21（V是版本号） 最高Version 40，(40-1)</em>4+21 = 177，所以最高是177 x 177 的正方形。</p><p>下面是一个二维码的样例：<br><img src="https://gss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=caf539606b224f4a57cc7b1539c7bc6a/024f78f0f736afc3013f7023b519ebc4b7451240.jpg" alt=""></p><p>1、定位图案</p><p>Position Detection Pattern是定位图案，用于标记二维码的矩形大小。这三个定位图案有白边叫Separators for Postion Detection Patterns。之所以三个而不是四个意思就是三个就可以标识一个矩形了。</p><p>Timing Patterns也是用于定位的。原因是二维码有40种尺寸，尺寸过大了后需要有根标准线，不然扫描的时候可能会扫歪了。</p><p>Alignment Patterns 只有Version 2以上（包括Version2）的二维码需要这个东东，同样是为了定位用的。</p><p>2、功能性数据</p><p>Format Information 存在于所有的尺寸中，用于存放一些格式化数据的。</p><p>Version Information 在 &gt;= Version 7以上，需要预留两块3 x 6的区域存放一些版本信息。</p><p>数据码和纠错码</p><p>除了上述的那些地方，剩下的地方存放 Data Code 数据码 和 Error Correction Code 纠错码。</p><p>3、数据编码</p><p>QR码支持如下的编码：</p><p>Numeric mode 数字编码，从0到9。如果需要编码的数字的个数不是3的倍数，那么，最后剩下的1或2位数会被转成4或7bits，则其它的每3位数字会被编成 10，12，14bits，编成多长还要看二维码的尺寸（下面有一个表Table 3说明了这点）</p><p>Alphanumeric mode 字符编码。包括 0-9，大写的A到Z（没有小写），以及符号$ % * + – . / : 包括空格。这些字符会映射成一个字符索引表。如下所示：（其中的SP是空格，Char是字符，Value是其索引值） 编码的过程是把字符两两分组，然后转成下表的45进制，然后转成11bits的二进制，如果最后有一个落单的，那就转成6bits的二进制。而编码模式和 字符的个数需要根据不同的Version尺寸编成9, 11或13个二进制（如下表中Table 3）<br><img src="https://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=d8c7c96a8101a18bf0be1a49ae1f2b30/8694a4c27d1ed21b5de761a3ab6eddc451da3f4d.jpg" alt=""></p><p>Byte mode, 字节编码，可以是0-255的ISO-8859-1字符。有些二维码的扫描器可以自动检测是否是UTF-8的编码。</p><p>Kanji mode 这是日文编码，也是双字节编码。同样，也可以用于中文编码。日文和汉字的编码会减去一个 值。如：在0X8140 to 0X9FFC中的字符会减去8140，在0XE040到0XEBBF中的字符要减去0XC140，然后把前两位拿出来乘以0XC0，然后再加上后两位，最 后转成13bit的编码。如下图示例：<br><img src="https://gss0.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=e06f4364b51bb0518f71bb2e064af68c/738b4710b912c8fc8ad6b98bfa039245d688214a.jpg" alt=""></p><p>Extended Channel Interpretation (ECI) mode 主要用于特殊的字符集。并不是所有的扫描器都支持这种编码。</p><p>Structured Append mode 用于混合编码，也就是说，这个二维码中包含了多种编码格式。</p><p>FNC1 mode 这种编码方式主要是给一些特殊的工业或行业用的。比如GS1条形码之类的。</p><p>简单起见，后面三种不会在本文 中讨论。</p><p>下面两张表中，</p><p>Table 2 是各个编码格式的“编号”，这个东西要写在Format Information中。注：中文是1101</p><p>Table 3 表示了，不同版本（尺寸）的二维码，对于，数字，字符，字节和Kanji模式下，对于单个编码的2进制的位数。（在二维码的规格说明书中，有各种各样的编码规范表，后面还会提到）</p><p><img src="https://gss0.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=8ab6ed5dd20735fa91a546bfae61238b/8cb1cb1349540923fcfa2c389458d109b2de49e0.jpg" alt=""></p><p>示例一：数字编码</p><p>在Version 1的尺寸下，纠错级别为H的情况下，编码： 01234567</p><p> 把上述数字分成三组: 012 345 67</p><p> 把他们转成二进制:  012 转成 0000001100；  345 转成 0101011001；  67 转成 1000011。</p><p> 把这三个二进制串起来: 0000001100 0101011001 1000011</p><p> 把数字的个数转成二进制 (version 1-H是10 bits ): 8个数字的二进制是 0000001000</p><p> 把数字编码的标志0001和第4步的编码加到前面:  0001 0000001000 0000001100 0101011001 1000011</p><p>示例二：字符编码</p><p>在Version 1的尺寸下，纠错级别为H的情况下，编码: AC-42</p><ol><li><p>从字符索引表中找到 AC-42 这五个字条的索引 (10,12,41,4,2)</p></li><li><p>两两分组: (10,12) (41,4) (2)</p></li></ol><p>3.把每一组转成11bits的二进制:</p><p>(10,12) 10*45+12 等于 462 转成 00111001110</p><p>(41,4) 41*45+4 等于 1849 转成 11100111001</p><p>(2) 等于 2 转成 000010</p><ol start="4"><li><p>把这些二进制连接起来：00111001110 11100111001 000010</p></li><li><p>把字符的个数转成二进制 (Version 1-H为9 bits ): 5个字符，5转成 000000101</p></li><li><p>在头上加上编码标识 0010 和第5步的个数编码:  0010 000000101 00111001110 11100111001 000010</p></li></ol><p>结束符和补齐符</p><p>假如我们有个HELLO WORLD的字符串要编码，根据上面的示例二，我们可以得到下面的编码，</p><p>编码</p><p>字符数</p><p>HELLO WORLD的编码</p><p>0010    000001011    01100001011 01111000110 10001011100 10110111000 10011010100 001101    </p><p>我们还要加上结束符：</p><p>编码</p><p>字符数</p><p>HELLO WORLD的编码</p><p>结束</p><p>0010    000001011    01100001011 01111000110 10001011100 10110111000 10011010100 001101    0000    </p><p>按8bits重排</p><p>如果所有的编码加起来不是8个倍数我们还要在后面加上足够的0，比如上面一共有78个bits，所以，我们还要加上2个0，然后按8个bits分好组：</p><p>00100000   01011011   00001011   01111000   11010001   01110010   11011100   01001101   01000011   01000000</p><p>补齐码（Padding Bytes）</p><p>最后，如果如果还没有达到我们最大的bits数的限制，我们还要加一些补齐码（Padding Bytes），Padding Bytes就是重复下面的两个bytes：11101100 00010001 （这两个二进制转成十进制是236和17，我也不知道为什么，只知道Spec上是这么写的）关于每一个Version的每一种纠错级别的最大Bits限 制，可以参看QR Code Spec的第28页到32页的Table-7一表。</p><p>假设我们需要编码的是Version 1的Q纠错级，那么，其最大需要104个bits，而我们上面只有80个bits，所以，还需要24个bits，也就是需要3个Padding Bytes，我们就添加三个，于是得到下面的编码：</p><p>00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 11101100 00010001 11101100</p><p>纠错码</p><p>上面我们说到了一些纠错级别，Error Correction Code Level，二维码中有四种级别的纠错，这就是为什么二维码有残缺还能扫出来，也就是为什么有人在二维码的中心位置加入图标。</p><p>错误修正容量</p><p>L水平    7%的字码可被修正    </p><p>M水平    15%的字码可被修正    </p><p>Q水平    25%的字码可被修正    </p><p>H水平    30%的字码可被修正    </p><p>那么，QR是怎么对数据码加上纠错码的？首先，我们需要对数据码进行分组，也就是分成不同的Block，然后对各个Block进行纠错编码，对于如何分组，我们可以查看QR Code Spec的第33页到44页的Table-13到Table-22的定义表。注意最后两列：</p><p>Number of Error Code Correction Blocks ：需要分多少个块。</p><p>Error Correction Code Per Blocks：每一个块中的code个数，所谓的code的个数，也就是有多少个8bits的字节。</p><p><img src="https://gss0.baidu.com/-vo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=3ba9738196529822056631c5e7fa57f3/0b55b319ebc4b7453e23f850c9fc1e178b8215c4.jpg" alt=""></p><p>举个例子：上述的Version 5 + Q纠错级：需要4个Blocks（2个Blocks为一组，共两组），头一组的两个Blocks中各15个bits数据 + 各 9个bits的纠错码（注：表中的codewords就是一个8bits的byte）（再注：最后一例中的（c, k, r ）的公式为：c = k + 2 * r，因为后脚注解释了：纠错码的容量小于纠错码的一半）</p><p>对每个块的纠错码</p><p>1    1    67 85 70 134 87 38 85 194 119 50 6 18 6 103 38    213 199 11 45 115 247 241 223 229 248 154 117 154 111 86 161 111 39    </p><p>2    246 246 66 7 118 134 242 7 38 86 22 198 199 146 6    87 204 96 60 202 182 124 157 200 134 27 129 209 17 163 163 120 133    </p><p>2    1    182 230 247 119 50 7 118 134 87 38 82 6 134 151 50 7    148 116 177 212 76 133 75 242 238 76 195 230 189 10 108 240 192 141    </p><p>2    70 247 118 86 194 6 151 50 16 236 17 236 17 236 17 236    235 159 5 173 24 147 59 33 106 40 255 172 82 2 131 32 178 236    </p><p>注：二维码的纠错码主要是通过Reed-Solomon error correction（里 德-所罗门纠错算法）来实现的。对于这个算法，对于我来说是相当的复杂，里面有很多的数学计算，最终编码。</p><p>穿插放置</p><p>二维码的混乱技术还没有玩完，它还要把数据码和纠错码的各个codewords交替放在一起。如何交替呢，规则如下：</p><p>对于数据码：把每个块的第一个codewords先拿出来按顺度排列好，然后再取第一块的第二个，如此类推。如：上述示例中的Data Codewords如下：</p><p>块 1    67    85    70    134    87    38    85    194    119    50    6    18    6    103    38         </p><p>块 2    246    246    66    7    118    134    242    7    38    86    22    198    199    146    6         </p><p>块 3    182    230    247    119    50    7    118    134    87    38    82    6    134    151    50    7    </p><p>块 4    70    247    118    86    194    6    151    50    16    236    17    236    17    236    17    236    </p><p>我们先取第一列的：67， 246， 182， 70</p><p>然后再取第二列的：67， 246， 182， 70， 85，246，230 ，247</p><p>如此类推：67， 246， 182， 70， 85，246，230 ，247 ………  ……… ，38，6，50，17，7，236</p><p>对于纠错码，也是一样：</p><p>块 1    213    199    11    45    115    247    241    223    229    248    154    117    154    111    86    161    111    39    </p><p>块 2    87    204    96    60    202    182    124    157    200    134    27    129    209    17    163    163    120    133    </p><p>块 3    148    116    177    212    76    133    75    242    238    76    195    230    189    10    108    240    192    141    </p><p>块 4    235    159    5    173    24    147    59    33    106    40    255    172    82    2    131    32    178    236    </p><p>和数据码取的一样，得到：213，87，148，235，199，204，116，159，…… …… 39，133，141，236</p><p>然后，再把这两组放在一起（纠错码放在数据码之后）得到：</p><p>67, 246, 182, 70, 85, 246, 230, 247, 70, 66, 247, 118, 134, 7, 119, 86, 87, 118, 50, 194, 38, 134, 7, 6, 85, 242, 118, 151, 194, 7, 134, 50, 119, 38, 87, 16, 50, 86, 38, 236, 6, 22, 82, 17, 18, 198, 6, 236, 6, 199, 134, 17, 103, 146, 151, 236, 38, 6, 50, 17, 7, 236, 213, 87, 148, 235, 199, 204, 116, 159, 11, 96, 177, 5, 45, 60, 212, 173, 115, 202, 76, 24, 247, 182, 133, 147, 241, 124, 75, 59, 223, 157, 242, 33, 229, 200, 238, 106, 248, 134, 76, 40, 154, 27, 195, 255, 117, 129, 230, 172, 154, 209, 189, 82, 111, 17, 10, 2, 86, 163, 108, 131, 161, 163, 240, 32, 111, 120, 192, 178, 39, 133, 141, 236</p><p>Remainder Bits</p><p>最后再加上Reminder Bits，对于某些Version的QR，上面的还不够长度，还要加上Remainder Bits，比如：上述的5Q版的二维码，还要加上7个bits，Remainder Bits加零就好了。关于哪些Version需要多少个Remainder bit，可以参看QR Code Spec的第15页的Table-1的定义表。</p><p>4、画二维码图</p><p>Position Detection Pattern</p><p>首先，先把Position Detection图案画在三个角上。<br><img src="https://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=02a423f4b4b7d0a27b9c0c9bfbdf5a31/63d0f703918fa0eca76a2b4b209759ee3c6ddbc3.jpg" alt=""></p><p>Alignment Pattern</p><p>然后，再把Alignment图案画上<br><img src="https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=fc08826f8018367aaddc77db1e43a7ec/c9fcc3cec3fdfc03de1cacfed23f8794a4c2260b.jpg" alt=""></p><p>关于Alignment的位置，可以查看QR Code Spec的第81页的Table-E.1的定义表（下表是不完全表格）<br><img src="https://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=c27ff065652762d0806bacb990dc24c2/43a7d933c895d143c6d8ab6575f082025baf07cd.jpg" alt=""></p><p>下图是根据上述表格中的Version8的一个例子（6，24，42）<br><img src="https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=a44d40f1ef50352ab1342d0e6373d7ca/e824b899a9014c08f0b867e30c7b02087af4f4f1.jpg" alt=""></p><p>Timing Pattern</p><p>接下来是Timing Pattern的线（这个不用多说了）</p><p><img src="https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=a2c4794d5db5c9ea62a60be5e5099a38/8601a18b87d6277f08707d7e2e381f30e924fc12.jpg" alt=""></p><p>Format Information</p><p>再接下来是Formation Information，下图中的蓝色部分。</p><p><img src="https://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=55f2d2a5fb1f4134e0620d78152fb9f2/d1a20cf431adcbef85e53140aaaf2edda2cc9fa7.jpg" alt=""></p><p>Format Information是一个15个bits的信息，每一个bit的位置如下图所示：（注意图中的Dark Module，那是永远出现的）</p><p><img src="https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=94882b79dff9d72a1731181be41a040c/f9198618367adab4c42954058dd4b31c8601e4ff.jpg" alt=""></p><p>这15个bits中包括：</p><p>5个数据bits：其中，2个bits用于表示使用什么样的Error Correction Level， 3个bits表示使用什么样的Mask</p><p>10个纠错bits。主要通过BCH Code来计算</p><p>然后15个bits还要与101010000010010做XOR操作。这样就保证不会因为我们选用了00的纠错级别，以及000的Mask，从重造成全部为白色，这会增加我们的扫描器的图像识别的困难。</p><p>下面是一个示例：</p><p>关于Error Correction Level如下表所示：</p><p>关于Mask图案如后面的Table 23所示。</p><p>Version Information</p><p>再接下来是Version Information（版本7以后需要这个编码），下图中的蓝色部分。</p><p>Version Information一共是18个bits，其中包括6个bits的版本号以及12个bits的纠错码，下面是一个示例：</p><p>而其填充位置如下：</p><p>数据和数据纠错码</p><p>然后是填接我们的最终编码，最终编码的填充方式如下：从左下角开始沿着红线填我们的各个bits，1是黑色，0是白色。如果遇到了上面的非数据区，则绕开或跳过。</p><p>5、掩码图案</p><p>这样下来，图就填好了，但是，也许那些点并不均衡，所以还要做Masking操作QR的Spec中说了，QR有8个 Mask可以使用，如下所示：其中，各个mask的公式在各个图下面。所谓mask，说白了，就是和上面生成的图做XOR操作。Mask只会和数据区进 行XOR，不会影响功能区。</p><p>其Mask的标识码如下所示：（其中的i,j分别对应于上图的x,y）</p><p><img src="https://gss0.baidu.com/-vo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=7ccde12649c2d562f25dd8ebd721bcd7/7acb0a46f21fbe09ae968c526d600c338644ada8.jpg" alt=""></p><p>Mask过后的二维码就成最终的图了。</p><p>（以上内容来源于网络）</p><h3 id="二、-编码实现"><a href="#二、-编码实现" class="headerlink" title="二、 编码实现"></a>二、 编码实现</h3><p>首先，我们需要下载Google的ZXing库。<br>下载地址：<a href="https://github.com/zxing/zxing" target="_blank" rel="noopener">https://github.com/zxing/zxing</a></p><p>根据内容创建二维码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * TODO 根据给定的内容生成二维码</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> content        二维码内容</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> logoImagePath  logo图标的路径</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> needCompressed 是否需要压缩logo</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 生成的二维码</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> WriterException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BufferedImage <span class="title">createImage</span><span class="params">(String content, String logoImagePath, <span class="keyword">boolean</span> needCompressed)</span> </span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> IOException, WriterException </span>&#123;</span><br><span class="line">       HashMap hints = <span class="keyword">new</span> HashMap&lt;EncodeHintType, Object&gt;();</span><br><span class="line">       hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H);  <span class="comment">// 纠错等级</span></span><br><span class="line">       hints.put(EncodeHintType.CHARACTER_SET, CHARSET);</span><br><span class="line">       hints.put(EncodeHintType.MARGIN, <span class="number">1</span>);  <span class="comment">// 二维码两边空白区域大小</span></span><br><span class="line">       BitMatrix bitMatrix = <span class="keyword">new</span> MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, QRCODE_SIZE, QRCODE_SIZE, hints);</span><br><span class="line">       <span class="keyword">int</span> height = bitMatrix.getHeight();</span><br><span class="line">       <span class="keyword">int</span> width = bitMatrix.getWidth();</span><br><span class="line">       BufferedImage image = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x++)</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; height; y++)</span><br><span class="line">               image.setRGB(x, y, bitMatrix.get(x, y) ? <span class="number">0xFF000000</span> : <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (logoImagePath == <span class="keyword">null</span> || <span class="string">""</span>.equals(logoImagePath))</span><br><span class="line">           <span class="keyword">return</span> image;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果有logo，则插入logo图片</span></span><br><span class="line">       QRCode.InsertImage(image, logoImagePath, needCompressed);</span><br><span class="line">       <span class="keyword">return</span> image;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>如果有logo则将logo插入到二维码中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * TODO 插入logo图片</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> sourceImage 原图片</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> logoImagePath logo图片所在的路径</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> needCompressed 是否需要压缩</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertImage</span><span class="params">(BufferedImage sourceImage, String logoImagePath, <span class="keyword">boolean</span> needCompressed)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       File file = <span class="keyword">new</span> File(logoImagePath);</span><br><span class="line">       <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">           System.out.println(<span class="string">"logo文件不存在！\n"</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Image src = ImageIO.read(file);</span><br><span class="line">       <span class="keyword">int</span> width = src.getWidth(<span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">int</span> height = src.getHeight(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 压缩二维码图片</span></span><br><span class="line">       <span class="keyword">if</span> (needCompressed) &#123;</span><br><span class="line">           <span class="keyword">if</span> (width &gt; LOGO_WIDTH)</span><br><span class="line">               width = LOGO_WIDTH;</span><br><span class="line">           <span class="keyword">if</span> (height &gt; LOGO_HEIGHT)</span><br><span class="line">               height = LOGO_HEIGHT;</span><br><span class="line"></span><br><span class="line">           Image image = src.getScaledInstance(width, height, Image.SCALE_SMOOTH);</span><br><span class="line">           BufferedImage tag = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">           Graphics g = tag.getGraphics();</span><br><span class="line">           g.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">           g.dispose();  <span class="comment">// 释放占有的资源</span></span><br><span class="line">           src = image;</span><br><span class="line">           <span class="comment">// 直观的理解：Graphics2D 就相当于画笔，而BufferedImage 就是画笔绘制的结果。</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 插入logo</span></span><br><span class="line">       Graphics2D graph = sourceImage.createGraphics();</span><br><span class="line">       <span class="keyword">int</span> x = (QRCODE_SIZE - width) / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span> y = (QRCODE_SIZE - height) / <span class="number">2</span>;</span><br><span class="line">       graph.drawImage(src, x, y, width, height, <span class="keyword">null</span>);</span><br><span class="line">       Shape shape = <span class="keyword">new</span> RoundRectangle2D.Float(x, y, width, width, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">       graph.setStroke(<span class="keyword">new</span> BasicStroke(<span class="number">3f</span>));</span><br><span class="line">       graph.draw(shape);</span><br><span class="line">       graph.dispose();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>解码过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * TODO 解析二维码内容</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> file 二维码</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 二维码包含的信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decode</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       BufferedImage image;</span><br><span class="line">       image = ImageIO.read(file);</span><br><span class="line">       <span class="keyword">if</span> (image == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       BufferedImageLuminanceSource source = <span class="keyword">new</span> BufferedImageLuminanceSource(image);</span><br><span class="line">       BinaryBitmap bitmap = <span class="keyword">new</span> BinaryBitmap(<span class="keyword">new</span> HybridBinarizer(source));</span><br><span class="line">       HashMap hints = <span class="keyword">new</span> HashMap&lt;DecodeHintType, Object&gt;();</span><br><span class="line">       hints.put(DecodeHintType.CHARACTER_SET, CHARSET);</span><br><span class="line">       Result result = <span class="keyword">new</span> MultiFormatReader().decode(bitmap, hints);</span><br><span class="line">       String resultStr = result.getText();</span><br><span class="line">       <span class="keyword">return</span> resultStr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>测试结果<br><img src="https://upload-images.jianshu.io/upload_images/12649311-374caaf35a8835dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""><br>源码下载地址：<a href="https://github.com/Liyzy/ZXing-QRCode" target="_blank" rel="noopener">https://github.com/Liyzy/ZXing-QRCode</a><br>开发环境：idea 2018.2</p>]]></content>
    
    <summary type="html">
    
      今天突然想到二维码是如何存储信息的，手画二维码是否可行呢。于是就开始各种搜索，最终自己也利用Google的ZXing工具完成了一个生成二维码和解析二维码的简单程序。
    
    </summary>
    
    
      <category term="JAVA" scheme="http://liyzy.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>【java学习笔记3】继承&amp;多态篇</title>
    <link href="http://liyzy.github.io/2018/08/06/%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%91/"/>
    <id>http://liyzy.github.io/2018/08/06/【java学习笔记3】/</id>
    <published>2018-08-06T05:36:10.024Z</published>
    <updated>2018-10-06T11:54:35.955Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p></p><br><a id="more"></a><p></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol><li>关键字<code>extends</code>表示继承，继承是一个<code>is-a</code>关系，java中只有公有继承</li><li><p>覆盖方法（override）<br>将父类中的方法在子类中重新定义，以Employee类和Manager类为例，Manager继承Employee类，Employee有方法getSalary(); Manager类需要重写这个方法，加上经理所特有的奖金。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> salary;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> bonus;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//return salary + bonus;  // 错误，不能访问超类的私有域</span></span><br><span class="line"><span class="comment">//return getSalary() + bonus;  // 错误，调用自身直至崩溃</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getSalary() + bonus;  <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//super关键字表示调用父类的方法</span></span><br></pre></td></tr></table></figure></li><li><p>子类构造器<br>必须调用父类的构造器，并且应将这一过程放在程序的第一句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, String id, <span class="keyword">double</span> salary)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name, id, salary);  <span class="comment">// 置于第一句，如果没有这句，系统自动调用父类的默认构造函数；如果没有默认构造函数有没有显式调用其他构造器就会产生错误</span></span><br><span class="line">bonus = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>java不支持多继承，即每一个类都只能继承最多一个类。但每一个类可以实现多个接口，这也是引入接口的一个考虑。</p></li><li>多态<br>java实现多态的两种方式：重载(overloading)和覆盖(override)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* override */</span></span><br><span class="line">Manager boss = <span class="keyword">new</span> Manager(<span class="string">"lihui"</span>, <span class="number">201822</span>, <span class="number">50000</span>);</span><br><span class="line">boss.setBonus(<span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">Empolyee[] staff = <span class="keyword">new</span> Empolyee[<span class="number">2</span>];</span><br><span class="line">staff[<span class="number">0</span>] = boss;</span><br><span class="line">staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee(<span class="string">"chengle"</span>, <span class="number">201833</span>, <span class="number">60000</span>);</span><br><span class="line"></span><br><span class="line">staff[<span class="number">0</span>].setBonus(<span class="number">20000</span>);  <span class="comment">// 错误，staff声明为Employee类型，Employee没有setBonus方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(staff[<span class="number">0</span>] <span class="keyword">instanceof</span> Manager)</span><br><span class="line">((Manager)staff[<span class="number">0</span>]).setBonus(<span class="number">20000</span>);  <span class="comment">// 正确，将staff[0]强制转换为Manager类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Employee aEmpolyee: staff)</span><br><span class="line">System.out.println(aEmpolyee.getName() + <span class="string">" "</span> + aEmpolyee.getSalary());</span><br><span class="line"><span class="comment">// aEmpolyee定义为Empolyee类型，但在执行的时候，aEmpolyee引用的Empolyee和Manager调用不同的getSalary函数</span></span><br><span class="line"><span class="comment">// 一个对象变量可以指示多种实际类型的现象称为多态。</span></span><br><span class="line"><span class="comment">// 在运行的时候自动选择调用哪个方法称为动态绑定。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* overloading */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">(String name)</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getSalary</span><span class="params">(String name)</span></span>&#123;...&#125;  <span class="comment">//错误，已经存在getSalary(String name)方法,即签名相同，说明重载与返回值无关</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">(String name, String id)</span></span>&#123;...&#125;  <span class="comment">//正确的重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>方法的签名：方法的名字和参数列表称为方法的签名，返回类型不是签名的一部分。</p></blockquote><p>override的规则：</p><ul><li>子类覆盖父类中具有相同签名的方法。</li><li>返回类型是被重写方法的返回类型的子类型。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为final的方法不能被重写。</li><li>声明为static、private、final的方法不能被重写。(private的方法本身就被定义成了final的)</li><li>构造器不能被重写。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li></ul><p>overloading的规则：<br>方法名相同，参数列表必须不同，返回值可同可不同，修饰符可同可不同。</p><ol start="6"><li>方法调用的过程<br>1）假设调用x.f(param), 编译器一一列举x所属类中的名为f的方法以及其父类中访问属性为public的名为f的方法（超类的私有方法不可访问）。<br>2）查看调用方法提供的参数类型。如果第一步中列举出的方法中有一个方法的参数列表与提供的参数类型完全匹配，就选择这个方法。如果没有找到与参数类型匹配的方法或者经过类型转换后有多个方法与之匹配，就会产生错误。<br>3）如果是static、private、final方法或者构造器，编译器可以准确的知道应该调用哪个方法，静态绑定。<br>4）动态绑定时，先查看子类中是否定义了这个方法，是则调用，否则调用父类的这个方法。</li><li>final修饰符<br>定义类的时候加上final修饰符表示类不允许被继承，其中的方法自动的成为final，但是域不会变成final。一个方法或者一个域也可以加上final表示不可被覆盖或者不可改变域的值。</li><li>抽象类<br>关键字<code>abstract</code>表示抽象类，包含有一个或多个抽象函数的类需要声明为抽象类（为了代码清晰），抽象类里的抽象方法不需要实现，在子类中对其进行实现。</li></ol>]]></content>
    
    <summary type="html">
    
      java学习笔记的第三篇，内容主要有继承和多态
    
    </summary>
    
    
      <category term="JAVA" scheme="http://liyzy.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>【java学习笔记2】数组&amp;运算符&amp;权限篇</title>
    <link href="http://liyzy.github.io/2018/07/08/%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E3%80%91/"/>
    <id>http://liyzy.github.io/2018/07/08/【java学习笔记2】/</id>
    <published>2018-07-08T09:53:51.036Z</published>
    <updated>2018-10-06T11:54:14.975Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p></p><br><a id="more"></a><p></p><ol><li>数组</li><li>运算符</li><li>包</li><li>访问权限</li><li>修饰符</li></ol><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="1-数组的声明："><a href="#1-数组的声明：" class="headerlink" title="1. 数组的声明："></a>1. 数组的声明：</h4><p><code>int[] a;</code></p><h4 id="2-数组的创建"><a href="#2-数组的创建" class="headerlink" title="2. 数组的创建"></a>2. 数组的创建</h4><p>使用new运算符数组的创建<code>int[] a = new int[100]</code> 数组的长度不要求是常量：<code>new int[n]</code>会创建一个长度为n的数组</p><h4 id="3-数组的初始化"><a href="#3-数组的初始化" class="headerlink" title="3. 数组的初始化"></a>3. 数组的初始化</h4><p>可以使用for循环进行赋值，或者直接<code>int[] a = {1, 2, 3}</code>进行赋值；数组创建时，数字数组所有元素初始化为0，Boolean数组所有元素初始化为false，对象数组则初始化为null值。</p><h4 id="4-数组长度"><a href="#4-数组长度" class="headerlink" title="4. 数组长度"></a>4. 数组长度</h4><p>每一个数组都有成员属性length，使用<code>a.length</code>获得数组a的长度</p><h4 id="5-数组的遍历输出"><a href="#5-数组的遍历输出" class="headerlink" title="5. 数组的遍历输出"></a>5. 数组的遍历输出</h4><p> a. 传统for循环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">    System.out.print(a[i] + <span class="string">" "</span>);</span><br></pre></td></tr></table></figure></p><p>b. for each循环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> element : a)</span><br><span class="line">    System.out.print(element + <span class="string">" "</span>);</span><br><span class="line"><span class="comment">//对于在for循环语句中需要使用元素下标的程序来说不合适</span></span><br></pre></td></tr></table></figure></p><p>c. 利用Arrays类的toString方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line"><span class="comment">//a为数值型的数组或Boolean数组</span></span><br></pre></td></tr></table></figure></p><h4 id="6-数组拷贝"><a href="#6-数组拷贝" class="headerlink" title="6. 数组拷贝"></a>6. 数组拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] b = a;  <span class="comment">//b和a引用同一个数组</span></span><br><span class="line">b[<span class="number">1</span>] = <span class="number">7</span>;  <span class="comment">//此时访问a[1]也是7</span></span><br></pre></td></tr></table></figure><p>如果希望把一个数组的所有值拷贝到一个新的数组,使用Arrays类的copyOf方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] b = Arrays.copyOf(a, a.length);</span><br></pre></td></tr></table></figure></p><p>第二个参数表示新数组的长度，比原数组长，则多余的元素被赋值为0或者false或者null，比原数组短，则只复制前面的对应长度的元素。<br>方法<code>Arrays.copyOfRange(type[] a, int start, int end)</code><br>type为int, short, byte, long, double, float, Boolean 类型</p><h4 id="7-数组排序"><a href="#7-数组排序" class="headerlink" title="7. 数组排序"></a>7. 数组排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(a);  <span class="comment">//使用优化的快速排序</span></span><br></pre></td></tr></table></figure><h4 id="8-多维数组"><a href="#8-多维数组" class="headerlink" title="8. 多维数组"></a>8. 多维数组</h4><p>多维数组创建<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span>[][] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][]; <span class="comment">//正确, 第二维的长度可以动态申请，可以不同</span></span><br><span class="line"><span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[][<span class="number">3</span>]; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p><p>多维数组遍历<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">    b[i] = <span class="keyword">new</span> <span class="keyword">int</span>[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b[i].length; j++)</span><br><span class="line">    b[i][j] = i + j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length)</span><br><span class="line">System.out.print(a[i][j] + <span class="string">" "</span>);</span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : b)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : row)</span><br><span class="line">        System.out.print(value + <span class="string">" "</span>);</span><br><span class="line"><span class="comment">//第三种方式</span></span><br><span class="line">System.out.println(Arrays.deepToString(b));</span><br></pre></td></tr></table></figure></p><p>多维数组的每一行是可以通过引用进行交换的。</p><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">12.3f</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">a = a / <span class="number">0</span>;  <span class="comment">//得到Infinity或者NaN</span></span><br><span class="line">b = b / <span class="number">0</span>;  <span class="comment">//除零异常</span></span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure><h4 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b = -<span class="number">5</span>;</span><br><span class="line">a = a % <span class="number">3</span>;</span><br><span class="line">b = b % <span class="number">3</span>;</span><br><span class="line">System.out.println(a + <span class="string">","</span> + b);  <span class="comment">//2,-2</span></span><br><span class="line">a = a % -<span class="number">3</span>;</span><br><span class="line">b = b % -<span class="number">3</span>;</span><br><span class="line">System.out.print(a + <span class="string">","</span> + b);  <span class="comment">//2,-2</span></span><br><span class="line"><span class="comment">/*求模运算的结果与左操作数符号相同，与右操作数符号无关*/</span></span><br></pre></td></tr></table></figure><h4 id="算术运算的结果不低于int型"><a href="#算术运算的结果不低于int型" class="headerlink" title="算术运算的结果不低于int型"></a>算术运算的结果不低于int型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">2</span>;</span><br><span class="line">b = a + b;  <span class="comment">//错误，a+b返回int型，int不能赋值给byte</span></span><br><span class="line">b = (<span class="keyword">byte</span>)(a + b);  <span class="comment">//正确，强制转换</span></span><br><span class="line">b += a; <span class="comment">//正确，b += a等价于b = (byte)(b + a)</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">7</span>;</span><br><span class="line">c = c + <span class="number">5.2</span>; <span class="comment">//错误</span></span><br><span class="line">c += <span class="number">5.2</span>;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/12649311-cb0925715b3bdaae.jpg?imageMogr2/auto-orient/" alt=""><br>虚箭头表示可能有精度损失的转换，实箭头表示无信息丢失的转换。</p><p>基本数据类型的数组之间不能相互赋值，因为java中数组是类。</p><h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><p><strong>&lt;&lt;</strong>左移，低位补0，移位中可能会出现符号变换<br><strong>&gt;&gt;</strong>右移，高位补符号位<br><strong>&gt;&gt;&gt;</strong>无符号右移，高位补0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// a &gt;&gt; 33等价于a &gt;&gt; 1，移的位数和数值类型的位数取模</span></span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// b &gt;&gt; 33等价于b &gt;&gt; 1,在b &gt;&gt; 33操作中，b自动提升为int型</span></span><br></pre></td></tr></table></figure></p><p><strong>~</strong>位反运算，每一位取反</p><h4 id="位逻辑运算"><a href="#位逻辑运算" class="headerlink" title="位逻辑运算"></a>位逻辑运算</h4><p>位逻辑运算优先级  <strong>&amp; ^  |</strong></p><h4 id="三目运算符？：的第二第三操作数必须是可以赋值的"><a href="#三目运算符？：的第二第三操作数必须是可以赋值的" class="headerlink" title="三目运算符？：的第二第三操作数必须是可以赋值的"></a>三目运算符？：的第二第三操作数必须是可以赋值的</h4><hr><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>一个类可以使用所属包中所有的类，以及其他包中的公有类。<br>访问其他包中公有类的两种方式：在每个类前添加完整的包名；使用import语句(放在源文件的顶部，package语句的后面)。<br>package语句对整个源文件有效，即同一个源文件里的所有类都属于这个包。</p><hr><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//public</span><br><span class="line">//private</span><br><span class="line">//protected</span><br><span class="line">//没有指定则为同包可访问</span><br></pre></td></tr></table></figure><hr><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>static 静态修饰符<br>final 常量修饰符，也可以表示一个类不允许继承<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">i = <span class="number">3</span>; <span class="comment">//错误，i只有在new了一个对象后才会存在</span></span><br><span class="line">j = <span class="number">7</span>; <span class="comment">//正确，j是静态的，不需要创建对象就存在</span></span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">a.i = <span class="number">3</span>; <span class="comment">//正确</span></span><br><span class="line">A.i = <span class="number">3</span>; <span class="comment">//错误</span></span><br><span class="line">A.j = <span class="number">4</span>; <span class="comment">//正确，j是所有的A类对象所共有的，所以可以通过类名来访问</span></span><br><span class="line">a.j = <span class="number">4</span>; <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      java学习笔记的第二篇，内容主要有数组、运算符、权限、修饰符等
    
    </summary>
    
    
      <category term="JAVA" scheme="http://liyzy.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Gitee(码云)、Github同时配置ssh key</title>
    <link href="http://liyzy.github.io/2018/07/06/Gitee(%E7%A0%81%E4%BA%91)%E3%80%81Github%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEssh%20key/"/>
    <id>http://liyzy.github.io/2018/07/06/Gitee(码云)、Github同时配置ssh key/</id>
    <published>2018-07-06T13:25:17.666Z</published>
    <updated>2018-10-06T07:15:04.641Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p></p><br><a id="more"></a><p></p><h4 id="一、到-ssh文件夹下"><a href="#一、到-ssh文件夹下" class="headerlink" title="一、到.ssh文件夹下"></a>一、到.ssh文件夹下</h4><p><code>cd ~/.ssh</code></p><h4 id="二、通过下面的命令，依次生成两个平台的key"><a href="#二、通过下面的命令，依次生成两个平台的key" class="headerlink" title="二、通过下面的命令，依次生成两个平台的key"></a>二、通过下面的命令，依次生成两个平台的key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;github_id_rsa&quot;</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;gitee_id_rsa&quot;</span><br></pre></td></tr></table></figure><p>完成后，.ssh文件夹生成以下文件<br><img src="https://upload-images.jianshu.io/upload_images/12649311-e0698269f6eab7ef.png?imageMogr2/auto-orient/" alt=""></p><h4 id="三、把public-key复制到gitee和github"><a href="#三、把public-key复制到gitee和github" class="headerlink" title="三、把public key复制到gitee和github"></a>三、把public key复制到gitee和github</h4><p>执行命令<code>cat github_id_rsa.pub</code>把第二行到结尾的内容复制到github的ssh中保存<br><img src="https://upload-images.jianshu.io/upload_images/12649311-c8d3e0656f6d1a5d.png?imageMogr2/auto-orient/" alt=""></p><p>同样的操作，添加gitee的ssh</p><h4 id="四、创建config文件解决ssh冲突"><a href="#四、创建config文件解决ssh冲突" class="headerlink" title="四、创建config文件解决ssh冲突"></a>四、创建config文件解决ssh冲突</h4><p>在.ssh文件夹下执行命令<code>vi config</code><br>文件中添加以下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># gitee</span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/gitee_id_rsa</span><br><span class="line"></span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/github_id_rsa</span><br></pre></td></tr></table></figure></p><h4 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h4><p>执行<br><code>ssh -T git@github.com</code><br>成功则返回<br><code>Welcome to Gitee.com ,yourname!</code><br>执行<br><code>ssh -T git@gitee.com</code><br>成功则返回<br><code>Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p>]]></content>
    
    <summary type="html">
    
      最先接触的是GitHub，后来接触了中文的Gitee(码云)。那么怎么在同一个电脑上同时配置ssh key，将项目同时上传到两个平台上呢？
    
    </summary>
    
    
      <category term="SSH" scheme="http://liyzy.github.io/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>【java学习笔记1】数据类型&amp;函数篇</title>
    <link href="http://liyzy.github.io/2018/07/03/%E3%80%90java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%91/"/>
    <id>http://liyzy.github.io/2018/07/03/【java学习笔记1】/</id>
    <published>2018-07-03T11:30:01.284Z</published>
    <updated>2018-10-06T11:54:26.989Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p></p><br><a id="more"></a><p></p><ol><li>Java简单介绍</li><li>第一个程序Hello World</li><li>基本数据类型</li><li>对象和类</li><li>数据声明</li><li>函数声明</li><li>参数传递</li></ol><hr><h3 id="Java简单介绍"><a href="#Java简单介绍" class="headerlink" title="Java简单介绍"></a>Java简单介绍</h3><ol><li>Java的优点：简单、可移植性</li><li>JDK (Java Development Kit)  Java开发工具包</li><li>JRE (Java Runtime Environment) Java运行环境<br> 只要具有JRE，就可以运行Java代码，而与操作系统的类别无关</li><li>安装完JDK后，在电脑“编辑系统环境变量”—“环境变量”选项下，系统变量新建 变量名 JAVA_HONE 变量值 D:\Program Files\java\jdk-10.0.1(这是我的JDK位置)      系统变量找到Path变量，编辑新建D:\Program Files\java\jdk-10.0.1\bin<br>之后在cmd 中测试命令 Java 和 Javac ，有东西输出之后就可以用Javac在cmd里编译Java程序了(生成.class文件)，用Java [option] [主类名]就可以运行程序了(java HelloWorld  而不是 java HelloWorld.class)。<h3 id="第一个程序-Hello-World"><a href="#第一个程序-Hello-World" class="headerlink" title="第一个程序 Hello World"></a>第一个程序 Hello World</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意Java区分大小写，参数中的String的S必须大写。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>char<br>boolean<br>byte, short, int, long, float, double</p><h4 id="char-字符型"><a href="#char-字符型" class="headerlink" title="char(字符型)"></a>char(字符型)</h4><blockquote><p>首先补充编码的知识<br><strong><em>ASCII码</em></strong>(美国信息交换标准代码，7-bits ASCII码) 七位码，共128个字符，它主要用于显示现代英语和其他西欧语言。<br><strong><em>GB2312</em></strong>，是中国国家标准的简体中文字符集，双字节字符集。<br><strong><em>GBK</em></strong>，GBK字符集主要扩展了繁体中文字的支持，双字节字符集。<br><strong><em>GB18030</em></strong>,GB 18030标准采用单字节、双字节和四字节三种方式对字符编码。<br>单字节部分使用0×00至0×7F码(对应于ASCII码的相应码)。<br>双字节部分，首字节码从0×81至0×FE，尾字节码位分别是0×40至0×7E和0×80至0×FE。<br>四字节部分采用GB/T 11383未采用的0×30到0×39作为对双字节编码扩充的后缀，这样扩充的四字节编码，其范围为0×81308130到0×FE39FE39。其中第一、三个字节编码码位均为0×81至0×FE，第二、四个字节编码码位均为0×30至0×39。<br>按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集(DBCS)。<br><strong><em>Unicode</em></strong>(万国码、统一码、单一码)，16位，也就是两个字节代表一个字符。<br><strong><em>UTF-8</em></strong>是一种8位的unicode字符集，编码长度是可变的，并且是ASCII字符集的严格超集，也就是说ASCII中每个字符的编码在UTF-8中是完全一样的。UTF-8字符集中，一个字符可能是1个字节，2个字节，3个字节或者4个字节长。一般来说，欧洲的字母字符长度为1到2个字节，而亚洲的大部分字符则是3个字节，附加字符为4个字节长。<br>更多关于编码参考文章<a href="http://blog.sina.com.cn/s/blog_4b4409c30100vw9t.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4b4409c30100vw9t.html</a></p></blockquote><p>在Java中采用Unicode编码，所以<br><code>char a = &#39;a&#39;;</code> 和 <code>char b = &#39;中&#39;</code>一样都占两个字节(区别于C和C++)<br><code>char c = &#39;\u21fa&#39;</code>表示转义字符，格式为\u加上4位16进制数</p><h4 id="boolean-布尔型"><a href="#boolean-布尔型" class="headerlink" title="boolean(布尔型)"></a>boolean(布尔型)</h4><p>只有true 和 false 两个值，区别于C和C++。<br>在C和C++中，bool类型可以用数字赋值，非零即为真，零为假。但在Java中只有<code>boolean flag = true;</code> 和 <code>boolean flag = false;</code></p><h4 id="byte-short-int-long-float-double-数值型"><a href="#byte-short-int-long-float-double-数值型" class="headerlink" title="byte, short, int, long, float, double(数值型)"></a>byte, short, int, long, float, double(数值型)</h4><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">存储要求</th><th style="text-align:left">取值范围</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">byte</td><td style="text-align:left">1字节</td><td style="text-align:left">-128~127</td><td></td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">2字节</td><td style="text-align:left">-32768~32767</td><td></td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">4字节</td><td style="text-align:left">超过21亿</td><td></td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">8字节</td><td style="text-align:left">很大很大</td><td>需要在数值后加后缀L</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">4字节</td><td style="text-align:left">大约为±3.402E+38</td><td>需要在数值后加后缀F，有效位6~7位</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">8字节</td><td style="text-align:left">大约为±1.797E+308</td><td>需要在数值后加后缀D，有效位15位</td></tr></tbody></table><p>float和double类型表示的的数值是离散的，可能有一些小数就是无法表示，只能为近似值。不加F后缀的浮点数值默认为double类型。<br>float和double不能做移位运算。整形移位运算相当于除或乘2的移的位数的次幂。-1在计算机中存储形式为全一，无论移多少位都不变。</p><h3 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h3><p>对象(哎)是现实世界中的一个实体。<br>类是具有相同特征的对象的属性的集合。</p><h4 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[修饰符<span class="number">1</span>][修饰符<span class="number">2</span>][修饰符...]<span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i; <span class="comment">//类内的变量可以不用定义时赋值，数值变量系统默认赋值为零；逻辑变量boolean默认为false</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">float</span>[] f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//函数内的变量随手赋值是个好习惯，不赋值的话，在内存中是暂时没有这个变量的</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类实例化为对象"><a href="#类实例化为对象" class="headerlink" title="类实例化为对象"></a>类实例化为对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">Student s2;</span><br><span class="line">s2 = s1;</span><br><span class="line"><span class="comment">//一个对象变量没有实际包含一个对象，而仅仅是引用一个对象。</span></span><br><span class="line"><span class="comment">//new操作符返回的也是一个引用，即这个对象的存储地址。</span></span><br><span class="line"><span class="comment">//上面代码中的s2 = s1;仅仅是把s1保存的引用复制一份给s2，并没有复制这个对象</span></span><br><span class="line"><span class="comment">//可以将一个对象变量赋值为null，表明这个对象变量目前没有引用任何的对象</span></span><br><span class="line"><span class="comment">//如果一个对象没有任何的对象变量引用它，那么这个对象就成为垃圾对象，会被系统自动清理</span></span><br><span class="line"><span class="comment">//例如上面代码，如果添加s1 = null;那么这个对象不是垃圾对象，因为还有s2引用(指向)它。</span></span><br></pre></td></tr></table></figure><h3 id="数据声明"><a href="#数据声明" class="headerlink" title="数据声明"></a>数据声明</h3><p>没什么好说的。<code>[变量类型] [变量名] = [初始值];</code><br>说一些命名的规则和习惯吧(提高代码可读性)。    </p><blockquote><p>a. 必须是字母开头的由字母、数字、下划线组成的序列，区分大小写。虽然在命名可以使用$，但是不要使用。<br> b. 类名使用 UpperCamelCase(大驼峰) 风格，即每个单词首字母都要大写。<br> c. 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase(小驼峰) 风格，即从第二个单词开始首字母大写。如：studentName<br> d. 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br> e. 杜绝完全不规范的缩写， 避免望文不知义。<br> …</p></blockquote><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符<span class="number">1</span>][修饰符<span class="number">2</span>][修饰符..] [函数返回值] [函数名](参数<span class="number">1</span>，参数<span class="number">2</span>，参数..) &#123;函数体&#125;</span><br></pre></td></tr></table></figure><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p><strong><em>Java的函数参数传递只有一种方法：传值(call by value)</em></strong><br>java 成员变量(成员变量就是方法外部，类的内部定义的变量)存储在堆中的对象里面;局部变量就是方法或语句块内部定义的变量,局部变量必须初始化,局部变量的数据存在于栈内存中,栈内存中的局部变量随着方法的结束而出栈。</p><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Card</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rank;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap1</span><span class="params">(Card c1,Card c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Card temp = c1;</span><br><span class="line">c1 = c2;</span><br><span class="line">c2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap2</span><span class="params">(Card c1,Card c2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = c1.rank;</span><br><span class="line">c1.rank = c2.rank;</span><br><span class="line">c2.rank = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    Card c1 = <span class="keyword">new</span> Card();</span><br><span class="line">    c1.rank = <span class="number">5</span>;</span><br><span class="line">    Card c2 = <span class="keyword">new</span> Card();</span><br><span class="line">    c2.rank = <span class="number">6</span>;</span><br><span class="line">    swap1(c1,c2);</span><br><span class="line">    swap2(c1,c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果是swap1并没有实现数值交换；swap2实现了数值的变换。<br>分析：在main函数中，首先生成两个对象存储在堆中，并有引用变量c1,c2分别指向两个对象。在调用swap1，main函数的栈空间里<strong><em>复制</em></strong>c1,c2传递给函数，在函数中一波操作猛如虎，两个复制品的指向对象互换，然后函数结束，两个复制品出栈，然而原c1和c2的指向并没有改变。在swap2里，改的直接是存储在堆里的对象的变量，指向没有变化，但是内部的数值已经交换了。</p>]]></content>
    
    <summary type="html">
    
      java学习笔记的第一篇，内容主要有数据结构、函数等
    
    </summary>
    
    
      <category term="JAVA" scheme="http://liyzy.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计范式</title>
    <link href="http://liyzy.github.io/2018/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/"/>
    <id>http://liyzy.github.io/2018/06/27/数据库设计范式/</id>
    <published>2018-06-27T06:40:33.845Z</published>
    <updated>2018-10-06T11:31:04.358Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p></p><br><a id="more"></a><p></p><h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1.第一范式(1NF)"></a>1.第一范式(1NF)</h3><blockquote><p>定义：如果关系模式R的所有属性的域都是原子的，那么称关系模式R属于第一范式。</p></blockquote><p>通俗的讲，第一范式就是属性不可再分。比如地址属性，可以再分为省、市、县等属性，所以在这种情况下，地址属性所在的关系模式就不符合第一范式。</p><h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2.第二范式(2NF)"></a>2.第二范式(2NF)</h3><blockquote><p>定义：若R满足第一范式，且每一个非主属性完全函数依赖于主码，则R满足第二范式。</p></blockquote><hr><p>这里首先补充函数依赖的知识</p><h4 id="平凡依赖和非平凡依赖"><a href="#平凡依赖和非平凡依赖" class="headerlink" title="平凡依赖和非平凡依赖"></a>平凡依赖和非平凡依赖</h4><p>如果A-&gt;B，A是B的超集，则称此函数依赖为平凡的。<br>举个例子：A-&gt;A   AB-&gt;A    ABC-&gt;AB都是平凡依赖（此处的A、B、C为原子属性）<br>非平凡依赖就是不包含自己或包含自己的集决定自己的函数依赖。</p><h4 id="完全依赖和部分依赖"><a href="#完全依赖和部分依赖" class="headerlink" title="完全依赖和部分依赖"></a>完全依赖和部分依赖</h4><p>函数依赖A-&gt;B称为部分依赖的条件是存在A的真子集C使得C-&gt;B。即A中的一部分就可以决定B，不需要所有的属性来决定B。<br>反之，需要A中所有的属性才能来决定B，缺一不可，那么A-&gt;B就是一个完全依赖。</p><h4 id="传递依赖"><a href="#传递依赖" class="headerlink" title="传递依赖"></a>传递依赖</h4><p>如果A、B是两个属性集，存在A-&gt;B，如果c是一个属性，并且c不属于A或B，并且存在B-&gt;c，那么c就传递依赖于A。</p><hr><p>根据2NF的定义，我们可以知道，单属性主键的关系模式一定符合第二范式。</p><h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3.第三范式(3NF)"></a>3.第三范式(3NF)</h3><blockquote><p>定义：对于F*(F的闭包)中所有形如A-&gt;B的函数依赖（其中A、B都包含于R），以下至少一项成立：<br>    · A-&gt;B是一个平凡的函数依赖<br>    · A是R的一个超码<br>    · B-A中的每个属性c都包含于R的一个候选码中</p></blockquote><p>简单的说，若R满足第二范式，且每一个非主属性都不传递函数依赖于主码，则R满足第三范式。<br>即不存在如下依赖关系：<br>　　 关键字段 → 非关键字段x → 非关键字段y<br>举个例子：<br>假定学生关系表为Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)，关键字为单一关键字”学号”，因为存在如下决定关系：<br>　　 (学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话)<br>　　 这个数据库是符合2NF的，但是不符合3NF，因为存在如下决定关系：<br>　　 (学号) → (所在学院) → (学院地点, 学院电话)<br>　　 即存在非关键字段”学院地点”、”学院电话”对关键字段”学号”的传递函数依赖。 </p><h3 id="4-BC范式-BCNF"><a href="#4-BC范式-BCNF" class="headerlink" title="4.BC范式(BCNF)"></a>4.BC范式(BCNF)</h3><blockquote><p>定义：若R满足第三范式，且每一个主属性都不部分函数依赖或传递函数依赖于主码，则R满足第三范式。<br>· 每一个决定属性集（因素）都包含（候选）码<br>· R中的所有属性（主，非主属性）都完全函数依赖于码</p></blockquote><p>举个例子：<br>假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：<br>　　 (仓库ID, 存储物品ID) →(管理员ID, 数量)<br>　　 (管理员ID, 存储物品ID) → (仓库ID, 数量)<br>　　 所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：<br>　　 (仓库ID) → (管理员ID)<br>　　 (管理员ID) → (仓库ID)  即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。</p><hr><h3 id="BCNF分解算法"><a href="#BCNF分解算法" class="headerlink" title="BCNF分解算法"></a>BCNF分解算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(有违反BCNF的函数依赖)</span><br><span class="line">&#123;</span><br><span class="line">    找出违反BCNF的函数依赖A-&gt;B；</span><br><span class="line">    先计算A的闭包，且用A的闭包(除去A)替换B，并将其分解为&#123;A+&#125;和&#123;AU(R-(A+)&#125;;   <span class="comment">//比如A-&gt;B ，而&#123;A&#125;+=&#123;A,B,C&#125;，则用A-&gt;BC替换A-&gt;B;</span></span><br><span class="line">    求出分解后的关系满足的投影FD集合；</span><br><span class="line">    再看分解后的关系的FD集合是否满足BCNF，如果不满足，则继续分解</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：<br><img src="http://my.csdn.net/uploads/201204/27/1335509637_4564.jpg" alt=""></p><h3 id="3NF分解算法"><a href="#3NF分解算法" class="headerlink" title="3NF分解算法"></a>3NF分解算法</h3><p><img src="http://my.csdn.net/uploads/201204/27/1335509651_4573.jpg" alt=""></p><p><img src="http://my.csdn.net/uploads/201204/30/1335793674_5124.GIF" alt=""></p><p>致谢：<br>分解算法参考博客：<a href="https://blog.csdn.net/xiazdong/article/details/7517438" target="_blank" rel="noopener">https://blog.csdn.net/xiazdong/article/details/7517438</a></p>]]></content>
    
    <summary type="html">
    
      学习数据库，个人感觉设计范式是比较重要也是比较难的一部分，于是自己做了一些总结
    
    </summary>
    
    
      <category term="数据库" scheme="http://liyzy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库练习题(基础)</title>
    <link href="http://liyzy.github.io/2018/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%E9%A2%98(%E6%AF%94%E8%BE%83%E5%9F%BA%E7%A1%80)/"/>
    <id>http://liyzy.github.io/2018/06/13/数据库练习题(比较基础)/</id>
    <published>2018-06-13T03:32:31.969Z</published>
    <updated>2018-10-06T10:21:35.169Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p></p><br><a id="more"></a><p></p><h4 id="一、基本表的定义与删除"><a href="#一、基本表的定义与删除" class="headerlink" title="一、基本表的定义与删除"></a>一、基本表的定义与删除</h4><p>T1.<br>用SQL语句创建如下三张表：学生（Student）,课程表（Course）,和学生选课表（SC）,这三张表的结构如表1-1到表1-3所示。<br>表1-1 Student表结构</p><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">说明</th><th>数据类型</th><th style="text-align:left">约束</th></tr></thead><tbody><tr><td style="text-align:left">Sno</td><td style="text-align:left">学号</td><td>字符串</td><td style="text-align:left">长度为7，主码</td></tr><tr><td style="text-align:left">Sname</td><td style="text-align:left">姓名</td><td>字符串</td><td style="text-align:left">长度为10，非空</td></tr><tr><td style="text-align:left">Ssex</td><td style="text-align:left">性别</td><td>字符串</td><td style="text-align:left">长度为2，取‘男’或‘女’</td></tr><tr><td style="text-align:left">Sage</td><td style="text-align:left">年龄</td><td>整数</td><td style="text-align:left">取值15~45</td></tr><tr><td style="text-align:left">Sdept</td><td style="text-align:left">所在系</td><td>字符串</td><td style="text-align:left">长度为20    默认为‘计算机系’</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(</span><br><span class="line">Sno <span class="built_in">varchar</span>(<span class="number">7</span>) primary <span class="keyword">key</span>,</span><br><span class="line">Sname <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Ssex <span class="built_in">varchar</span>(<span class="number">2</span>) <span class="keyword">check</span>(Ssex=<span class="string">'男'</span> <span class="keyword">or</span> Ssex=<span class="string">'女'</span>),</span><br><span class="line">Sage <span class="built_in">int</span> <span class="keyword">check</span>(Sage&gt;=<span class="number">15</span> <span class="keyword">and</span> Sage &lt;=<span class="number">45</span>),</span><br><span class="line">Sdept <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span>(<span class="string">'计算机系'</span>));</span><br></pre></td></tr></table></figure><p>表1-2Course表结构</p><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">说明</th><th>数据类型</th><th style="text-align:left">约束</th></tr></thead><tbody><tr><td style="text-align:left">Cno</td><td style="text-align:left">课程号</td><td>字符串</td><td style="text-align:left">长度为10，主码</td></tr><tr><td style="text-align:left">Cname</td><td style="text-align:left">课程名</td><td>字符串</td><td style="text-align:left">长度为20，非空</td></tr><tr><td style="text-align:left">Ccredit</td><td style="text-align:left">学分</td><td>整数</td><td style="text-align:left">取值大于0</td></tr><tr><td style="text-align:left">Semster</td><td style="text-align:left">学期</td><td>整数</td><td style="text-align:left">取值大于0</td></tr><tr><td style="text-align:left">Cperiod</td><td style="text-align:left">学时</td><td>整数</td><td style="text-align:left">取值大于0</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Course(</span><br><span class="line">Cno <span class="built_in">varchar</span>(<span class="number">10</span>) primary <span class="keyword">key</span>,</span><br><span class="line">Cname <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Ccredit <span class="built_in">int</span> <span class="keyword">check</span>(Ccredit&gt;<span class="number">0</span>),</span><br><span class="line">Semster <span class="built_in">int</span> <span class="keyword">check</span>(Semster &gt;<span class="number">0</span>),</span><br><span class="line">Cperiodint <span class="keyword">check</span>(Cperiod&gt;<span class="number">0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>表1-3 SC表结构<br>表1-2Course表结构</p><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">说明</th><th>数据类型</th><th style="text-align:left">约束</th></tr></thead><tbody><tr><td style="text-align:left">Sno</td><td style="text-align:left">学号</td><td>字符串</td><td style="text-align:left">长度为7，主码，参照Student的外码</td></tr><tr><td style="text-align:left">Cno</td><td style="text-align:left">课程名</td><td>字符串</td><td style="text-align:left">长度为10，主码，参照Course</td></tr><tr><td style="text-align:left">Grade</td><td style="text-align:left">成绩</td><td>整数</td><td style="text-align:left">取值0~100</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC(</span><br><span class="line">Sno <span class="built_in">varchar</span>(<span class="number">7</span>),</span><br><span class="line">Cno <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">Grade <span class="built_in">int</span> <span class="keyword">check</span>(Grade &gt;=<span class="number">0</span> <span class="keyword">and</span> Grade &lt;=<span class="number">100</span>),</span><br><span class="line">primary <span class="keyword">key</span>(Sno,Cno),</span><br><span class="line">foreign <span class="keyword">key</span> (Sno) <span class="keyword">references</span> Student(Sno),</span><br><span class="line">foreign <span class="keyword">key</span> (Cno) <span class="keyword">references</span> Course(Cno));</span><br></pre></td></tr></table></figure><p>PS:<br>外码(键): 一个关系模式(r1)可能在它的属性中包含另一个关系模式(r2)的主码,这个属性在r1上称作参照r2的外码。关系r1称为外码依赖的参照关系，关系r2称为外码的被参照关系。FK一定来自另一个表的PK，FK是PK的子集。</p><p>如果外键或者主键要求命名，请使用以下语法<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constraint pk_Student_Sno primary key (Sno)</span><br><span class="line">constraint fk_Student_Sno foreign key (Sno) references Student(Sno)//SC表，参照表后边的属性可以省略</span><br></pre></td></tr></table></figure></p><p>已有表，添加外键<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SC</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> fk_Student_Sno </span><br><span class="line">foreign <span class="keyword">key</span> (Sno) </span><br><span class="line"><span class="keyword">references</span> Student(Sno);</span><br></pre></td></tr></table></figure></p><hr><h4 id="二、修改表结构"><a href="#二、修改表结构" class="headerlink" title="二、修改表结构"></a>二、修改表结构</h4><p>T2.<br>为SC表添加“选课类别”列，此列的定义为XKLB char(4)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table SC add XKLB char(4);</span><br></pre></td></tr></table></figure><p>T3.<br>将新添加的XKLB的类型修改为char(6)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table SC alter column XKLB char(6);</span><br></pre></td></tr></table></figure></p><p>T4.<br>删除Course表的Cperiod列<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Course <span class="keyword">drop</span> <span class="keyword">column</span> Cperiod;</span><br></pre></td></tr></table></figure></p><p>T5.<br>重命名Student表的Ssex列为sex<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_rename 'Student.Ssex','sex';</span><br></pre></td></tr></table></figure></p><hr><h4 id="三、数据查询功能"><a href="#三、数据查询功能" class="headerlink" title="三、数据查询功能"></a>三、数据查询功能</h4><p>表3-1 Student表数据</p><table><thead><tr><th style="text-align:left">Sno</th><th style="text-align:left">Sname</th><th style="text-align:left">Ssex</th><th style="text-align:left">Sage</th><th style="text-align:left">Sdept</th></tr></thead><tbody><tr><td style="text-align:left">9512101</td><td style="text-align:left">李勇</td><td style="text-align:left">男</td><td style="text-align:left">19</td><td style="text-align:left">计算机系</td></tr><tr><td style="text-align:left">9512102</td><td style="text-align:left">刘晨</td><td style="text-align:left">男</td><td style="text-align:left">20</td><td style="text-align:left">计算机系</td></tr><tr><td style="text-align:left">9512103</td><td style="text-align:left">王敏</td><td style="text-align:left">女</td><td style="text-align:left">20</td><td style="text-align:left">计算机系</td></tr><tr><td style="text-align:left">9521101</td><td style="text-align:left">张立</td><td style="text-align:left">男</td><td style="text-align:left">22</td><td style="text-align:left">信息系</td></tr><tr><td style="text-align:left">9521102</td><td style="text-align:left">吴宾</td><td style="text-align:left">女</td><td style="text-align:left">21</td><td style="text-align:left">信息系</td></tr><tr><td style="text-align:left">9521103</td><td style="text-align:left">张海</td><td style="text-align:left">男</td><td style="text-align:left">20</td><td style="text-align:left">信息系</td></tr><tr><td style="text-align:left">9531101</td><td style="text-align:left">钱小平</td><td style="text-align:left">女</td><td style="text-align:left">18</td><td style="text-align:left">数学系</td></tr><tr><td style="text-align:left">9531102</td><td style="text-align:left">王大力</td><td style="text-align:left">男</td><td style="text-align:left">19</td><td style="text-align:left">数学系</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student</span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">(<span class="string">'9512101'</span>,<span class="string">'李勇'</span>,<span class="string">'男'</span>,<span class="number">19</span>,<span class="string">'计算机系'</span>),</span><br><span class="line">(<span class="string">'9512102'</span>,<span class="string">'刘晨'</span>,<span class="string">'男'</span>,<span class="number">20</span>,<span class="string">'计算机系'</span>),</span><br><span class="line">(<span class="string">'9512103'</span>,<span class="string">'王敏'</span>,<span class="string">'女'</span>,<span class="number">20</span>,<span class="string">'计算机系'</span>),</span><br><span class="line">(<span class="string">'9521101'</span>,<span class="string">'张立'</span>,<span class="string">'男'</span>,<span class="number">22</span>,<span class="string">'信息系'</span>),</span><br><span class="line">(<span class="string">'9521102'</span>,<span class="string">'吴宾'</span>,<span class="string">'女'</span>,<span class="number">21</span>,<span class="string">'信息系'</span>),</span><br><span class="line">(<span class="string">'9521103'</span>,<span class="string">'张海'</span>,<span class="string">'男'</span>,<span class="number">20</span>,<span class="string">'信息系'</span>),</span><br><span class="line">(<span class="string">'9531101'</span>,<span class="string">'钱小平'</span>,<span class="string">'女'</span>,<span class="number">18</span>,<span class="string">'数学系'</span>),</span><br><span class="line">(<span class="string">'9531102'</span>,<span class="string">'王大力'</span>,<span class="string">'男'</span>,<span class="number">19</span>,<span class="string">'数学系'</span>);</span><br></pre></td></tr></table></figure><p>表3-2 Course表数据</p><table><thead><tr><th style="text-align:left">Cno</th><th style="text-align:left">Cname</th><th style="text-align:left">Ccredit</th><th style="text-align:left">Semster</th></tr></thead><tbody><tr><td style="text-align:left">C01</td><td style="text-align:left">计算机文化学</td><td style="text-align:left">3</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">C02</td><td style="text-align:left">VB</td><td style="text-align:left">2</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">C03</td><td style="text-align:left">计算机网络</td><td style="text-align:left">4</td><td style="text-align:left">7</td></tr><tr><td style="text-align:left">C04</td><td style="text-align:left">数据库基础</td><td style="text-align:left">6</td><td style="text-align:left">6</td></tr><tr><td style="text-align:left">C05</td><td style="text-align:left">高等数学</td><td style="text-align:left">8</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">C06</td><td style="text-align:left">数据结构</td><td style="text-align:left">5</td><td style="text-align:left">4</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course(Cno,Cname,Ccredit,Semster)</span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">(<span class="string">'C01'</span>,<span class="string">'计算机文化学'</span>,<span class="number">3</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="string">'C02'</span>,<span class="string">'VB'</span>,<span class="number">2</span>,<span class="number">3</span>),</span><br><span class="line">(<span class="string">'C03'</span>,<span class="string">'计算机网络'</span>,<span class="number">4</span>,<span class="number">7</span>),</span><br><span class="line">(<span class="string">'C04'</span>,<span class="string">'数据库基础'</span>,<span class="number">6</span>,<span class="number">6</span>),</span><br><span class="line">(<span class="string">'C05'</span>,<span class="string">'高等数学'</span>,<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="string">'C06'</span>,<span class="string">'数据结构'</span>,<span class="number">5</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>表 3-3 SC表数据</p><table><thead><tr><th style="text-align:left">Sno</th><th style="text-align:left">Cno</th><th style="text-align:left">Grade</th><th style="text-align:left">XKLB</th></tr></thead><tbody><tr><td style="text-align:left">9512101</td><td style="text-align:left">c01</td><td style="text-align:left">90</td><td style="text-align:left">必修</td></tr><tr><td style="text-align:left">9512101</td><td style="text-align:left">c02</td><td style="text-align:left">86</td><td style="text-align:left">选修</td></tr><tr><td style="text-align:left">9512101</td><td style="text-align:left">c06</td><td style="text-align:left"><null></null></td><td style="text-align:left">必修</td></tr><tr><td style="text-align:left">9512102</td><td style="text-align:left">c02</td><td style="text-align:left">78</td><td style="text-align:left">选修</td></tr><tr><td style="text-align:left">9512102</td><td style="text-align:left">c04</td><td style="text-align:left">66</td><td style="text-align:left">必修</td></tr><tr><td style="text-align:left">9521102</td><td style="text-align:left">c01</td><td style="text-align:left">82</td><td style="text-align:left">选修</td></tr><tr><td style="text-align:left">9521102</td><td style="text-align:left">c02</td><td style="text-align:left">75</td><td style="text-align:left">选修</td></tr><tr><td style="text-align:left">9521102</td><td style="text-align:left">c04</td><td style="text-align:left">92</td><td style="text-align:left">必修</td></tr><tr><td style="text-align:left">9521102</td><td style="text-align:left">c05</td><td style="text-align:left">50</td><td style="text-align:left">必修</td></tr><tr><td style="text-align:left">9521103</td><td style="text-align:left">c02</td><td style="text-align:left">68</td><td style="text-align:left">选修</td></tr><tr><td style="text-align:left">9521103</td><td style="text-align:left">c06</td><td style="text-align:left"><null></null></td><td style="text-align:left">必修</td></tr><tr><td style="text-align:left">9531101</td><td style="text-align:left">c01</td><td style="text-align:left">80</td><td style="text-align:left">选修</td></tr><tr><td style="text-align:left">9531101</td><td style="text-align:left">c05</td><td style="text-align:left">95</td><td style="text-align:left">必修</td></tr><tr><td style="text-align:left">9531102</td><td style="text-align:left">c05</td><td style="text-align:left">85</td><td style="text-align:left">必修</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC </span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">(<span class="string">'9512101'</span>,<span class="string">'c01'</span>,<span class="number">90</span>,<span class="string">'必修'</span>),</span><br><span class="line">(<span class="string">'9512101'</span>,<span class="string">'c02'</span>,<span class="number">86</span>,<span class="string">'选修'</span>),</span><br><span class="line">(<span class="string">'9512101'</span>,<span class="string">'c06'</span>,<span class="literal">NULL</span>,<span class="string">'必修'</span>),</span><br><span class="line">(<span class="string">'9512102'</span>,<span class="string">'c02'</span>,<span class="number">78</span>,<span class="string">'选修'</span>),</span><br><span class="line">(<span class="string">'9512102'</span>,<span class="string">'c04'</span>,<span class="number">66</span>,<span class="string">'必修'</span>),</span><br><span class="line">(<span class="string">'9521102'</span>,<span class="string">'c01'</span>,<span class="number">82</span>,<span class="string">'选修'</span>),</span><br><span class="line">(<span class="string">'9521102'</span>,<span class="string">'c02'</span>,<span class="number">75</span>,<span class="string">'选修'</span>),</span><br><span class="line">(<span class="string">'9521102'</span>,<span class="string">'c04'</span>,<span class="number">92</span>,<span class="string">'必修'</span>),</span><br><span class="line">(<span class="string">'9521102'</span>,<span class="string">'c05'</span>,<span class="number">50</span>,<span class="string">'必修'</span>),</span><br><span class="line">(<span class="string">'9521103'</span>,<span class="string">'c02'</span>,<span class="number">68</span>,<span class="string">'选修'</span>),</span><br><span class="line">(<span class="string">'9521103'</span>,<span class="string">'c06'</span>,<span class="literal">NULL</span>,<span class="string">'必修'</span>),</span><br><span class="line">(<span class="string">'9531101'</span>,<span class="string">'c01'</span>,<span class="number">80</span>,<span class="string">'选修'</span>),</span><br><span class="line">(<span class="string">'9531101'</span>,<span class="string">'c05'</span>,<span class="number">95</span>,<span class="string">'必修'</span>),</span><br><span class="line">(<span class="string">'9531102'</span>,<span class="string">'c05'</span>,<span class="number">85</span>,<span class="string">'必修'</span>);</span><br></pre></td></tr></table></figure><p>T6.<br>查询全体学生的学号与姓名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select Sno,Sname </span><br><span class="line">from Student;</span><br></pre></td></tr></table></figure></p><p>T7.<br>查询全体学生的姓名，学号和所在系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select Sno,Sname,Sdept </span><br><span class="line">from Student;</span><br></pre></td></tr></table></figure></p><p>T8.<br>查询全体学生的所有信息（三张表以上的关联查询）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from Student left join SC on Student.Sno=SC.Sno left join Course on SC.Cno=Course.Cno</span><br></pre></td></tr></table></figure></p><p>T9.<br>查询全体学生的姓名及其出生年份<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,<span class="number">2018</span>-Sage <span class="keyword">as</span> <span class="string">'出生年份'</span></span><br><span class="line"><span class="keyword">from</span> Student</span><br></pre></td></tr></table></figure></p><p>T10.<br>查询全体学生的姓名和出生年份，并在出生年份列前加入一个列，此列的每行数据均为“Year of Birth”常量值<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,<span class="string">'Year of Birth'</span>,<span class="number">2018</span>-Sage <span class="keyword">as</span> <span class="string">'出生年份'</span></span><br><span class="line"><span class="keyword">from</span> Student</span><br></pre></td></tr></table></figure></p><p>T11.<br>在选课表（SC）中查询有哪些学生选修了课程，并列出学生的学号<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> Sno</span><br><span class="line"><span class="keyword">from</span> SC</span><br></pre></td></tr></table></figure></p><p>T12.<br>查询计算机系全体学生的姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Sdept=<span class="string">'计算机系'</span></span><br></pre></td></tr></table></figure></p><p>T13.<br>查询所有年龄在20岁以下的学生的姓名及年龄<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Sage</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sage&lt;<span class="number">20</span></span><br></pre></td></tr></table></figure></p><p>T14.<br>查询考试成绩不及格的学生的姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> Student,SC </span><br><span class="line"><span class="keyword">where</span> Student.Sno=SC.Sno <span class="keyword">and</span> SC.Grade&lt;<span class="number">60</span></span><br></pre></td></tr></table></figure></p><p>T15.<br>查询年龄在20~23岁之间的学生的姓名，所在系和年龄<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Sdept,Sage</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sage <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">23</span></span><br></pre></td></tr></table></figure></p><p>T16.<br>查询年龄不在20~23之间的学生的姓名，所在系和年龄<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Sdept,Sage</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sage <span class="keyword">not</span> <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">23</span></span><br></pre></td></tr></table></figure></p><p>T17.<br>查询信息系，数学系和计算机系学生的姓名和性别<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Ssex</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sdept <span class="keyword">in</span> (<span class="string">'信息系'</span>,<span class="string">'数学系'</span>,<span class="string">'计算机系'</span>)</span><br></pre></td></tr></table></figure></p><p>T18.<br>查询既不属于信息系，数学系，也不属于计算机系的学生的姓名和性别<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Ssex</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sdept <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'信息系'</span>,<span class="string">'数学系'</span>,<span class="string">'计算机系'</span>)</span><br></pre></td></tr></table></figure></p><p>T19.<br>查询学生表中姓“张”的学生的详细信息<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sname <span class="keyword">like</span> <span class="string">'张%'</span></span><br></pre></td></tr></table></figure></p><p>T20.<br>查询学生表中姓“张”，姓“李”和姓“刘”的学生的情况<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sname <span class="keyword">like</span> <span class="string">'张%'</span> <span class="keyword">or</span> Sname <span class="keyword">like</span> <span class="string">'李%'</span> <span class="keyword">or</span> Sname <span class="keyword">like</span> <span class="string">'刘%'</span></span><br></pre></td></tr></table></figure></p><p>使用下边的这种写法更加简便<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sname <span class="keyword">like</span> <span class="string">'[张李刘]%'</span></span><br></pre></td></tr></table></figure></p><p>T21.<br>查询名字中第2个字为“小”或“大”字的学生的姓名和学号<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Sno</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sname <span class="keyword">like</span> <span class="string">'_[小大]%'</span></span><br></pre></td></tr></table></figure></p><p>T22.<br>查询所有不姓“刘”的学生的姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sname <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">'刘%'</span></span><br></pre></td></tr></table></figure></p><p>T23.<br>从学生表中查询学号的最后一位不是2，3，5的学生的情况<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sno <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">'%[235]'</span></span><br></pre></td></tr></table></figure></p><p>T24.<br>查询无考试成绩的学生的学号和相应的课程号<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,Cno</span><br><span class="line"><span class="keyword">from</span> SC </span><br><span class="line"><span class="keyword">where</span> Grade <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure></p><p>T25.<br>查询所有有考试成绩的学生的学号和课程号<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,Cno</span><br><span class="line"><span class="keyword">from</span> SC </span><br><span class="line"><span class="keyword">where</span> Grade <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure></p><p>T26.<br>查询计算机系年龄在20岁以下的学生的姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sdept=<span class="string">'计算机系'</span> <span class="keyword">and</span> Sage&lt;<span class="number">20</span></span><br></pre></td></tr></table></figure></p><p>T27.<br>将学生按年龄升序排序<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Sage <span class="keyword">asc</span></span><br></pre></td></tr></table></figure></p><p>T28.<br>查询选修了课程“c02”的学生的学号及其成绩，查询结果按成绩降序排列<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,Grade</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> Cno=<span class="string">'C02'</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Grade <span class="keyword">desc</span></span><br></pre></td></tr></table></figure></p><p>T29.<br>查询全体学生的信息，查询结果按所在系的系名升序排列，同一系的学生按年龄降序排列<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Sdept,Sage <span class="keyword">desc</span></span><br></pre></td></tr></table></figure></p><p>T30.<br>统计学生总人数<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">from</span> Student</span><br></pre></td></tr></table></figure></p><p>T31.<br>统计选修了选修课程的学生的人数<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> Sno)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> XKLB=<span class="string">'选修'</span></span><br></pre></td></tr></table></figure></p><p>T32.<br>计算学号为9512101的学生的考试总成绩之和<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(Grade)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> Sno=<span class="string">'9512101'</span></span><br></pre></td></tr></table></figure></p><p>T33.<br>计算课程“c01”的学生的考试平均成绩<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(Grade)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> Cno=<span class="string">'C01'</span></span><br></pre></td></tr></table></figure></p><p>T34.<br>查询选修了课程“c01”的学生的最高分和最低分<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(Grade),<span class="keyword">min</span>(Grade)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> Cno=<span class="string">'C01'</span></span><br></pre></td></tr></table></figure></p><p>T35.<br>统计每门课程的选课人数，列出课程号和人数<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Cno,<span class="keyword">count</span>(Sno) <span class="keyword">as</span> <span class="string">'选课人数'</span></span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Cno</span><br></pre></td></tr></table></figure></p><p>T36.<br>查询每名学生的选课门数和平均成绩<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,<span class="keyword">count</span>(Cno) <span class="keyword">as</span> <span class="string">'选课门数'</span>,<span class="keyword">avg</span>(Grade) <span class="keyword">as</span> <span class="string">'平均成绩'</span></span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Sno</span><br></pre></td></tr></table></figure></p><p>T37.<br>查询选修了3门以上课程的学生的学号<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Sno</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(Cno)&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>T38.<br>查询选课门数等于或大于4门的学生的平均成绩和选课门数<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,<span class="keyword">avg</span>(Grade) <span class="keyword">as</span> <span class="string">'平均成绩'</span>,<span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="string">'选课门数'</span></span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Sno</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;=<span class="number">4</span></span><br></pre></td></tr></table></figure></p><hr><h4 id="四、多表查询"><a href="#四、多表查询" class="headerlink" title="四、多表查询"></a>四、多表查询</h4><p>T39.<br>查询每个学生的情况及其选课的情况<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> SC <span class="keyword">on</span> Student.Sno=SC.Sno</span><br></pre></td></tr></table></figure></p><p>T40.<br>查询计算机系学生的选课情况，要求列出学生的名字，所修课的课程号和成绩<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Cno,Grade</span><br><span class="line"><span class="keyword">from</span> Student,SC</span><br><span class="line"><span class="keyword">where</span> Student.Sno=Sc.Sno <span class="keyword">and</span> Sdept=<span class="string">'计算机系'</span></span><br></pre></td></tr></table></figure></p><p>T41.<br>查询信息系选修VB课程的学生的成绩，要求列出学生姓名，课程名和成绩<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Cname,Grade</span><br><span class="line"><span class="keyword">from</span> Student,SC,Course</span><br><span class="line"><span class="keyword">where</span> Student.Sno=SC.Sno <span class="keyword">and</span> SC.Cno=Course.Cno <span class="keyword">and</span> sdept=<span class="string">'信息系'</span> <span class="keyword">and</span> Cname=<span class="string">'VB'</span></span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Cname,Grade </span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">join</span> SC <span class="keyword">on</span> Student.Sno=SC.Sno <span class="keyword">join</span> Course <span class="keyword">on</span> Course.Cno=SC.Cno </span><br><span class="line"><span class="keyword">where</span> Sdept = <span class="string">'信息系'</span> <span class="keyword">and</span> Cname = <span class="string">'VB'</span>;</span><br></pre></td></tr></table></figure><p>T42.<br>查询所有选修了VB课程的学生的情况，要求列出学生姓名和所在的系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Sdept</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">join</span> SC <span class="keyword">on</span> Student.Sno=SC.Sno <span class="keyword">join</span> Course <span class="keyword">on</span> Course.Cno=SC.Cno </span><br><span class="line"><span class="keyword">where</span> Cname=<span class="string">'VB'</span></span><br></pre></td></tr></table></figure></p><p>T43.<br>查询与刘晨在同一个系学习的学生的姓名和所在系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Sdept</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Sdept=(<span class="keyword">select</span> Sdept</span><br><span class="line">             <span class="keyword">from</span> Student</span><br><span class="line">             <span class="keyword">where</span> Sname=<span class="string">'刘晨'</span>)</span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s2.Sname,s2.Sdept</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">as</span> s1,Student <span class="keyword">as</span> s2</span><br><span class="line"><span class="keyword">where</span> s1.Sname=<span class="string">'刘晨'</span> <span class="keyword">and</span> s2.Sname !=<span class="string">'刘晨'</span> <span class="keyword">and</span> s1.Sdept=s2.Sdept</span><br></pre></td></tr></table></figure><p>T44.<br>查询学生的选课情况，包括选修课程的学生和没有修课的学生<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">left</span> <span class="keyword">join</span> SC <span class="keyword">on</span> Student.Sno=SC.Sno</span><br></pre></td></tr></table></figure></p><p>T45.<br>查询数学系成绩在80分以上的学生的学号，姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Student.Sno,Sname</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">join</span> SC <span class="keyword">on</span> Student.Sno=SC.Sno</span><br><span class="line"><span class="keyword">where</span> Sdept=<span class="string">'数学系'</span> <span class="keyword">and</span> Grade&gt;<span class="number">80</span></span><br></pre></td></tr></table></figure></p><p>T46.<br>查询计算机系考试成绩最高的学生的姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">join</span> SC <span class="keyword">on</span> Student.Sno=SC.Sno</span><br><span class="line"><span class="keyword">where</span> Sdept=<span class="string">'计算机系'</span> <span class="keyword">and</span> Grade=(<span class="keyword">select</span> <span class="keyword">max</span>(Grade)</span><br><span class="line">                                 <span class="keyword">from</span> Student <span class="keyword">join</span> SC <span class="keyword">on</span> Student.Sno=SC.Sno</span><br><span class="line"> <span class="keyword">Group</span> <span class="keyword">by</span> Sdept</span><br><span class="line"> <span class="keyword">having</span> Sdept=<span class="string">'计算机系'</span>)</span><br></pre></td></tr></table></figure></p><hr><h4 id="五、嵌套子查询"><a href="#五、嵌套子查询" class="headerlink" title="五、嵌套子查询"></a>五、嵌套子查询</h4><p>(T43)</p><p>T47.<br>查询成绩大于90分的学生的学号和姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,Sname</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Sno <span class="keyword">in</span> (<span class="keyword">select</span> Sno</span><br><span class="line">              <span class="keyword">from</span> SC</span><br><span class="line">              <span class="keyword">where</span> Grade&gt;<span class="number">90</span>)</span><br></pre></td></tr></table></figure></p><p>T48.<br>查询选修了“数据库基础”课程的学生的学号和姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,Sname</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Sno <span class="keyword">in</span> (<span class="keyword">select</span> Sno</span><br><span class="line">              <span class="keyword">from</span> SC </span><br><span class="line">              <span class="keyword">where</span> Cno <span class="keyword">in</span> (<span class="keyword">select</span> Cno</span><br><span class="line">                            <span class="keyword">from</span> Course</span><br><span class="line">                            <span class="keyword">where</span> Cname=<span class="string">'数据库基础'</span>))</span><br></pre></td></tr></table></figure></p><p>T49.<br>查询选修了刘晨没有选修的课程的学生的学号和所在系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,Sdept</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Sno <span class="keyword">in</span> (<span class="keyword">select</span> Sno</span><br><span class="line">              <span class="keyword">from</span> SC</span><br><span class="line">              <span class="keyword">where</span> Cno <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> Cno</span><br><span class="line">                                <span class="keyword">from</span> SC</span><br><span class="line">                                <span class="keyword">where</span> Sno=(<span class="keyword">select</span> Sno</span><br><span class="line">                                           <span class="keyword">from</span> Student</span><br><span class="line">                                           <span class="keyword">where</span> Sname=<span class="string">'刘晨'</span>)))</span><br></pre></td></tr></table></figure></p><p>T50.<br>查询选修了课程“c02”且成绩高于此课程的平均成绩的学生的学号和成绩<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,Grade</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> Cno=<span class="string">'C02'</span> <span class="keyword">and</span> Grade&gt;(<span class="keyword">select</span> <span class="keyword">avg</span>(Grade)</span><br><span class="line">                           <span class="keyword">from</span> SC</span><br><span class="line">                           <span class="keyword">where</span> Cno=<span class="string">'C02'</span>)</span><br></pre></td></tr></table></figure></p><p>T51.<br>查询选修了课程“c01”的学生姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Sno <span class="keyword">in</span> (<span class="keyword">select</span> Sno</span><br><span class="line">              <span class="keyword">from</span> SC</span><br><span class="line">              <span class="keyword">where</span> Cno=<span class="string">'C01'</span>)</span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> *</span><br><span class="line">              <span class="keyword">from</span> SC</span><br><span class="line">              <span class="keyword">where</span> Sno=Student.Sno <span class="keyword">and</span> Cno=<span class="string">'C01'</span>)</span><br></pre></td></tr></table></figure><p>PS.一般来说，在SQL中in子查询都可以用exists代替。EXISTS子查询可以看成是一个独立的查询系统，只为了获取真假逻辑值，EXISTS子查询与外查询查询的表是两个完全独立的毫无关系的表，当我们在子查询中添加了Sno关联之后，EXISTS子查询与外查询查询的表就统一了，是二者组合组建的虚表，是同一个表（这样当子查询查询到虚表中当前行的Cno为C01时，则将虚表当前行中对应的Sname查询到了）.<br>　　重点在于Sno关联之上，添加Sno关联，数据库会先将两张表通过Sno关联组合成一张虚表，所有的查询操作都在这张虚表上完成。</p><hr><h4 id="六、自查询"><a href="#六、自查询" class="headerlink" title="六、自查询"></a>六、自查询</h4><p>T52.查询所有成绩大于C01课程最高成绩的学生的学号<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SC2.Sno</span><br><span class="line"><span class="keyword">from</span> SC <span class="keyword">as</span> SC1,SC <span class="keyword">as</span> SC2</span><br><span class="line"><span class="keyword">where</span> SC1.Sno=SC2.Sno <span class="keyword">and</span> SC1.Cno=SC2.Cno <span class="keyword">and</span> SC2.Grade&gt;all(<span class="keyword">select</span> Grade</span><br><span class="line">                                                            <span class="keyword">from</span> SC</span><br><span class="line">                                                            <span class="keyword">where</span> SC.Cno=<span class="string">'C01'</span>)</span><br></pre></td></tr></table></figure></p><hr><h4 id="七、更新数据"><a href="#七、更新数据" class="headerlink" title="七、更新数据"></a>七、更新数据</h4><p>T53.<br>将所有学生的年龄加1<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> Student</span><br><span class="line"><span class="keyword">set</span> Sage=Sage+<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>T54.<br>将“9512101”学生的年龄改为21岁<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> Student</span><br><span class="line"><span class="keyword">set</span> Sage=<span class="number">21</span></span><br><span class="line"><span class="keyword">where</span> Sno=<span class="string">'9512101'</span></span><br></pre></td></tr></table></figure></p><p>T55.<br>将计算机系学生的成绩加5分<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> SC</span><br><span class="line"><span class="keyword">set</span> Grade=Grade+<span class="number">5</span></span><br><span class="line"><span class="keyword">where</span> Sno <span class="keyword">in</span> (<span class="keyword">select</span> Sno</span><br><span class="line">              <span class="keyword">from</span> Student</span><br><span class="line">              <span class="keyword">where</span> Sdept=<span class="string">'计算机系'</span>)</span><br></pre></td></tr></table></figure></p><hr><h4 id="八、删除数据"><a href="#八、删除数据" class="headerlink" title="八、删除数据"></a>八、删除数据</h4><p>T56.<br>删除所有学生的选课记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> SC</span><br></pre></td></tr></table></figure></p><p>T57.<br>删除所有不及格学生的选课记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> Grade&lt;<span class="number">60</span></span><br></pre></td></tr></table></figure></p><p>T58.<br>删除计算机系不及格学生的选课记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> Grade&lt;<span class="number">60</span> <span class="keyword">and</span> Sno <span class="keyword">in</span> (<span class="keyword">select</span> Sno</span><br><span class="line">                           <span class="keyword">from</span> Student</span><br><span class="line">                           <span class="keyword">where</span> Sdept=<span class="string">'计算机系'</span>)</span><br></pre></td></tr></table></figure></p><hr><p>数据来源于网络，整理@lihui<br>测试代码：<br><a href="https://Liyzy.github.io/2018/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%E9%A2%98%28%E6%AF%94%E8%BE%83%E5%9F%BA%E7%A1%80%29/create_table.sql">建表代码</a><br><a href="http://Liyzy.github.io/2018/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%E9%A2%98%28%E6%AF%94%E8%BE%83%E5%9F%BA%E7%A1%80%29/T.sql">题目代码</a><br>测试环境：SQL Server 2017</p><hr><p>考试结束了，烤糊了😭…附上题目留与后人吧<br><strong>2017-2018学年大连理工大学软件学院数据库考试题目说明</strong></p><p><font color="#0099ff">20分 </font>   10个选择（比较简单，复习注意概念，比如DBS，DB，DBMS都是什么。其中有两个有关事务的题，即第十二章内容，分别是ACID的四个性质内容和结束事务并回滚的语句是什么问题）</p><p><font color="#0099ff">50分 </font>     4个关系代数，6个SQL，一个5分。考了not exists和not in 相互转换, not exists…except结构,  标量子查询，分组聚集的内容（懵的一匹@_@）</p><p><font color="#0099ff">10分 </font>     范式分解 属性闭包和候选码（6分），判断第几范式（2分），BCNF分解（2分）</p><p><font color="#0099ff">20分 </font>     ER图 画ER图（10分），转换成关系模式（10分）。<br>（回忆版）商店记录商品信息和客户信息，商品信息包括商品编号、名称、单价等，客户信息包括客户编号、客户姓名、电话等。一个顾客可以购买多个商品，一件商品可以购买不同数量，一次性的购物记录在一个购物单里，商品销售时价格可以调整。要求商店可以查询一个客户的消费记录和消费总额。根据题意设计ER图，可以自己添加必要属性。</p>]]></content>
    
    <summary type="html">
    
      近期要数据库考试了，复习一波，题还是很基础的~
    
    </summary>
    
    
      <category term="数据库" scheme="http://liyzy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【python learning 1】从Hello world!开始（print()函数解析）</title>
    <link href="http://liyzy.github.io/2018/06/06/%E3%80%90python%20learning%E3%80%91hello%20world/"/>
    <id>http://liyzy.github.io/2018/06/06/【python learning】hello world/</id>
    <published>2018-06-06T10:40:37.079Z</published>
    <updated>2018-10-06T14:15:34.868Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><p></p><br><a id="more"></a><br>老规矩，学习一门语言，肯定要从Hello world开始啦<p></p><p>python2<br><code>print &quot;Hello world!&quot;</code></p><p>python3<br><code>print(&quot;Hello world!&quot;)</code><br>不同的原因是，在python3中，print只作为一个函数调用，括号中的内容作为函数的参数。</p><p>但是，在python2中使用括号也没有问题。</p><p>print()函数:</p><p><code>print（*objects,sep=&#39; &#39;,end=&#39;\n&#39;,file=sys.stdout,flush=False）</code></p><p>参数意义</p><p>*objects 表示要输出的值，可以是多个，用逗号分隔</p><p>sep 表示多个输出值之间的间隔，可以自己赋值，默认为一个空格</p><p>end 表示输出语句最末尾附加的字符串，默认为’\n’，即换行    #ps: 在Python2中，如果不想换行则在输出语句的末尾加一个逗号，Python3中写成print(“hhh”,end=’’)就好了。</p><p>file 表示输出的对象，可以是文件也可以是数据流，默认是sys.stdout</p><p>flush 表示是否立刻将输出语句输出的目标对象，默认为False</p>]]></content>
    
    <summary type="html">
    
      这是python自学的记录第一篇，主要内容有print函数
    
    </summary>
    
    
      <category term="python" scheme="http://liyzy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://liyzy.github.io/2018/06/04/hello-world/"/>
    <id>http://liyzy.github.io/2018/06/04/hello-world/</id>
    <published>2018-06-04T07:44:10.983Z</published>
    <updated>2018-10-06T13:51:07.418Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      这是我的第一篇blog哦~
    
    </summary>
    
    
  </entry>
  
</feed>
